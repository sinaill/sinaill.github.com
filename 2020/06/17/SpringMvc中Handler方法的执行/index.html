<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="SpringMVC," />










<meta name="description" content="需要注意的类invocableHandlerMethodHandlerMethodParameterHandlerMethodParameter为HandlerMethod的内部类和MethodParameter的子类 先看MethodParameter private final Method method &#x2F;&#x2F;指向方法 private final int parameterIndex; &#x2F;&#x2F;本">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC中Handler方法的执行">
<meta property="og:url" content="http://yoursite.com/2020/06/17/SpringMvc%E4%B8%ADHandler%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="需要注意的类invocableHandlerMethodHandlerMethodParameterHandlerMethodParameter为HandlerMethod的内部类和MethodParameter的子类 先看MethodParameter private final Method method &#x2F;&#x2F;指向方法 private final int parameterIndex; &#x2F;&#x2F;本">
<meta property="article:published_time" content="2020-06-16T17:43:37.227Z">
<meta property="article:modified_time" content="2020-06-16T17:43:37.227Z">
<meta property="article:author" content="sinaill">
<meta property="article:tag" content="SpringMVC">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/17/SpringMvc中Handler方法的执行/"/>





  <title>SpringMVC中Handler方法的执行 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E4%B8%ADHandler%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SpringMVC中Handler方法的执行</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="需要注意的类"><a href="#需要注意的类" class="headerlink" title="需要注意的类"></a>需要注意的类</h3><h4 id="invocableHandlerMethod"><a href="#invocableHandlerMethod" class="headerlink" title="invocableHandlerMethod"></a>invocableHandlerMethod</h4><h4 id="HandlerMethodParameter"><a href="#HandlerMethodParameter" class="headerlink" title="HandlerMethodParameter"></a>HandlerMethodParameter</h4><p><code>HandlerMethodParameter</code>为<code>HandlerMethod</code>的内部类和<code>MethodParameter</code>的子类</p>
<p>先看<code>MethodParameter</code></p>
<pre><code>private final Method method
//指向方法
private final int parameterIndex;
//本方法参数在方法中的形参位置index，从0开始
</code></pre><pre><code></code></pre><h4 id="argumentResolver"><a href="#argumentResolver" class="headerlink" title="argumentResolver"></a>argumentResolver</h4><p>创建<code>InvocableHandlerMethod</code>的时候，将<code>Spring</code>给<code>RequestMappingHandlerAdapter</code>注入的<code>argumentResovlers</code>参数传递给<code>InvocableHandlerMethod</code>，用来对通过<code>GenericTypeResolver</code>确定方法参数类型之后的<code>MethodParameter</code>进行处理</p>
<p>例如<code>RequestParamMethodArgumentResolver</code>，它的<code>supportParameter</code>方法，即验证是否适用于当前参数</p>
<pre><code>@Override
public boolean supportsParameter(MethodParameter parameter) {
    Class&lt;?&gt; paramType = parameter.getParameterType();
    if (parameter.hasParameterAnnotation(RequestParam.class)) {
        //与instanceof作用相同，只不过这个是判断类之间的管理
        //判断传入的类与这个类是否相同或者是不是传入的这个类的超类或者超接口
        if (Map.class.isAssignableFrom(paramType)) {
            String paramName = parameter.getParameterAnnotation(RequestParam.class).value();
            return StringUtils.hasText(paramName);
        }
        else {
            return true;
        }
    }
    else {
        if (parameter.hasParameterAnnotation(RequestPart.class)) {
            return false;
        }
        else if (MultipartFile.class.equals(paramType) || &quot;javax.servlet.http.Part&quot;.equals(paramType.getName())) {
            return true;
        }
        else if (this.useDefaultResolution) {
            return BeanUtils.isSimpleProperty(paramType);
        }
        else {
            return false;
        }
    }
}</code></pre><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><code>Handler</code>方法的执行由<code>handlerAdapter</code>接口的实现类的<code>handle</code>方法为入口</p>
<pre><code>// Actually invoke the handler.
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre><p>本Demo中配置方式决定了<code>ha</code>变量为<code>RequestMappingHandlerAdapter</code>实例对象，调用该对象的<code>handle</code>方法<br>，<code>handle</code>方法为它父类<code>AbstractHandlerMethodAdapter</code>中的方法</p>
<pre><code>@Override
public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {

    return handleInternal(request, response, (HandlerMethod) handler);
}</code></pre><p>接着又调用该对象的<code>handleInternal</code>方法</p>
<pre><code>@Override
protected ModelAndView handleInternal(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    //判断是否有@SessionAttributes注解
    if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
        // Always prevent caching in case of session attribute management.
        checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
    }
    else {
        // Uses configured default cacheSeconds setting.
        checkAndPrepare(request, response, true);
    }

    // Execute invokeHandlerMethod in synchronized block if required.
    if (this.synchronizeOnSession) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized (mutex) {
                return invokeHandleMethod(request, response, handlerMethod);
            }
        }
    }

    return invokeHandleMethod(request, response, handlerMethod);
}</code></pre><p><code>getSessionAttributesHandler</code>方法</p>
<pre><code>private SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) {
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    SessionAttributesHandler sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);
    if (sessionAttrHandler == null) {
        synchronized (this.sessionAttributesHandlerCache) {
            sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);
            if (sessionAttrHandler == null) {
                sessionAttrHandler = new SessionAttributesHandler(handlerType, sessionAttributeStore);
                this.sessionAttributesHandlerCache.put(handlerType, sessionAttrHandler);
            }
        }
    }
    return sessionAttrHandler;
}</code></pre><p>单例模式创建<code>SessionAttributesHandler</code>，看构造方法</p>
<pre><code>public SessionAttributesHandler(Class&lt;?&gt; handlerType, SessionAttributeStore sessionAttributeStore) {
    Assert.notNull(sessionAttributeStore, &quot;SessionAttributeStore may not be null.&quot;);
    this.sessionAttributeStore = sessionAttributeStore;

    SessionAttributes annotation = AnnotationUtils.findAnnotation(handlerType, SessionAttributes.class);
    if (annotation != null) {
        this.attributeNames.addAll(Arrays.asList(annotation.value()));
        this.attributeTypes.addAll(Arrays.&lt;Class&lt;?&gt;&gt;asList(annotation.types()));
    }

    for (String attributeName : this.attributeNames) {
        this.knownAttributeNames.add(attributeName);
    }
}</code></pre><p>查看<code>Controller</code>有没有<code>@SessionAttributes</code>注解</p>
<p>把注解中的<code>value</code>值放入成员变量<code>knownAttributeNames</code>集合中</p>
<p>跟入<code>invokeHandleMethod</code></p>
<pre><code>/**
 * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}
 * if view resolution is required.
 */
private ModelAndView invokeHandleMethod(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    ServletWebRequest webRequest = new ServletWebRequest(request, response);

    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
    ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);

    ModelAndViewContainer mavContainer = new ModelAndViewContainer();
    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
    modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);
    mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

    AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
    asyncWebRequest.setTimeout(this.asyncRequestTimeout);

    final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.setTaskExecutor(this.taskExecutor);
    asyncManager.setAsyncWebRequest(asyncWebRequest);
    asyncManager.registerCallableInterceptors(this.callableInterceptors);
    asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

    if (asyncManager.hasConcurrentResult()) {
        Object result = asyncManager.getConcurrentResult();
        mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
        asyncManager.clearConcurrentResult();

        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
        }
        requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);
    }

    requestMappingMethod.invokeAndHandle(webRequest, mavContainer);

    if (asyncManager.isConcurrentHandlingStarted()) {
        return null;
    }

    return getModelAndView(mavContainer, modelFactory, webRequest);
}</code></pre><p>先看<code>WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</code>，进入<code>getDataBinderFactory</code></p>
<pre><code>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = this.initBinderCache.get(handlerType);
    if (methods == null) {
        methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);
        this.initBinderCache.put(handlerType, methods);
    }
    List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList&lt;InvocableHandlerMethod&gt;();
    // Global methods first
    for (Entry&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; entry : this.initBinderAdviceCache .entrySet()) {
        if (entry.getKey().isApplicableToBeanType(handlerType)) {
            Object bean = entry.getKey().resolveBean();
            for (Method method : entry.getValue()) {
                initBinderMethods.add(createInitBinderMethod(bean, method));
            }
        }
    }
    for (Method method : methods) {
        Object bean = handlerMethod.getBean();
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }
    return createDataBinderFactory(initBinderMethods);
}</code></pre><p><code>initBinderCache</code>字面看是<code>@initBinder</code>方法的缓存，看<code>selectMethod</code>方法</p>
<pre><code>public static Set&lt;Method&gt; selectMethods(final Class&lt;?&gt; handlerType, final MethodFilter handlerMethodFilter) {
    final Set&lt;Method&gt; handlerMethods = new LinkedHashSet&lt;Method&gt;();
    Set&lt;Class&lt;?&gt;&gt; handlerTypes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;();
    Class&lt;?&gt; specificHandlerType = null;
    if (!Proxy.isProxyClass(handlerType)) {
        handlerTypes.add(handlerType);
        specificHandlerType = handlerType;
    }
    handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));
    for (Class&lt;?&gt; currentHandlerType : handlerTypes) {
        final Class&lt;?&gt; targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);
        ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
            @Override
            public void doWith(Method method) {
                Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
                if (handlerMethodFilter.matches(specificMethod) &amp;&amp;
                        (bridgedMethod == specificMethod || !handlerMethodFilter.matches(bridgedMethod))) {
                    handlerMethods.add(specificMethod);
                }
            }
        }, ReflectionUtils.USER_DECLARED_METHODS);
    }
    return handlerMethods;
}</code></pre><p>判断传入的<code>handlerType</code>是不是代理类，不是的话添加到集合<code>handlerTypes</code>中，再让<code>specificHandlerYtpe</code>指向它，如果事代理类的话，将代理类实现的接口添加到集合<code>handlerTypes</code>中。<br>下一步对<code>handlerTypes</code>进行处理，当<code>handlerType</code>不是代理类时，这一步处理的就是<code>handlerType</code>本身，<br>调用了类<code>ReflectionUtils</code>的<code>doWithMethods</code>方法对<code>handlerType</code>进行处理</p>
<pre><code>public static void doWithMethods(Class&lt;?&gt; clazz, MethodCallback mc, MethodFilter mf) {
    // Keep backing up the inheritance hierarchy.
    Method[] methods = getDeclaredMethods(clazz);
    for (Method method : methods) {
        if (mf != null &amp;&amp; !mf.matches(method)) {
            continue;
        }
        try {
            mc.doWith(method);
        }
        catch (IllegalAccessException ex) {
            throw new IllegalStateException(&quot;Not allowed to access method &#39;&quot; + method.getName() + &quot;&#39;: &quot; + ex);
        }
    }
    if (clazz.getSuperclass() != null) {
        doWithMethods(clazz.getSuperclass(), mc, mf);
    }
    else if (clazz.isInterface()) {
        for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) {
            doWithMethods(superIfc, mc, mf);
        }
    }
}</code></pre><p><code>mf</code>为<code>MethodFilter</code>接口的实现类，作用为判断如果传入的<code>method</code>为非桥接方法和非<code>Object</code>中的方法就返回<code>true</code>，否则返回<code>false</code>。</p>
<pre><code>public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {

    @Override
    public boolean matches(Method method) {
        return (!method.isBridge() &amp;&amp; method.getDeclaringClass() != Object.class);
    }
}

</code></pre><p>接着获取上一步的<code>handlerType</code>的方法，<code>getDeclaredMethod</code>获取的是类中定义的所有类型的方法，不包括从父类继承的。然后通过<code>mf</code>过滤掉桥接方法，然后使用<code>mc</code>的<code>dowith</code>方法遍历所有它们，<code>mc</code>为<code>selectMehtod</code>中的用匿名内部类的方法构造。</p>
<pre><code>new ReflectionUtils.MethodCallback() {
            @Override
            public void doWith(Method method) {
                Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
                if (handlerMethodFilter.matches(specificMethod) &amp;&amp;
                        (bridgedMethod == specificMethod || !handlerMethodFilter.matches(bridgedMethod))) {
                    handlerMethods.add(specificMethod);
                }
            }
        }</code></pre><p>其中<code>ClassUtils</code>的<code>getMostSpecificmethod</code>方法，通过<code>method</code>查找方法名和变量名在<code>targetClass</code>中相同的<code>method</code>，<code>BridgeMethodResolver.findBridgedMethod</code>api的英文解释，Find the original method for the supplied bridge Method.从源码看是通过传入的桥接方法获取到Class，然后获取所有方法，匹配名字和参数个数相同的方法。接下来是<code>handlerMethodFilter</code>过滤器的匹配，这个过滤器定义在<code>RequestMappingHandlerAdapter</code>中</p>
<pre><code>public static final MethodFilter INIT_BINDER_METHODS = new MethodFilter() {

    @Override
    public boolean matches(Method method) {
        return AnnotationUtils.findAnnotation(method, InitBinder.class) != null;
    }
};</code></pre><p>作用是查看方法是否有<code>@initBinder</code>注解，如果有返回<code>true</code>，没有就返回<code>false</code>，当<code>specificMethod</code>不是<code>@initBinder</code>注解的方法，切不是桥接方法或桥接方法为<code>@initBinder</code>方法时，将<code>specificMethod</code>添加到<code>handlerMethods</code>中，然后返回</p>
<pre><code>
private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = this.initBinderCache.get(handlerType);
    if (methods == null) {
        methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);
        this.initBinderCache.put(handlerType, methods);
    }
    List&lt;InvocableHandlerMethod&gt; initBinderMethods = new ArrayList&lt;InvocableHandlerMethod&gt;();
    // Global methods first
    for (Entry&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; entry : this.initBinderAdviceCache .entrySet()) {
        if (entry.getKey().isApplicableToBeanType(handlerType)) {
            Object bean = entry.getKey().resolveBean();
            for (Method method : entry.getValue()) {
                initBinderMethods.add(createInitBinderMethod(bean, method));
            }
        }
    }
    for (Method method : methods) {
        Object bean = handlerMethod.getBean();
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }
    return createDataBinderFactory(initBinderMethods);
}
</code></pre><p>这样返回的<code>methods</code>集合中就有了和当前<code>handlerType</code>(当前<code>request</code>对应的<code>controller</code>)对应的<code>@initBinder</code>方法，并且存放在了缓存<code>initBinderCache</code>中，<code>initBinderAdviceCache</code>存放的是在<code>@controllerAdvice</code>中的全局<code>@initBinder</code>方法。</p>
<p>然后调用<code>createInitBinderMethod</code>方法创建一个<code>invocableHandlerMethod</code></p>
<pre><code>private InvocableHandlerMethod createInitBinderMethod(Object bean, Method method) {
    InvocableHandlerMethod binderMethod = new InvocableHandlerMethod(bean, method);
    binderMethod.setHandlerMethodArgumentResolvers(this.initBinderArgumentResolvers);
    binderMethod.setDataBinderFactory(new DefaultDataBinderFactory(this.webBindingInitializer));
    binderMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
    return binderMethod;
}</code></pre><p>然后将全局<code>@initBinder</code>方法和控制器中的<code>@initBinder</code>方法放入集合<code>initBinderMethods</code>中，并且用它来创建数据绑定工厂</p>
<pre><code>protected InitBinderDataBinderFactory createDataBinderFactory(List&lt;InvocableHandlerMethod&gt; binderMethods)
        throws Exception {

    return new ServletRequestDataBinderFactory(binderMethods, getWebBindingInitializer());
}</code></pre><pre><code>WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</code></pre><p>以上主要查找了控制器中和全局<code>@initBinder</code>方法，然后和<code>webBindingInitializer</code>一同创建<code>servletRequestDataBinderFactory</code></p>
<p>接下来看</p>
<pre><code>ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory)</code></pre><pre><code>private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {
    SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);
    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();
    Set&lt;Method&gt; methods = this.modelAttributeCache.get(handlerType);
    if (methods == null) {
        methods = HandlerMethodSelector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);
        this.modelAttributeCache.put(handlerType, methods);
    }
    List&lt;InvocableHandlerMethod&gt; attrMethods = new ArrayList&lt;InvocableHandlerMethod&gt;();
    // Global methods first
    for (Entry&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; entry : this.modelAttributeAdviceCache.entrySet()) {
        if (entry.getKey().isApplicableToBeanType(handlerType)) {
            Object bean = entry.getKey().resolveBean();
            for (Method method : entry.getValue()) {
                attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));
            }
        }
    }
    for (Method method : methods) {
        Object bean = handlerMethod.getBean();
        attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));
    }
    return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);
}</code></pre><p>主要是处理<code>@modelAttribute</code>注解方法</p>
<p><code>getSessionAttributesHandler</code>方法获取创建好的<code>SessionAttributesHandler</code></p>
<p>接着从当前<code>modelAttributeCache</code>根据当前<code>handlerType</code>查找集合<code>methods</code></p>
<pre><code>methods = HandlerMethodSelector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</code></pre><p>熟悉的方法，不过过滤器换成了<code>MODEL_ATTRIBUTE_METHODS</code></p>
<pre><code>public static final MethodFilter MODEL_ATTRIBUTE_METHODS = new MethodFilter() {

    @Override
    public boolean matches(Method method) {
        return ((AnnotationUtils.findAnnotation(method, RequestMapping.class) == null) &amp;&amp;
                (AnnotationUtils.findAnnotation(method, ModelAttribute.class) != null));
    }
};</code></pre><p>查找当前<code>handlerType</code>中没有被<code>@requestMapping</code>注解并且有<code>@modelAttribute</code>注解的方法，然后再从<code>@controllerAdvice</code>注解的类中也找相同的全局<code>@modelAttribute</code>方法，然后创建<code>modelFactory</code></p>
<pre><code>ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</code></pre><p>创建<code>ServletInvocableHandlerMethod</code>对象</p>
<pre><code>private ServletInvocableHandlerMethod createRequestMappingMethod(
        HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {

    ServletInvocableHandlerMethod requestMethod;
    requestMethod = new ServletInvocableHandlerMethod(handlerMethod);
    requestMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    requestMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
    requestMethod.setDataBinderFactory(binderFactory);
    requestMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
    return requestMethod;
}</code></pre><p><code>argumentResolver</code>是<code>HandlerMethodArgumentResolver</code>类的实例，用来做参数解析，<code>returnValueHandlers</code>是<code>HandlerMethodReturnValueHandlerComposite</code>类的实例，用来对返回结果做处理，<code>parameterNameDiscoverer</code>用来记录参数名解析器</p>
<pre><code>ModelAndViewContainer mavContainer = new ModelAndViewContainer();</code></pre><p>ModelAndViewContainer主要是用来返回<code>Model</code>对象的，当然里面还有变量<code>view</code>存放视图</p>
<p>此时<code>Model</code>为默认<code>Model</code>，是新建的<code>BindingAwareModelMap</code>类的实例</p>
<pre><code>modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</code></pre><p>文档是这样写的</p>
<pre><code>/**
 * Populate the model in the following order:
 * &lt;ol&gt;
 *     &lt;li&gt;Retrieve &quot;known&quot; session attributes listed as {@code @SessionAttributes}.
 *     &lt;li&gt;Invoke {@code @ModelAttribute} methods
 *     &lt;li&gt;Find {@code @ModelAttribute} method arguments also listed as
 *     {@code @SessionAttributes} and ensure they&#39;re present in the model raising
 *     an exception if necessary.
 * &lt;/ol&gt;
 * @param request the current request
 * @param mavContainer a container with the model to be initialized
 * @param handlerMethod the method for which the model is initialized
 * @throws Exception may arise from {@code @ModelAttribute} methods
 */
public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)
        throws Exception {

    Map&lt;String, ?&gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);
    mavContainer.mergeAttributes(sessionAttributes);

    invokeModelAttributeMethods(request, mavContainer);

    for (String name : findSessionAttributeArguments(handlerMethod)) {
        if (!mavContainer.containsAttribute(name)) {
            Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
            if (value == null) {
                throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);
            }
            mavContainer.addAttribute(name, value);
        }
    }
}</code></pre><p>当与<code>@SessionAttribute</code>注解的<code>value</code>值相同的变量名在控制器某个方法被实例化放入<code>model</code>中，也就是被放入<code>Session</code>中后，在此处会获得这个注解的变量名的属性，源码也就是变量<code>sessionAttributesHandler</code>中有个变量<code>knownAttributeNames</code>集合，存放了<code>@SessionAttribute</code>注解的<code>value</code>值，这里通过<code>request</code>获取<code>Session</code>，然后取出<code>value</code>对应属性</p>
<p>然后<code>mergeAttributes</code>将获取到的属性复制一份放到<code>mavContainer</code>的<code>model</code>中</p>
<p>查看<code>invokeModelAttributeMethods</code>方法</p>
<pre><code>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)
        throws Exception {

    while (!this.modelMethods.isEmpty()) {
        InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
        String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
        if (mavContainer.containsAttribute(modelName)) {
            continue;
        }

        Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

        if (!attrMethod.isVoid()){
            String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
            if (!mavContainer.containsAttribute(returnValueName)) {
                mavContainer.addAttribute(returnValueName, returnValue);
            }
        }
    }
}</code></pre><p>此处的<code>modelMethods</code>在前几步的<code>getModelFactory</code>中，是获取的控制器和全局<code>@ModelAttribute</code>方法的集合。</p>
<p>我们看<code>getNextModelMethod(mavContainer).getHandlerMethod()</code></p>
<pre><code>private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {
    for (ModelMethod modelMethod : this.modelMethods) {
        if (modelMethod.checkDependencies(mavContainer)) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Selected @ModelAttribute method &quot; + modelMethod);
            }
            this.modelMethods.remove(modelMethod);
            return modelMethod;
        }
    }
    ModelMethod modelMethod = this.modelMethods.get(0);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Selected @ModelAttribute method (not present: &quot; +
                modelMethod.getUnresolvedDependencies(mavContainer)+ &quot;) &quot; + modelMethod);
    }
    this.modelMethods.remove(modelMethod);
    return modelMethod;
}</code></pre><p>对集合<code>modelMethods</code>进行遍历，查找合适条件的<code>modelMethod</code>，这里用的<code>modelMethod</code>的<code>checkDependencies</code>方法</p>
<pre><code>public boolean checkDependencies(ModelAndViewContainer mavContainer) {
    for (String name : this.dependencies) {
        if (!mavContainer.containsAttribute(name)) {
            return false;
        }
    }
    return true;
}</code></pre><p>关于<code>ModelMethod</code>的<code>denpendencies</code>变量，需要往前追溯一下变量<code>modelMethod</code>是怎么创建的</p>
<p>回到<code>getModelFactory</code>方法</p>
<pre><code>attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</code></pre><p>将获取到的带<code>@ModelAttribute</code>注解的方法<code>method</code>包装为<code>InvocableHandlerMethod</code>类型然后添加到<code>List&lt;InvocableHandlerMethod&gt;</code>的集合中<code>attrMethods</code>中，在创建<code>ModelFactory</code>类的实例的时候利用构造函数将其集合类型转化为<code>List&lt;ModelMethod&gt;</code>的集合<code>modelMethods</code></p>
<pre><code>public ModelFactory(List&lt;InvocableHandlerMethod&gt; invocableMethods, WebDataBinderFactory dataBinderFactory,
        SessionAttributesHandler sessionAttributesHandler) {

    if (invocableMethods != null) {
        for (InvocableHandlerMethod method : invocableMethods) {
            this.modelMethods.add(new ModelMethod(method));
        }
    }
    this.dataBinderFactory = dataBinderFactory;
    this.sessionAttributesHandler = sessionAttributesHandler;
}</code></pre><p>在构造函数里，集合<code>attrMethods</code>中的<code>invocableHandlerMethod</code>类的实例被包装为<code>ModelMethod</code>类的实例<br><code>new ModelMethod(method)</code></p>
<p>我们看<code>ModelMethod</code>的构造函数是怎么处理<code>dependencies</code>变量的</p>
<pre><code>private ModelMethod(InvocableHandlerMethod handlerMethod) {
    this.handlerMethod = handlerMethod;
    for (MethodParameter parameter : handlerMethod.getMethodParameters()) {
        if (parameter.hasParameterAnnotation(ModelAttribute.class)) {
            this.dependencies.add(getNameForParameter(parameter));
        }
    }
}</code></pre><p><code>getMethodParameters</code>获取方法的所有参数，返回一个<code>MethodParameter</code>集合，接下来遍历这些参数，如果有带<code>@ModelAttribute</code>注解的，获取参数的名字放入类型为<code>Set&lt;String&gt;</code>集合的<code>dependencies</code>中</p>
<p>接下来就知道<code>checkDependencies</code>方法是做什么的了</p>
<pre><code>public boolean checkDependencies(ModelAndViewContainer mavContainer) {
    for (String name : this.dependencies) {
        if (!mavContainer.containsAttribute(name)) {
            return false;
        }
    }
    return true;
}</code></pre><p><code>!mavContainer.containsAttribute(name)</code>，对方法的所有参数名字遍历</p>
<pre><code>public boolean containsAttribute(String name) {
    return getModel().containsAttribute(name);
}</code></pre><p>以上将<code>@ModelAttribute</code>方法的集合做了包装，<code>invocableHandlerMethod -&gt; ModelMethod</code>，多了个<code>dependencies</code>属性，类型为<code>Set&lt;String&gt;</code>，用来存放当前方法中带了<code>@ModelAttribute</code>注解的<strong>形参</strong>的参数名</p>
<p>接着遍历包装后的集合，<code>mavContainer</code>中的<code>model</code>必须拥有<code>dependencies</code>中所有的属性名，此时<code>checkDependencies</code>方法返回<code>true</code>，当<code>ModelMethod</code>的<code>dependencies</code>为空时，也返回<code>true</code>，其他返回<code>false</code></p>
<p>回到变量<code>ModelFactory</code>的<code>getNextModelMethod(mavContainer).getHandlerMethod()</code></p>
<pre><code>private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {
    for (ModelMethod modelMethod : this.modelMethods) {
        if (modelMethod.checkDependencies(mavContainer)) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Selected @ModelAttribute method &quot; + modelMethod);
            }
            this.modelMethods.remove(modelMethod);
            return modelMethod;
        }
    }
    ModelMethod modelMethod = this.modelMethods.get(0);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Selected @ModelAttribute method (not present: &quot; +
                modelMethod.getUnresolvedDependencies(mavContainer)+ &quot;) &quot; + modelMethod);
    }
    this.modelMethods.remove(modelMethod);
    return modelMethod;
}</code></pre><p>由于当前Demo中<code>@ModelAttribute</code>方法的形参没有带<code>@ModelAttribute</code>注解，所以这里<code>dependencies</code>为空，返回<code>true</code></p>
<p>将符合条件的<code>ModelMethod</code>返回，然后移除，下面再依次返回不符合条件的<code>ModelMethod</code></p>
<p>往回<code>invokeModelAttributeMethods</code>方法</p>
<pre><code>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)
        throws Exception {

    while (!this.modelMethods.isEmpty()) {
        InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
        String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
        if (mavContainer.containsAttribute(modelName)) {
            continue;
        }

        Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

        if (!attrMethod.isVoid()){
            String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
            if (!mavContainer.containsAttribute(returnValueName)) {
                mavContainer.addAttribute(returnValueName, returnValue);
            }
        }
    }
}</code></pre><p><code>getNextModelMethod</code>获取到<code>ModelMetod</code>后，将它解包装回<code>InvocableHandlerMethod</code>，获取当前方法注解<code>@ModelAttribute</code>的<code>value</code>值，如果当前<code>mavContainer</code>中的<code>Model</code>已经有与<code>value</code>同名的属性名，则跳过，<strong>在之前的代码，我们知道此时</strong><code>Model</code><strong>中的属性来自于</strong><code>@SessionAttributes</code></p>
<p>然后调用<code>InvocableHandlerMethod</code>的<code>invokeForRequest</code>方法来完成执行<code>ModelAttribute</code>方法，取得返回值</p>
<pre><code>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    if (logger.isTraceEnabled()) {
        StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
        sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
        sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
        sb.append(Arrays.asList(args));
        logger.trace(sb.toString());
    }
    Object returnValue = doInvoke(args);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
    }
    return returnValue;
}</code></pre><p>获取方法参数数组</p>
<pre><code>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    MethodParameter[] parameters = getMethodParameters();
    Object[] args = new Object[parameters.length];
    for (int i = 0; i &lt; parameters.length; i++) {
        MethodParameter parameter = parameters[i];
        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
        GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
        args[i] = resolveProvidedArgument(parameter, providedArgs);
        if (args[i] != null) {
            continue;
        }
        if (this.argumentResolvers.supportsParameter(parameter)) {
            try {
                args[i] = this.argumentResolvers.resolveArgument(
                        parameter, mavContainer, request, this.dataBinderFactory);
                continue;
            }
            catch (Exception ex) {
                if (logger.isDebugEnabled()) {
                    logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
                }
                throw ex;
            }
        }
        if (args[i] == null) {
            String msg = getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);
            throw new IllegalStateException(msg);
        }
    }
    return args;
}</code></pre><p>获取了方法参数类型数组<code>MethodParameter[]</code></p>
<p>遍历该数组，<code>resolveParameterType</code>确定每个方法参数的类型，<code>getBean().getClass()</code>传入方法所在的类的<code>Class</code></p>
<pre><code>public static Class&lt;?&gt; resolveParameterType(MethodParameter methodParam, Class&lt;?&gt; clazz) {
    Assert.notNull(methodParam, &quot;MethodParameter must not be null&quot;);
    Assert.notNull(clazz, &quot;Class must not be null&quot;);
    methodParam.setContainingClass(clazz);
    methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve());
    return methodParam.getParameterType();
}</code></pre><p>设置成员变量<code>containClass</code>和<code>parameterType</code>，先看<code>forMethodParameter</code>方法</p>
<pre><code>public static ResolvableType forMethodParameter(MethodParameter methodParameter) {
    return forMethodParameter(methodParameter, (Type) null);
}

public static ResolvableType forMethodParameter(MethodParameter methodParameter, Type targetType) {
    Assert.notNull(methodParameter, &quot;MethodParameter must not be null&quot;);
    //获取方法参数所在的类的ResolvableType,其它参数TypeProvider和variableResolve为空
    ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());
    //typeProvider由methodParameter为参数，提供参数的真正类型
    //以owner创建它的内部类new DefaultVariableResolver
    return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).
            getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);
}</code></pre><p><code>forType</code>是用来创建<code>ResolveType</code>类型的变量</p>
<pre><code>public static ResolvableType forType(Type type) {
    return forType(type, null, null);
}

static ResolvableType forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver) {
    if (type == null &amp;&amp; typeProvider != null) {
        type = SerializableTypeWrapper.forTypeProvider(typeProvider);
    }
    if (type == null) {
        return NONE;
    }

    // Purge empty entries on access since we don&#39;t have a clean-up thread or the like.
    cache.purgeUnreferencedEntries();

    // For simple Class references, build the wrapper right away -
    // no expensive resolution necessary, so not worth caching...
    if (type instanceof Class) {
        return new ResolvableType(type, typeProvider, variableResolver, null);
    }

    // Check the cache - we may have a ResolvableType which has been resolved before...
    ResolvableType key = new ResolvableType(type, typeProvider, variableResolver);
    ResolvableType resolvableType = cache.get(key);
    if (resolvableType == null) {
        resolvableType = new ResolvableType(type, typeProvider, variableResolver, null);
        cache.put(resolvableType, resolvableType);
    }
    return resolvableType;
}</code></pre><p>这里先用单独一个<code>type</code>，这里是<code>containClass</code>即方法参数所在的类，创建一个<code>ResolveType</code></p>
<pre><code>private ResolvableType(
        Type type, TypeProvider typeProvider, VariableResolver variableResolver, ResolvableType componentType) {

    this.type = type;
    this.typeProvider = typeProvider;
    this.variableResolver = variableResolver;
    this.componentType = componentType;
    this.resolved = resolveClass();
}

private Class&lt;?&gt; resolveClass() {
    if (this.type instanceof Class || this.type == null) {
        return (Class&lt;?&gt;) this.type;
    }
    if (this.type instanceof GenericArrayType) {
        Class&lt;?&gt; resolvedComponent = getComponentType().resolve();
        return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);
    }
    return resolveType().resolve();
}</code></pre><p>因为传来的<code>type</code>是<code>invocableHandlerMethod</code>中的<code>bean</code>，所以<code>type</code>==<code>resolved</code></p>
<p>第二次使用了为<code>null</code>的<code>targetType</code>，<code>new MethodParameterTypeProvider(methodParameter)</code>和<code>owner.asVariableResolver()</code></p>
<pre><code>public MethodParameterTypeProvider(MethodParameter methodParameter) {
    if (methodParameter.getMethod() != null) {
        this.methodName = methodParameter.getMethod().getName();
        this.parameterTypes = methodParameter.getMethod().getParameterTypes();
    }
    else {
        this.methodName = null;
        this.parameterTypes = methodParameter.getConstructor().getParameterTypes();
    }
    this.declaringClass = methodParameter.getDeclaringClass();
    this.parameterIndex = methodParameter.getParameterIndex();
    this.methodParameter = methodParameter;
}

VariableResolver asVariableResolver() {
    if (this == NONE) {
        return null;
    }
    return new DefaultVariableResolver();
}</code></pre><p>创建这个<code>TypeProvider</code>通过构造函数传入了<code>methodParameter</code>，并且将它的一些属性注入到自己中</p>
<p>因为传入的<code>targetType</code>为<code>null</code></p>
<pre><code>if (type == null &amp;&amp; typeProvider != null) {
    type = SerializableTypeWrapper.forTypeProvider(typeProvider);
}

static Type forTypeProvider(final TypeProvider provider) {
    Assert.notNull(provider, &quot;Provider must not be null&quot;);
    if (provider.getType() instanceof Serializable || provider.getType() == null) {
        return provider.getType();
    }
    Type cached = cache.get(provider.getType());
    if (cached != null) {
        return cached;
    }
    for (Class&lt;?&gt; type : SUPPORTED_SERIALIZABLE_TYPES) {
        if (type.isAssignableFrom(provider.getType().getClass())) {
            ClassLoader classLoader = provider.getClass().getClassLoader();
            Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[] { type,
                SerializableTypeProxy.class, Serializable.class };
            InvocationHandler handler = new TypeProxyInvocationHandler(provider);
            cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);
            cache.put(provider.getType(), cached);
            return cached;
        }
    }
    throw new IllegalArgumentException(&quot;Unsupported Type class &quot; + provider.getType().getClass().getName());
}</code></pre><p><code>provider.getType()</code>，变量<code>provider</code>为前面传来<code>MethodParameterTypeProvider</code>类型的变量，决定了参数的具体类型，它的父类<code>TypeProvoider</code>实现了<code>serializable</code>接口</p>
<pre><code>@Override
public Type getType() {
    return this.methodParameter.getGenericParameterType();
}

public Type getGenericParameterType() {
    if (this.genericParameterType == null) {
        if (this.parameterIndex &lt; 0) {
            this.genericParameterType = (this.method != null ? this.method.getGenericReturnType() : null);
        }
        else {
            this.genericParameterType = (this.method != null ?
                this.method.getGenericParameterTypes()[this.parameterIndex] :
                this.constructor.getGenericParameterTypes()[this.parameterIndex]);
        }
    }
    return this.genericParameterType;
}</code></pre><p>调用了类<code>TypeProvider</code>的<code>getType</code>，通过之前注入的变量<code>MethodParameter</code></p>
<p>因为创建类<code>HandlerMethodParameter</code>的时候注入了<code>Method</code></p>
<pre><code>public HandlerMethodParameter(int index) {
    super(HandlerMethod.this.bridgedMethod, index);
}</code></pre><p>所以这里能获取到参数所在的方法的所有方法参数类型<code>this.method.getGenericParameterTypes()[this.parameterIndex]</code></p>
<p>然后利用这返回的方法参数的类型用来创建<code>ResolveType</code></p>
<pre><code>if (type instanceof Class) {
    return new ResolvableType(type, typeProvider, variableResolver, null);
}</code></pre><p>返回的参数类型的<code>type</code>，又用来和之前的<code>TypeProvider</code>和<code>VariableResolve</code>创建新<code>ResolveType</code></p>
<p>再回到之前的方法</p>
<pre><code>public static Class&lt;?&gt; resolveParameterType(MethodParameter methodParam, Class&lt;?&gt; clazz) {
    Assert.notNull(methodParam, &quot;MethodParameter must not be null&quot;);
    Assert.notNull(clazz, &quot;Class must not be null&quot;);
    methodParam.setContainingClass(clazz);
    methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve());
    return methodParam.getParameterType();
}</code></pre><p>这里再次调用创建好的<code>ResolveType</code>的<code>resolve</code>方法</p>
<pre><code>public Class&lt;?&gt; resolve() {
    return resolve(null);
}

public Class&lt;?&gt; resolve(Class&lt;?&gt; fallback) {
    return (this.resolved != null ? this.resolved : fallback);
}</code></pre><p>这里<code>ResolveType</code>的成员变量<code>resolve</code>和<code>type</code>指向的都是方法的参数类型</p>
<p>所以这里通过<code>ResolvableType.forMethodParameter(methodParam).resolve()</code>来找到方法参数的具体类型，然后设置到<code>methodParam</code>的<code>ParameterType</code>中</p>
<p>通过这样确定了方法参数的具体类型</p>
<p>回到<code>InvocalbleHandlerMethod</code></p>
<pre><code>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    MethodParameter[] parameters = getMethodParameters();
    Object[] args = new Object[parameters.length];
    for (int i = 0; i &lt; parameters.length; i++) {
        MethodParameter parameter = parameters[i];
        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
        GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
        args[i] = resolveProvidedArgument(parameter, providedArgs);
        if (args[i] != null) {
            continue;
        }
        if (this.argumentResolvers.supportsParameter(parameter)) {
            try {
                args[i] = this.argumentResolvers.resolveArgument(
                        parameter, mavContainer, request, this.dataBinderFactory);
                continue;
            }
            catch (Exception ex) {
                if (logger.isDebugEnabled()) {
                    logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
                }
                throw ex;
            }
        }
        if (args[i] == null) {
            String msg = getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);
            throw new IllegalStateException(msg);
        }
    }
    return args;
}</code></pre><p>确定方法参数的具体类型之后，接着调用<code>InvocableHandlerMethod</code>自身的<code>resolveProvidedArgument</code>方法处理对方法参数进行处理</p>
<pre><code>private Object resolveProvidedArgument(MethodParameter parameter, Object... providedArgs) {
    if (providedArgs == null) {
        return null;
    }
    for (Object providedArg : providedArgs) {
        if (parameter.getParameterType().isInstance(providedArg)) {
            return providedArg;
        }
    }
    return null;
}</code></pre><p>Demo中源码传入得入参<code>providedArgs</code>为<code>[]</code>，所以这里返回空</p>
<p>接着判断<code>this.argumentResolvers.supportsParameter(parameter)</code></p>
<pre><code>@Override
public boolean supportsParameter(MethodParameter parameter) {
    return getArgumentResolver(parameter) != null;
}


private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
    if (result == null) {
        for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Testing if argument resolver [&quot; + methodArgumentResolver + &quot;] supports [&quot; +
                        parameter.getGenericParameterType() + &quot;]&quot;);
            }
            if (methodArgumentResolver.supportsParameter(parameter)) {
                result = methodArgumentResolver;
                this.argumentResolverCache.put(parameter, result);
                break;
            }
        }
    }
    return result;
}</code></pre><p><code>argumentResolvers</code>属于类<code>HandlerMethodArgumentResolverComposite</code>，实现了<code>HandlerMethodArgumentResolver</code>接口，用来解析方法参数</p>
<p>遍历成员变量<code>argumentResolvers</code>，查找一个支持当前参数类型得参数解析器，放入缓存</p>
<p>当前Demo正在执行<code>@ModelAttribute</code>方法</p>
<pre><code>@ModelAttribute(&quot;attr&quot;)
public void mda(Map map) {
    Person person = new Person(&quot;li&quot;, 12);
    map.put(&quot;person&quot;, new Person(&quot;zh&quot;, 14));
}</code></pre><p>这里适用于这个的解析器为<code>MapMethodProcessor</code></p>
<p>有支持当前参数的参数解析器，所以返回<code>true</code></p>
<p>之后对方法参数变量<code>MethodParameter</code>进行处理</p>
<pre><code>args[i] = this.argumentResolvers.resolveArgument(
        parameter, mavContainer, request, this.dataBinderFactory);</code></pre><p>接下来</p>
<pre><code>@Override
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

    HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
    Assert.notNull(resolver, &quot;Unknown parameter type [&quot; + parameter.getParameterType().getName() + &quot;]&quot;);
    return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
}</code></pre><p><code>getArgumentResover(parameter)</code>返回<code>MapMethodProcessor</code></p>
<p>查看<code>MapMethodProcessor</code>的<code>resolveArgument</code>方法</p>
<pre><code>@Override
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

    return mavContainer.getModel();
}</code></pre><p>返回容器中的默认<code>BindingAwareModelMap</code></p>
<p>也就是说，此时<code>@ModelAttribute</code>方法中的<code>Map</code>类型的参数指向了<code>mavContainer</code>中的<code>Model</code></p>
<p>方法在最后返回方法参数<code>args[]</code>数组</p>
<p>回到<code>InvocableHandlerMethod</code>的<code>invokeForRequest</code>方法</p>
<pre><code>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    if (logger.isTraceEnabled()) {
        StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
        sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
        sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
        sb.append(Arrays.asList(args));
        logger.trace(sb.toString());
    }
    Object returnValue = doInvoke(args);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
    }
    return returnValue;
}</code></pre><p>这里接收返回的参数之后，调用<code>doInvoke(args)</code>真正对<code>@ModelAttribute</code>方法执行</p>
<pre><code>protected Object doInvoke(Object... args) throws Exception {
    ReflectionUtils.makeAccessible(getBridgedMethod());
    try {
        return getBridgedMethod().invoke(getBean(), args);
    }
    catch (IllegalArgumentException ex) {
        assertTargetBean(getBridgedMethod(), getBean(), args);
        throw new IllegalStateException(getInvocationErrorMessage(ex.getMessage(), args), ex);
    }
    catch (InvocationTargetException ex) {
        // Unwrap for HandlerExceptionResolvers ...
        Throwable targetException = ex.getTargetException();
        if (targetException instanceof RuntimeException) {
            throw (RuntimeException) targetException;
        }
        else if (targetException instanceof Error) {
            throw (Error) targetException;
        }
        else if (targetException instanceof Exception) {
            throw (Exception) targetException;
        }
        else {
            String msg = getInvocationErrorMessage(&quot;Failed to invoke controller method&quot;, args);
            throw new IllegalStateException(msg, targetException);
        }
    }
}</code></pre><p>这里使用了反射的方式来执行方法，然后返回返回值，所以我们现在也知道了操作<code>@ModelAttribute</code>方法中的<code>Map</code>入参，就等于是在操作<code>mavContainer</code>的<code>Model</code></p>
<p>回到<code>ModelFactory</code>的<code>invokeModelAttributeMethods</code></p>
<pre><code>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)
        throws Exception {

    while (!this.modelMethods.isEmpty()) {
        InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
        String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
        if (mavContainer.containsAttribute(modelName)) {
            continue;
        }

        Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

        if (!attrMethod.isVoid()){
            String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
            if (!mavContainer.containsAttribute(returnValueName)) {
                mavContainer.addAttribute(returnValueName, returnValue);
            }
        }
    }
}</code></pre><p>如果<code>@ModelAttribute</code>方法不是<code>void</code>类型</p>
<p>传入参数为<code>@ModelAttribute</code>方法的返回值和<code>attrMethod.getReturnType()</code></p>
<pre><code>public MethodParameter getReturnType() {
    return new HandlerMethodParameter(-1);
}</code></pre><p>接下来获取返回值名</p>
<pre><code>public static String getNameForReturnValue(Object returnValue, MethodParameter returnType) {
    ModelAttribute annotation = returnType.getMethodAnnotation(ModelAttribute.class);
    if (annotation != null &amp;&amp; StringUtils.hasText(annotation.value())) {
        return annotation.value();
    }
    else {
        Method method = returnType.getMethod();
        Class&lt;?&gt; resolvedType = GenericTypeResolver.resolveReturnType(method, returnType.getContainingClass());
        return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);
    }
}</code></pre><p>第一行获取方法参数所在方法是否有<code>@ModelAttribute</code>注解</p>
<pre><code>public &lt;T extends Annotation&gt; T getMethodAnnotation(Class&lt;T&gt; annotationType) {
    return getAnnotatedElement().getAnnotation(annotationType);
}

public AnnotatedElement getAnnotatedElement() {
    // NOTE: no ternary expression to retain JDK &lt;8 compatibility even when using
    // the JDK 8 compiler (potentially selecting java.lang.reflect.Executable
    // as common type, with that new base class not available on older JDKs)
    if (this.method != null) {
        return this.method;
    }
    else {
        return this.constructor;
    }
}</code></pre><p>如果存在注解，返回注解的<code>value</code>属性</p>
<p>然后检测<code>mavContainer</code>中的<code>Model</code>是否已经包含该<code>value</code>属性的值为<code>key</code>的键值对，如果不包含，则将<code>value</code>和返回值添加到<code>Model</code>中</p>
<p>回到<code>ModelFactory</code>的<code>initModel</code>方法</p>
<pre><code>public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)
        throws Exception {

    Map&lt;String, ?&gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);
    mavContainer.mergeAttributes(sessionAttributes);

    invokeModelAttributeMethods(request, mavContainer);

    for (String name : findSessionAttributeArguments(handlerMethod)) {
        if (!mavContainer.containsAttribute(name)) {
            Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
            if (value == null) {
                throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);
            }
            mavContainer.addAttribute(name, value);
        }
    }
}</code></pre><p>上面执行完<code>invokeModelAttributeMethods(request, mavContainer)</code>之后</p>
<p><code>findSessionAttributeArguments(handlerMethod)</code>返回的结果是响应的<code>Handler</code>方法中参数带<code>@ModelAttribute</code>注解的<code>value</code>值和<code>@SessionAttributes</code>注解的<code>value</code>相同时的<code>value</code>，或者带<code>@ModelAttribute</code>注解的方法参数属于<code>@SessionAttributes</code>注解的<code>Types</code>范围内的<code>value</code></p>
<p>然后将<code>value</code>作为<code>key</code>取出因为<code>Session</code>中相应属性，添加到<code>mavContainer</code>的<code>Model</code>中</p>
<p>取出的值为null时，抛出异常，也就是说当<code>@SessionAttributes</code>和<code>Handler</code>方法中参数的<code>@ModelAttribute</code>对应时，例如<code>value</code>相同，在执行完ModelAttribute方法之后，<code>mavContainer</code>中必须有值能传给这个<code>@ModelAttribute</code>方法参数</p>
<p>以上就是<code>modelFactory.initModel(webRequest, mavContainer, requestMappingMethod)</code>完成的事</p>
<p>接下来是对<code>Controller</code>中响应网页请求的方法的执行</p>
<p>该方法</p>
<pre><code>@RequestMapping(&quot;/Person&quot;)
public String testParam(Person person,HttpSession session) {
    System.out.println(person.getName()+&quot; &quot;+person.getAge());
    session.setAttribute(&quot;person&quot;, person);
    return &quot;person&quot;;
}</code></pre><p>依旧回到<code>RequestMappingHandlerAdapter</code></p>
<pre><code>requestMappingMethod.invokeAndHandle(webRequest, mavContainer)</code></pre><p>其中<code>requestMappingMethod</code>是由<code>InvocableHandlerMethod</code>包装成的<code>ServletInvocableHandlerMethod</code>，它指向响应了客户端请求的方法</p>
<pre><code>ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory)


private ServletInvocableHandlerMethod createRequestMappingMethod(
        HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {

    ServletInvocableHandlerMethod requestMethod;
    requestMethod = new ServletInvocableHandlerMethod(handlerMethod);
    requestMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    requestMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
    requestMethod.setDataBinderFactory(binderFactory);
    requestMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
    return requestMethod;
}</code></pre><p>进入<code>invokeAndHandle(webRequest, mavContainer)</code>，调用响应方法</p>
<pre><code>public void invokeAndHandle(ServletWebRequest webRequest,
        ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {

    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    setResponseStatus(webRequest);

    if (returnValue == null) {
        if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
            mavContainer.setRequestHandled(true);
            return;
        }
    }
    else if (StringUtils.hasText(this.responseReason)) {
        mavContainer.setRequestHandled(true);
        return;
    }

    mavContainer.setRequestHandled(false);
    try {
        this.returnValueHandlers.handleReturnValue(
                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    }
    catch (Exception ex) {
        if (logger.isTraceEnabled()) {
            logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
        }
        throw ex;
    }
}</code></pre><p><code>invokeForRequest</code>方法调用响应方法获取返回值</p>
<pre><code>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    if (logger.isTraceEnabled()) {
        StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
        sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
        sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
        sb.append(Arrays.asList(args));
        logger.trace(sb.toString());
    }
    Object returnValue = doInvoke(args);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
    }
    return returnValue;
}</code></pre><p>接下来的步骤与执行<code>@ModelAttribute</code>方法差不多，通过<code>GenericTypeResolver</code>确认了<code>MethodParameter</code>中的<code>ParameterType</code></p>
<p>接着获取适用<code>HandlerMethodArgumentResolver</code>时，这里使用的是<code>ServletModelAttributeMethodProcessor</code></p>
<pre><code>public boolean supportsParameter(MethodParameter parameter) {
    if (parameter.hasParameterAnnotation(ModelAttribute.class)) {
        return true;
    }
    else if (this.annotationNotRequired) {
        return !BeanUtils.isSimpleProperty(parameter.getParameterType());
    }
    else {
        return false;
    }
}</code></pre><p><code>BeanUtils.isSimpleProperty(parameter.getParameterType()</code>方法确认了<code>MethodParameter</code>不是简单属性，英文解释如下</p>
<p>Check if the given type represents a “simple” value type:a primitive, a String or other CharSequence, a Number, a Date,a URI, a URL, a Locale or a Class.</p>
<p>然后使用<code>argumentResolver</code>处理<code>MethodParameter</code></p>
<pre><code>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

    String name = ModelFactory.getNameForParameter(parameter);
    Object attribute = (mavContainer.containsAttribute(name) ?
            mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
    if (binder.getTarget() != null) {
        bindRequestParameters(binder, webRequest);
        validateIfApplicable(binder, parameter);
        if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
            throw new BindException(binder.getBindingResult());
        }
    }

    // Add resolved attribute and BindingResult at the end of the model
    Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
    mavContainer.removeAttributes(bindingResultModel);
    mavContainer.addAllAttributes(bindingResultModel);

    return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
}</code></pre><p><code>getNameForParameter(parameter)</code>决定了变量的名字，如果变量被<code>@ModelAttribute</code>注解修饰，则<code>name</code>取此<code>value</code>属性，当变量为<code>Array</code>或者<code>Collection</code>或者普通<code>Class</code>，则取成员变量或者全限定名最后一个.之后的字符作为<code>name</code></p>
<p>接着如果<code>mavContainer</code>中存在<code>key</code>为<code>name</code>，则取出对应的值，否则<code>createAttribute</code>方法获取<code>MethodParameter</code>的<code>Class</code>来创建新对象</p>
<p>接着<code>binderFactory.createBinder</code>创建一个数据绑定器</p>
<pre><code>@Override
public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)
        throws Exception {
    WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);
    if (this.initializer != null) {
        this.initializer.initBinder(dataBinder, webRequest);
    }
    initBinder(dataBinder, webRequest);
    return dataBinder;
}</code></pre><p>创建<code>binderFactory</code>的时候，<code>RequestMappingHandlerAdapter</code>给它注入了一个<code>ConfigurableWebBindinginitializer</code>类的变量，然后用它来初步初始化<code>dataBinder</code>，这个<code>dataBinder</code>的类型为<code>ExtendedServletRequestDataBinder</code></p>
<pre><code>@Override
public void initBinder(WebDataBinder binder, WebRequest request) {
    binder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
    if (this.directFieldAccess) {
        binder.initDirectFieldAccess();
    }
    if (this.messageCodesResolver != null) {
        binder.setMessageCodesResolver(this.messageCodesResolver);
    }
    if (this.bindingErrorProcessor != null) {
        binder.setBindingErrorProcessor(this.bindingErrorProcessor);
    }
    if (this.validator != null &amp;&amp; binder.getTarget() != null &amp;&amp;
            this.validator.supports(binder.getTarget().getClass())) {
        binder.setValidator(this.validator);
    }
    if (this.conversionService != null) {
        binder.setConversionService(this.conversionService);
    }
    if (this.propertyEditorRegistrars != null) {
        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {
            propertyEditorRegistrar.registerCustomEditors(binder);
        }
    }
}</code></pre><p><code>initializer</code>中有个重要变量<code>conversionService</code>，属于接口<code>ConversionService</code>，它指向了一个<code>DefaultFormattingConversionService</code>类的实例，该实例也是由<code>SpringMvc</code>注入，存放<code>SpringMvc</code>自带的类型转换器converters</p>
<p>接着由<code>binderFactory</code>的<code>init</code>方法初始化<code>dataBinder</code></p>
<pre><code>@Override
public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {
    for (InvocableHandlerMethod binderMethod : this.binderMethods) {
        if (isBinderMethodApplicable(binderMethod, binder)) {
            Object returnValue = binderMethod.invokeForRequest(request, null, binder);
            if (returnValue != null) {
                throw new IllegalStateException(&quot;@InitBinder methods should return void: &quot; + binderMethod);
            }
        }
    }
}</code></pre><p>这里真正调用我们使用<code>@InitBinder</code>注解的方法，同样的<code>invokeForRequest</code>方法，这里传入的<code>binder</code>，会作为调用该方法的参数</p>
<pre><code>@InitBinder
public void initBinder(WebDataBinder binder) {
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    sdf.setLenient(false);
    binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));
}</code></pre><p>所以我们<code>@InitBinder</code>的方法，其实就是在初始化<code>SpringMvc</code>为每个请求创建的<code>dataBinder</code></p>
<p>我们这里使用了<code>registerCustomEditor</code>注册了它<code>SpringMvc</code>中已经定义好的<code>PropertyEditor</code>，用来将字符串转化为<code>java.util.Date</code>，它继承了<code>PropertyEditorSupport</code>，如果要使用我们自定义的<code>PropertyEditor</code>，也是如此，覆写<code>getAsText</code>和<code>setAsText</code>方法，然后注册</p>
<pre><code>@Override
public String getAsText() {
    Date value = (Date) getValue();
    return (value != null ? this.dateFormat.format(value) : &quot;&quot;);
}

@Override
public void setAsText(String text) throws IllegalArgumentException {
    if (this.allowEmpty &amp;&amp; !StringUtils.hasText(text)) {
        // Treat empty String as null value.
        setValue(null);
    }
    //exactDateLength可以指定需要转化成Date类型的字符串长度
    else if (text != null &amp;&amp; this.exactDateLength &gt;= 0 &amp;&amp; text.length() != this.exactDateLength) {
        throw new IllegalArgumentException(
                &quot;Could not parse date: it is not exactly&quot; + this.exactDateLength + &quot;characters long&quot;);
    }
    else {
        try {
            //使用我们注入的DateFormat将字符串转化成Date
            setValue(this.dateFormat.parse(text));
        }
        catch (ParseException ex) {
            throw new IllegalArgumentException(&quot;Could not parse date: &quot; + ex.getMessage(), ex);
        }
    }
}
</code></pre><p>我们看是怎么用<code>dataBinder</code>注册的</p>
<pre><code>@Override
public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {
    getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);
}</code></pre><p>获取<code>PropertyEditorRegistry</code></p>
<pre><code>protected PropertyEditorRegistry getPropertyEditorRegistry() {
    if (getTarget() != null) {
        return getInternalBindingResult().getPropertyAccessor();
    }
    else {
        return getSimpleTypeConverter();
    }
}

protected AbstractPropertyBindingResult getInternalBindingResult() {
    if (this.bindingResult == null) {
        initBeanPropertyAccess();
    }
    return this.bindingResult;
}

public void initBeanPropertyAccess() {
    Assert.state(this.bindingResult == null,
            &quot;DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods&quot;);
    this.bindingResult = new BeanPropertyBindingResult(
            getTarget(), getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());
    if (this.conversionService != null) {
        this.bindingResult.initConversion(this.conversionService);
    }
}</code></pre><p>这里创建了一个<code>BeanPropertyBindingResult</code>类的实例，将<code>dataBinder</code>中的<code>target</code>和<code>objectName</code>传入，让<code>dataBinder</code>的<code>bindingResult</code>指向它，然后返回这个对象</p>
<p>然后调用这个实例的<code>getPropertyAccessor</code>方法，获取属性存取器</p>
<pre><code>@Override
public final ConfigurablePropertyAccessor getPropertyAccessor() {
    if (this.beanWrapper == null) {
        this.beanWrapper = createBeanWrapper();
        this.beanWrapper.setExtractOldValueForEditor(true);
        this.beanWrapper.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
        this.beanWrapper.setAutoGrowCollectionLimit(this.autoGrowCollectionLimit);
    }
    return this.beanWrapper;
}

protected BeanWrapper createBeanWrapper() {
    Assert.state(this.target != null, &quot;Cannot access properties on null bean instance &#39;&quot; + getObjectName() + &quot;&#39;!&quot;);
    return PropertyAccessorFactory.forBeanPropertyAccess(this.target);
}

public static BeanWrapper forBeanPropertyAccess(Object target) {
    return new BeanWrapperImpl(target);
}</code></pre><p>最后返回的是一个<code>BeanWrapperImpl</code>类的实例，并且让<code>BeanPropertyBindingResult</code>的<code>beanWrapper</code>指向它，这个类继承了<code>AbstractPropertyAccessor</code>和<code>PropertyEditorRegistrySupport</code></p>
<p>然后开始注册<code>PropertyEditor</code>，也就是执行我们自定义的<code>@InitBinder</code>注解的方法</p>
<pre><code>@Override
public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {
    registerCustomEditor(requiredType, null, propertyEditor);
}

@Override
public void registerCustomEditor(Class&lt;?&gt; requiredType, String propertyPath, PropertyEditor propertyEditor) {
    if (requiredType == null &amp;&amp; propertyPath == null) {
        throw new IllegalArgumentException(&quot;Either requiredType or propertyPath is required&quot;);
    }
    if (propertyPath != null) {
        if (this.customEditorsForPath == null) {
            this.customEditorsForPath = new LinkedHashMap&lt;String, CustomEditorHolder&gt;(16);
        }
        this.customEditorsForPath.put(propertyPath, new CustomEditorHolder(propertyEditor, requiredType));
    }
    else {
        if (this.customEditors == null) {
            this.customEditors = new LinkedHashMap&lt;Class&lt;?&gt;, PropertyEditor&gt;(16);
        }
        this.customEditors.put(requiredType, propertyEditor);
        this.customEditorCache = null;
    }
}</code></pre><p>然后将<code>PropertyEditor</code>放入<code>customEditors</code>，此时，<code>@InitBinder</code>注解的方法执行完毕</p>
<pre><code>@Override
public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {
    for (InvocableHandlerMethod binderMethod : this.binderMethods) {
        if (isBinderMethodApplicable(binderMethod, binder)) {
            Object returnValue = binderMethod.invokeForRequest(request, null, binder);
            if (returnValue != null) {
                throw new IllegalStateException(&quot;@InitBinder methods should return void: &quot; + binderMethod);
            }
        }
    }
}</code></pre><p>这里可以看到<code>@InitBinder</code>注解的方法不能有返回值</p>
<pre><code>@Override
public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)
        throws Exception {
    WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);
    if (this.initializer != null) {
        this.initializer.initBinder(dataBinder, webRequest);
    }
    initBinder(dataBinder, webRequest);
    return dataBinder;
}

public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

    String name = ModelFactory.getNameForParameter(parameter);
    Object attribute = (mavContainer.containsAttribute(name) ?
            mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
    if (binder.getTarget() != null) {
        bindRequestParameters(binder, webRequest);
        validateIfApplicable(binder, parameter);
        if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
            throw new BindException(binder.getBindingResult());
        }
    }</code></pre><p>初始化完<code>dataBinder</code>之后，开始绑定请求数据<code>bindRequestParameters(binder, webRequest)</code></p>
<pre><code>    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        servletBinder.bind(servletRequest);
    }
</code></pre><p><code>RequestFacade</code>在前面被封装成<code>ServletWebRequest</code>，这里又解包装<br>然后将<code>binder</code>从<code>ExtendedServletRequestDataBinder</code>向上转型为<code>ServletRequestDataBinder</code></p>
<pre><code>public void bind(ServletRequest request) {
    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);
    MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
    if (multipartRequest != null) {
        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
    }
    addBindValues(mpvs, request);
    doBind(mpvs);
}</code></pre><p>看mpvs是什么</p>
<pre><code>public ServletRequestParameterPropertyValues(ServletRequest request) {
    this(request, null, null);
}

public ServletRequestParameterPropertyValues(ServletRequest request, String prefix, String prefixSeparator) {
    super(WebUtils.getParametersStartingWith(
            request, (prefix != null ? prefix + prefixSeparator : null)));
}

public static Map&lt;String, Object&gt; getParametersStartingWith(ServletRequest request, String prefix) {
    Assert.notNull(request, &quot;Request must not be null&quot;);
    Enumeration&lt;String&gt; paramNames = request.getParameterNames();
    Map&lt;String, Object&gt; params = new TreeMap&lt;String, Object&gt;();
    if (prefix == null) {
        prefix = &quot;&quot;;
    }
    while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
        String paramName = paramNames.nextElement();
        if (&quot;&quot;.equals(prefix) || paramName.startsWith(prefix)) {
            String unprefixed = paramName.substring(prefix.length());
            String[] values = request.getParameterValues(paramName);
            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            }
            else if (values.length &gt; 1) {
                params.put(unprefixed, values);
            }
            else {
                params.put(unprefixed, values[0]);
            }
        }
    }
    return params;
}</code></pre><p>这里<code>request.getParameterNames()</code>获取请求中传来的参数的名字的枚举集合，然后<code>request.getParameterValues(paramName)</code>获取请求中参数的值</p>
<p>继续构造方法</p>
<pre><code>public MutablePropertyValues(Map&lt;?, ?&gt; original) {
    // We can optimize this because it&#39;s all new:
    // There is no replacement of existing property values.
    if (original != null) {
        this.propertyValueList = new ArrayList&lt;PropertyValue&gt;(original.size());
        for (Map.Entry&lt;?, ?&gt; entry : original.entrySet()) {
            this.propertyValueList.add(new PropertyValue(entry.getKey().toString(), entry.getValue()));
        }
    }
    else {
        this.propertyValueList = new ArrayList&lt;PropertyValue&gt;(0);
    }
}</code></pre><p><code>original</code>存放了请求中参数的名和值，将其从<code>Map</code>类型转换到<code>PropertyValue</code>的数组队列</p>
<pre><code>public void bind(ServletRequest request) {
    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);
    MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
    if (multipartRequest != null) {
        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
    }
    addBindValues(mpvs, request);
    doBind(mpvs);
}</code></pre><p><code>addBindValues(mpvc,request)</code>将<code>pathVariable</code>变量添加入<code>mpvs</code>中，<code>key</code>重复时跳过</p>
<p>然后<code>doBind(mpvs)</code>把<code>mvps</code>中的参数绑定到<code>dataBinder</code>的<code>target</code>中，也就是目标<code>handlerMethod</code>方法得参数中，中间利用到的转换器有默认的<code>ConversionService</code>中注入的转换器，例如<code>java.lang.String</code>转换到<code>java.lang.Integer</code>的转换器<code>StringToNumber</code></p>
<pre><code>final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; {

    @Override
    public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        return new StringToNumber&lt;T&gt;(targetType);
    }

    private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; {

        private final Class&lt;T&gt; targetType;

        public StringToNumber(Class&lt;T&gt; targetType) {
            this.targetType = targetType;
        }

        @Override
        public T convert(String source) {
            if (source.length() == 0) {
                return null;
            }
            return NumberUtils.parseNumber(source, this.targetType);
        }
    }

}</code></pre><p>回到<code>ServletModelAttributeMethodProcessor</code>的<code>resolveArgument</code></p>
<pre><code>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

    String name = ModelFactory.getNameForParameter(parameter);
    Object attribute = (mavContainer.containsAttribute(name) ?
            mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
    if (binder.getTarget() != null) {
        bindRequestParameters(binder, webRequest);
        validateIfApplicable(binder, parameter);
        if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
            throw new BindException(binder.getBindingResult());
        }
    }

    // Add resolved attribute and BindingResult at the end of the model
    Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
    mavContainer.removeAttributes(bindingResultModel);
    mavContainer.addAllAttributes(bindingResultModel);

    return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
}</code></pre><p><code>validateIfApplicable(binder,webRequest)</code>这句的作用在<code>@validated</code>注解的使用，对<code>POJO</code>类的属性进行jrs303验证</p>
<p>最后将<code>dataBinder</code>中的<code>BeanPropertyBindingResult</code>的已经和请求中的参数做了数据绑定之后的<code>target</code>和处理<code>@validated</code>注解之后的<code>BeanPropertyBindingResult</code>也就是它自身绑定到<code>mavContainer</code>的<code>Model</code>中</p>
<p>回到最初执行控制器<code>Controller</code>的<code>ServletInvocableHandlerMethod</code></p>
<pre><code>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,
        Object... providedArgs) throws Exception {

    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    if (logger.isTraceEnabled()) {
        StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
        sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
        sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
        sb.append(Arrays.asList(args));
        logger.trace(sb.toString());
    }
    Object returnValue = doInvoke(args);
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
    }
    return returnValue;
}</code></pre><p><code>getMethodArgumentValues</code>方法中，<code>argumentResolver</code>对形参<code>methodParameter</code>解析之后，获取到要执行的方法的参数的具体的值</p>
<p>然后利用反射执行方法，然后返回返回值</p>
<pre><code>public void invokeAndHandle(ServletWebRequest webRequest,
        ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {

    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    setResponseStatus(webRequest);

    if (returnValue == null) {
        if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
            mavContainer.setRequestHandled(true);
            return;
        }
    }
    else if (StringUtils.hasText(this.responseReason)) {
        mavContainer.setRequestHandled(true);
        return;
    }

    mavContainer.setRequestHandled(false);
    try {
        this.returnValueHandlers.handleReturnValue(
                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    }
    catch (Exception ex) {
        if (logger.isTraceEnabled()) {
            logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
        }
        throw ex;
    }
}</code></pre><p><code>Controller</code>中方法返回值一般就是<code>view</code>了</p>
<p><code>RequestMappingHandlerAdapter</code>在将<code>Controller</code>中目标方法包装成<code>ServletInvocableHandlerMethod</code>时注入了<code>HandlerMethodReturnValueHandlerComposite</code>的实例，其中包含了许多处理返回值的<code>HandlerMethodReturnValueHandler</code></p>
<p>其中这里处理<code>view</code>视图的是<code>ViewNameMethodReturnValueHandler</code></p>
<pre><code>@Override
public void handleReturnValue(Object returnValue, MethodParameter returnType,
        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {

    if (returnValue == null) {
        return;
    }
    else if (returnValue instanceof String) {
        String viewName = (String) returnValue;
        mavContainer.setViewName(viewName);
        if (isRedirectViewName(viewName)) {
            mavContainer.setRedirectModelScenario(true);
        }
    }
    else {
        // should not happen
        throw new UnsupportedOperationException(&quot;Unexpected return type: &quot; +
                returnType.getParameterType().getName() + &quot; in method: &quot; + returnType.getMethod());
    }
}</code></pre><p>返回值为<code>String</code>类型的时候，将它作为<code>viewName</code>放入<code>mavContainer</code>，然后判断<code>viewName</code>中是否以<code>redirect:</code>开头的设置<code>redirectModelScenario</code>属性</p>
<p>此时，<code>RequestMappingHandlerAdapter</code>的<code>InvokeHandleMethod</code>，也就是<code>handler</code>方法执行的入口就只剩下最后一步</p>
<pre><code>return getModelAndView(mavContainer, modelFactory, webRequest);


private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,
        ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {

    modelFactory.updateModel(webRequest, mavContainer);
    if (mavContainer.isRequestHandled()) {
        return null;
    }
    ModelMap model = mavContainer.getModel();
    ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model);
    if (!mavContainer.isViewReference()) {
        mav.setView((View) mavContainer.getView());
    }
    if (model instanceof RedirectAttributes) {
        Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
    }
    return mav;
}</code></pre><p>前面看到返回值为空时，设置<code>requestHandled</code>为<code>true</code>，使用<code>mavContainer</code>中的<code>Model</code>和<code>viewName</code>创建一个<code>ModelAndView</code>返回，接下来就是对视图进行处理</p>
<h3 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h3><ol>
<li><p>创建<code>WebDataBinderFactory</code>，用来处理请求中属性绑定到形参</p>
</li>
<li><p>创建<code>ModelFactory</code>，处理<code>@ModelAttribute</code>方法</p>
</li>
<li><p>创建<code>ModelAndViewContainer</code>，用来作为<code>Model</code>和<code>View</code>的容器</p>
</li>
<li><p>执行<code>@ModelAttribute</code>方法，在这之前先将<code>@SessionAttributes</code>注解的属性从<code>Session</code>中取出放入<code>mavContainer</code>的<code>Model</code>中</p>
</li>
<li><p>执行<code>Controller</code>目标方法，主要通过获取方法的形参，然后根据形参选择适用的<code>HandlerMethodArgumentResolver</code>对形参进行解析处理，并且在其中使用<code>WebDataBinderFactory</code>创建<code>DataBinder</code>将请求中附带的属性绑定到形参中，然后利用反射的方式来执行方法</p>
</li>
<li><p>获取到方法的返回值过后，利用合适的<code>HandlerMethodReturnValueHandler</code>对返回值也就是<code>view</code>进行处理，然后放入<code>mavContainer</code></p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SpringMVC/" rel="tag"># SpringMVC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/17/ReentrantReadWriteLock%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E4%BA%AB%E9%94%81/" rel="next" title="ReentrantReadWriteLock的共享锁和独享锁">
                <i class="fa fa-chevron-left"></i> ReentrantReadWriteLock的共享锁和独享锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/17/SpringMvc%E5%AF%B9Controller%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Emav%E7%9A%84%E5%A4%84%E7%90%86/" rel="prev" title="SpringMVC对Controller目标方法返回mav的处理">
                SpringMVC对Controller目标方法返回mav的处理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinaill</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#需要注意的类"><span class="nav-number">1.</span> <span class="nav-text">需要注意的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#invocableHandlerMethod"><span class="nav-number">1.1.</span> <span class="nav-text">invocableHandlerMethod</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HandlerMethodParameter"><span class="nav-number">1.2.</span> <span class="nav-text">HandlerMethodParameter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#argumentResolver"><span class="nav-number">1.3.</span> <span class="nav-text">argumentResolver</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程"><span class="nav-number">2.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤总结"><span class="nav-number">3.</span> <span class="nav-text">步骤总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinaill</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <link rel="stylesheet" href="/lib/prettify/skins/sunburst.css" type="text/css">
<script src="/lib/prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
      prettyPrint();
  });
</script>
</body>
</html>
