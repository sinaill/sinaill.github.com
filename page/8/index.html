<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="article:author" content="sinaill">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/Mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/Mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/" itemprop="url">Mysql基础语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>系统：win10 1803 mysql版本：5.7.24 可视化管理工具：Navicat Premium</p>
<h3 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h3><h4 id="建库，删库"><a href="#建库，删库" class="headerlink" title="建库，删库"></a>建库，删库</h4><p><code>CREATE DATABASE database-name</code></p>
<p><code>drop database database-name</code></p>
<h4 id="建表，删表"><a href="#建表，删表" class="headerlink" title="建表，删表"></a>建表，删表</h4><h5 id="建表模板"><a href="#建表模板" class="headerlink" title="建表模板"></a>建表模板</h5><pre><code>create table 库名.表名(
    字段名1 类型[(宽度) 约束条件],
    ···
)</code></pre><p><code>create table table_new like table_old</code></p>
<h5 id="常用约束条件"><a href="#常用约束条件" class="headerlink" title="常用约束条件"></a>常用约束条件</h5><p><code>primary key (PK)</code> #标识该字段为该表的主键，可以唯一的标识记录，主键就是不为空且唯一当然其还有加速查询的作用<br><code>foreign key (FK)</code> #标识该字段为该表的外键，用来建立表与表的关联关系<br><code>not null</code> #标识该字段不能为空<br><code>unique key (UK)</code> #标识该字段的值是唯一的<br><code>auto_increment</code> #标识该字段的值自动增长（整数类型，而且为主键）<br><code>default</code> #为该字段设置默认值<br><code>unsigned</code> #将整型设置为无符号即正数<br><code>zerofill</code> #不够使用0进行填充</p>
<h5 id="显示宽度"><a href="#显示宽度" class="headerlink" title="显示宽度"></a>显示宽度</h5><p>对于数字型，指定显示宽度不影响存储范围，使用zerofill约束条件后，实际显示宽度小于指定显示宽度时，自动加0代替，大于显示宽度时，按实际宽度显示</p>
<p>对于字符型(utf8)，指定显示宽度即指定存储字符个数 (最大65535-3/3)</p>
<p><code>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</code> M默认为4</p>
<p><code>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</code> M默认为6</p>
<p><code>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</code> M默认为9</p>
<p><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code> M默认为11</p>
<p><code>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</code> M默认为20</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><h6 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h6><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围（有符号）</th>
<th>范围（无符号）</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1字节</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2字节</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3字节</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4字节</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8字节</td>
<td>(-9233372036854775808，9223372036854775807)</td>
<td>(0，18446744073709551615)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4字节</td>
<td>(-3.402 823466E+38，1.175494351E-38)，0，(1.175494351E-38，3.402823466351E+38)</td>
<td>0，(1.175494351E-38，3.402823466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8字节</td>
<td>(1.7976931348623157E+308，2.2250738585072014E-308)，0，(2.2250738585072014E-308，1.797 693 134 862 315 7 E+308)</td>
<td>0，(2.2250738585072014E-308，1.7976931348623157E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小数值</td>
</tr>
</tbody></table>
<h6 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h6><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0-255字节</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535字节</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255字节</td>
<td>不超过255个字符的二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255字节</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65535字节</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65535字节</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16777215字节</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16777215字节</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LOGNGBLOB</td>
<td>0-4294967295字节</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4294967295字节</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<h6 id="枚举和集合"><a href="#枚举和集合" class="headerlink" title="枚举和集合"></a>枚举和集合</h6><p>ENUM （最多65535个成员） 64KB<br>SET （最多64个成员） 64KB</p>
<h6 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h6><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01/9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59/838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901/2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>8</td>
<td>1970-01-01 00:00:00/2037 年某时</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h5 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h5><p><code>drop table 表格</code></p>
<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p><code>insert into 表格(字段···) values(值···),(),()···</code></p>
<p><code>select * from table where 字段+条件</code></p>
<p><code>update 表格 set 列名 where 字段+条件</code></p>
<p><code>delete from 表格 where 字段+条件</code></p>
<h4 id="查看字段"><a href="#查看字段" class="headerlink" title="查看字段"></a>查看字段</h4><p><code>desc 表名</code></p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><code>limit x,y</code></p>
<p>从第x条开始，查询y条记录</p>
<h4 id="更改表"><a href="#更改表" class="headerlink" title="更改表"></a>更改表</h4><h5 id="更改表名"><a href="#更改表名" class="headerlink" title="更改表名"></a>更改表名</h5><p><code>alter table 表名 rename 新表名</code></p>
<h5 id="更改列名"><a href="#更改列名" class="headerlink" title="更改列名"></a>更改列名</h5><p><code>ALTER TABLE 表名 CHANGE 旧字段 新字段 旧类型</code></p>
<h5 id="新增列"><a href="#新增列" class="headerlink" title="新增列"></a>新增列</h5><p><code>alter table 表名 add column 新字段 类型</code></p>
<h5 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h5><p><code>alter table 表名 drop column 字段</code></p>
<h5 id="修改表列类型"><a href="#修改表列类型" class="headerlink" title="修改表列类型"></a>修改表列类型</h5><p><code>alter table 表名 modify 字段 新类型</code></p>
<h5 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h5><p><code>alter table 表名 drop constraint 约束名字</code></p>
<h5 id="添加一个表的字段的约束并指定默认值"><a href="#添加一个表的字段的约束并指定默认值" class="headerlink" title="添加一个表的字段的约束并指定默认值"></a>添加一个表的字段的约束并指定默认值</h5><p><code>alter table 表名 add constraint 约束名字 约束类型 for 字段</code></p>
<h4 id="主外键关联"><a href="#主外键关联" class="headerlink" title="主外键关联"></a>主外键关联</h4><p>添加外键约束</p>
<p>alter table 子表 add foreign key(子表外键字段) references 父表(父表主键字段)</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h5><p><code>ALTER TABLE 表名 ADD INDEX 索引名 (column_list)</code></p>
<p>索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称,column_list指出对哪些列进行索引，多列时各列之间用逗号分隔</p>
<p><code>ALTER TABLE 表名 ADD UNIQUE (column_list)</code></p>
<p><code>ALTER TABLE 表名 ADD PRIMARY KEY (column_list)</code></p>
<h5 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h5><p><code>CREATE INDEX index_name ON table_name (column_list)</code></p>
<p><code>CREATE UNIQUE INDEX index_name ON table_name (column_list)</code></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX 索引名 ON 表名</code></p>
<p><code>ALTER TABLE 表名 DROP INDEX 索引名</code></p>
<p><code>ALTER TABLE 表名 DROP PRIMARY KEY</code></p>
<p>其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p>
<p>第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p>
<p>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p>
<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><p><code>show index from 表名</code></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="内连接-inner-join"><a href="#内连接-inner-join" class="headerlink" title="内连接(inner join)"></a>内连接(inner join)</h4><p>只返回两张表中所有满足连接条件的行，即使用比较运算符根据每个表中共有的列的值匹配两个表中的行。(inner关键字是可省略的)</p>
<p><code>select * from 表名1 a [INNER] join 表名2 b on a.字段+条件+b.字段（建议使用）</code></p>
<p><code>select * from 表名1 a,表名2 b where a.字段+条件+b.字段</code></p>
<h4 id="外连接-outer-join"><a href="#外连接-outer-join" class="headerlink" title="外连接(outer join)"></a>外连接(outer join)</h4><p>使用外连接不但返回符合连接和查询条件的数据行，还返回不符合条件的一些行</p>
<p>左外连接、右外连接。(outer关键字可省略)。</p>
<p>共同点：都返回符合连接条件和查询条件（即：内连接）的数据行</p>
<p>不同点：</p>
<ul>
<li><p>左外连接还返回左表中不符合连接条件，但符合查询条件的数据行。(所谓左表，就是写在left join关键字左边的表)</p>
</li>
<li><p>右外连接还返回右表中不符合连接条件，但符合查询条件的数据行。(所谓右表，就是写在right join关键字右边的表)</p>
</li>
</ul>
<p>左查询<code>left join</code></p>
<p><code>select 字段 from 表1 left join 表2 on 表1.字段+条件+表2.字段</code></p>
<p>右查询 <code>right join</code></p>
<p><code>select 字段 from 表1 left join 表2 on 表1.字段+条件+表2.字段</code></p>
<h3 id="交叉连接-cross-join"><a href="#交叉连接-cross-join" class="headerlink" title="交叉连接(cross join)"></a>交叉连接(cross join)</h3><p>因为没有连接条件，所进行的表与表间的所有行的连接,结果集中的总行数就是两张表中总行数的乘积(笛卡尔积)</p>
<p><code>select * from 表名1 a,表名2 b</code></p>
<p><code>select * from 表名1 a cross join 表名2 b</code></p>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>将多次查询(多条select语句), 在记录上进行拼接(字段不会增加)，每一条select语句获取的字段数必须严格一致(但是字段类型无关)</p>
<p><code>union all</code> 保留所有(不去重)</p>
<p><code>union [distinct]</code> 去重</p>
<h3 id="Mysql常用函数"><a href="#Mysql常用函数" class="headerlink" title="Mysql常用函数"></a>Mysql常用函数</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>(1)找出最大值：max(字段名)</p>
<p>(2)找出最小值: min(字段名)</p>
<p>(3)求平均数：avg(字段名)</p>
<p>(4)求和：sum(字段名)</p>
<p>(5)统计记录 count(字段名)，不包含null，count(*)统计所有记录</p>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><img src="http://wx1.sinaimg.cn/large/96b7c0f4gy1g1bh3eakchj20uw0hvwn7.jpg" alt=""></p>
<p>格式化参数：</p>
<p>%y 表示两位数字年份。例如：（2017返回17）<br>%Y 表示四位数字年份。例如：（2017返回2017）<br>%m 表示两位数字月份。例如：（01,02，….，12）<br>%c 表示数字的月份。例如：（1,2,3,4…..,12）<br>%M 表示月明，英文名称。<br>%d 表示两位数字的天数。例如：（01,02,03,…..31）<br>%e 表示数字的天数。例如（1,2,3,4,…..,31）<br>%H 表示两位数字的小时数，24小时制。例如：（01,02，…..，24）<br>%i 表示两位数字的分钟数。例如：（01,02…,60）<br>%S %s 表示两位数字的秒数。例如：（01,02…,60）</p>
<h4 id="字符串类函数"><a href="#字符串类函数" class="headerlink" title="字符串类函数"></a>字符串类函数</h4><p>(1)CONCAT(s1,s2,s3,…..) 连接字符串<br>例如：SELECT CONCAT(‘1’,’2’) FROM DUAL;<br>输出：12</p>
<p>(2)LOWER(s) 将字符串全部变成小写<br>例如：SELECT LOWER(‘ABC’) FROM DUAL;<br>输出：abc</p>
<p>(3)UPPER(s) 将字符串全部变成大写<br>例如：SELECT UPPER(‘abc’) FROM DUAL;<br>输出：ABC</p>
<p>(4)LTRIM(s) 去除字符串左侧的空格<br>例如：select LTRIM(‘ abc’) from dual;<br>输出：abc</p>
<p>(5)RTRIM(s) 去除字符串右侧的空格<br>例如：select LTRIM(‘abc ‘) from dual;<br>输出：abc</p>
<p>(6)TRIM(s) 去除字符串左右两侧的空格<br>例如：select LTRIM( ‘abc ‘) from dual;<br>输出：abc</p>
<p>(7)LPAD(s,len,pad) 用字符串pad来对s左侧进行填充，直至长度达到len<br>例如：SELECT LPAD(‘1’,5,’0’) FROM DUAL;<br>输出：00001</p>
<p>(8)RPAD(s,len,pad) 用字符串pad来对s右侧进行填充，直至长度达到len<br>例如：SELECT RPAD(‘1’,5,’0’) FROM DUAL;<br>输出：10000</p>
<p>(9)REPEAT(s,x) 将s重复x后返回<br>例如：select REPEAT(‘a’,5) from dual;<br>输出：aaaaa</p>
<p>(10)REPLACE(s,form,target) 将字符串中包含form的字符替换成target<br>例如：SELECT REPLACE(‘abc’,’a’,’A’) FROM DUAL;<br>输出：Abc</p>
<p>(11)STRCMP(s1,s2) 比较s1与s2，如果相同返回0，s2大于s1返回1，s2小于s1返回-1<br>例如：SELECT STRCMP(‘a’,’b’),STRCMP(‘a’,’a’),STRCMP(‘b’,’a’) FROM DUAL;<br>输出：-1 0 1</p>
<p>(12)LEFT(s,x) 返回字符串左侧x个字符<br>例如：SELECT LEFT(‘abc’,2) FROM DUAL;<br>输出：ab</p>
<p>(13)RIGHT(s,x) 返回字符串右侧x个字符<br>例如：SELECT RIGHT(‘abc’,2) FROM DUAL;<br>输出：bc</p>
<p>(14)MID(s,x,y) 返回字符串x位置开始y个字符<br>例如：SELECT MID(‘abcd’,3,2) FROM DUAL;<br>输出：cd</p>
<p>(15)SUBSTRING(s,x,y) 返回字符串x位子开始y个字符，与MID基本一样<br>例如：SELECT SUBSTRING(‘abcd’,3,2) FROM DUAL;<br>输出：cd</p>
<p>(16)INSERT(s,x,y,form) 将字符串x位置开始y个字符替换成form字符<br>例如：SELECT INSERT(‘abcd’,3,2,’FF’) FROM DUAL;<br>输出：abFF</p>
<p>(17)LENGTH(s) 返回s的长度<br>例如：SELECT LENGTH(‘123’) FROM DUAL;<br>输出：3</p>
<p>(18)REVERSE(s) 返回s颠倒顺序<br>例如：SELECT REVERSE(‘abc’) FROM DUAL;<br>输出：cba</p>
<h4 id="转换类型函数"><a href="#转换类型函数" class="headerlink" title="转换类型函数"></a>转换类型函数</h4><p>CAST(v as type) 转换数据类型</p>
<p>Type参数：</p>
<p>字符型：CHAR<br>日期：DATE<br>时间：TIME<br>日期时间型：DATETIME<br>浮点数：DECIMAL<br>整数：SIGNED<br>无符号整数：UNSIGNED</p>
<h4 id="数据库类函数"><a href="#数据库类函数" class="headerlink" title="数据库类函数"></a>数据库类函数</h4><p>DATABASE() 返回当前数据库名称<br>VERSION() 返回当前数据库版本<br>INET_ATON(ip) 返回数字表示的IP<br>INET_NTOA(num) 将数字表示的IP转换为IP<br>PASSWORD(s) 返回加密版本<br>MD5(s) 返回MD5加密值</p>
<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>ABS(X): 返回X的绝对值<br>MOD(N,M): 或%:返回N被M除的余数<br>FLOOR(X): 返回不大于X的最大整数值<br>CEILING(X): 返回不小于X的最小整数值<br>ROUND(X) : 返回参数X的四舍五入的一个整数<br>ROUND(X,D): 舍入函数。将参数X舍入到D小数位。 舍入算法取决于X的数据类型。如果未指定，则D默认为0。 D可能是负数，导致值X的小数点左边的D数字变为零</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/MyBatis%E5%A4%A7%E8%87%B4%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/MyBatis%E5%A4%A7%E8%87%B4%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/" itemprop="url">MyBatis大致运行流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原生调用方式"><a href="#原生调用方式" class="headerlink" title="原生调用方式"></a>原生调用方式</h3><pre><code>//第一种
SqlSession session = sqlSessionFactory.openSession();
try {
  Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);
} finally {
  session.close();
}

//第二种，使用到了代理(getMapper方法)

SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  Blog blog = mapper.selectBlog(101);
} finally {
  session.close();
}</code></pre><h3 id="集成框架后使用代理"><a href="#集成框架后使用代理" class="headerlink" title="集成框架后使用代理"></a>集成框架后使用代理</h3><ol>
<li>启动服务器后，自动创建数据库服务接口的代理类</li>
</ol>
<pre><code>//MapperRegistry类的addMapper方法
public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
if (type.isInterface()) {
  if (hasMapper(type)) {
    throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);
  }
  boolean loadCompleted = false;
  try {
    //每个接口对应一个代理工厂实例
    knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));
    // It&#39;s important that the type is added before the parser is run
    // otherwise the binding may automatically be attempted by the
    // mapper parser. If the type is already known, it won&#39;t try.
    MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
    parser.parse();
    loadCompleted = true;
  } finally {
    if (!loadCompleted) {
      knownMappers.remove(type);
    }
  }
}
}</code></pre><ol start="2">
<li>触发Spring的autowire自动向service注入接口的代理类，通过sqlsession的getMappder的方法</li>
</ol>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
return getConfiguration().getMapper(type, this);
}

//跟踪源码
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    return mapperRegistry.getMapper(type, sqlSession);
}

//mapperRegistry就是初始化容器时，通过addMapper方法，给每个接口确定了对应的代理工厂实例
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
    return mapperRegistry.getMapper(type, sqlSession);
}

//mapperRegistry类
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
//取出之前添加的代理工厂类
    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
    }
    try {
      //使用代理工厂类创建代理类实例
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
    }
}

//转进mapperProxyFactory类
protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
    //这行代码生成代理
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}

public T newInstance(SqlSession sqlSession) {
    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
}
</code></pre><ol start="3">
<li>代理类的生成</li>
</ol>
<p>我们知道代理类的生成需要一个实现invocationHandler接口的类，在MyBatis中这个类为MapperProxy，查看invoke方法</p>
<pre><code>  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (Object.class.equals(method.getDeclaringClass())) {
      try {
        return method.invoke(this, args);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    }
    查看method方法对用的MapperMehtod是否存在，不存在则创建
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
  }

  private MapperMethod cachedMapperMethod(Method method) {
    MapperMethod mapperMethod = methodCache.get(method);
    if (mapperMethod == null) {
      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }
    return mapperMethod;
  }</code></pre><ol start="4">
<li>通过代理调用原生调用方式</li>
</ol>
<p>通过MapperMehtod这个类来实现，先看下它的成员变量</p>
<pre><code>  private final SqlCommand command;
  private final MethodSignature method;

  public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) {
    this.command = new SqlCommand(config, mapperInterface, method);
    this.method = new MethodSignature(config, method);
  }


</code></pre><p>查看sqlcommand是什么，大概就是关于sql语句</p>
<pre><code>public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) {
  //接口名加方法名，正好等于我们配置文件的命名空间namespace加上语句的id
  String statementName = mapperInterface.getName() + &quot;.&quot; + method.getName();
  MappedStatement ms = null;
  if (configuration.hasStatement(statementName)) {
    //大概是通过命名空间和id从配置文件查找具体配置对象
    ms = configuration.getMappedStatement(statementName);
  } else if (!mapperInterface.equals(method.getDeclaringClass())) { // issue #35
    String parentStatementName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
    if (configuration.hasStatement(parentStatementName)) {
      ms = configuration.getMappedStatement(parentStatementName);
    }
  }
  if (ms == null) {
    if(method.getAnnotation(Flush.class) != null){
      name = null;
      type = SqlCommandType.FLUSH;
    } else {
      throw new BindingException(&quot;Invalid bound statement (not found): &quot; + statementName);
    }
  } else {
    name = ms.getId();
    type = ms.getSqlCommandType();
    if (type == SqlCommandType.UNKNOWN) {
      throw new BindingException(&quot;Unknown execution method for: &quot; + name);
    }
  }
}</code></pre><p>看<code>MethodSignature</code>的创建</p>
<pre><code>public MethodSignature(Configuration configuration, Method method) {
  this.returnType = method.getReturnType();
  this.returnsVoid = void.class.equals(this.returnType);
  this.returnsMany = (configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray());
  this.mapKey = getMapKey(method);
  this.returnsMap = (this.mapKey != null);
  //处理@Param
  this.hasNamedParameters = hasNamedParams(method);
  this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);
  this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);
  this.params = Collections.unmodifiableSortedMap(getParams(method, this.hasNamedParameters));
}</code></pre><p>在代理类中生成MethodMapper类后，调用execute方法来指定sqlcommand中的sql语句</p>
<pre><code>  public Object execute(SqlSession sqlSession, Object[] args) {
    //args是由代理类invoke方法传来的方法参数
    Object result;
    if (SqlCommandType.INSERT == command.getType()) {
      Object param = method.convertArgsToSqlCommandParam(args);
      //getName返回具体配置语句对象的id
      result = rowCountResult(sqlSession.insert(command.getName(), param));
    } else if (SqlCommandType.UPDATE == command.getType()) {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
    } else if (SqlCommandType.DELETE == command.getType()) {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
    } else if (SqlCommandType.SELECT == command.getType()) {
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
    } else if (SqlCommandType.FLUSH == command.getType()) {
        result = sqlSession.flushStatements();
    } else {
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName() 
          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
    }
    //返回结果
    return result;
  }

  //对返回结果result进行类型转换
  private Object rowCountResult(int rowCount) {
    final Object result;
    if (method.returnsVoid()) {
      result = null;
    } else if (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) {
      result = Integer.valueOf(rowCount);
    } else if (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) {
      result = Long.valueOf(rowCount);
    } else if (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) {
      result = Boolean.valueOf(rowCount &gt; 0);
    } else {
      throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName() + &quot;&#39; has an unsupported return type: &quot; + method.getReturnType());
    }
    return result;
  }</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/JDBC/" itemprop="url">JDBC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="获取链接Connection"><a href="#获取链接Connection" class="headerlink" title="获取链接Connection"></a>获取链接Connection</h3><pre><code>String driver = &quot;com.mysql.jdbc.Driver&quot;;
String url = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;;//防止中文乱码
String userName = &quot;root&quot;;
String passWord = &quot;password&quot;;
Connection con = null;
Class.forName(driver);//加载驱动
con = (Connection) DriverManager.getConnection(url, userName, passWord);//获取链接</code></pre><h3 id="preparestatement和statement"><a href="#preparestatement和statement" class="headerlink" title="preparestatement和statement"></a>preparestatement和statement</h3><p>使用preparestatement的优点：</p>
<ol>
<li>每一种数据库都会尽最大努力对预编译语句提供最大的性能优化.因为预编译语句有可能被重复调用.所以语句在被DB的编译器编译后的执行代码被缓存下来,那么下次调用时只要是相同的预编译语句就不需要编译,只要将参数直接传入编译过的语句执行代码中(相当于一个涵数)就会得到执行.这并不是说只有一个Connection中多次执行的预编译语句被缓存,而是对于整个DB中,只要预编译的语句语法和缓存中匹配.那么在任何时候就可以不需要再次编译而可以直接执行</li>
<li>代码的可读性和可维护性</li>
<li>防止恶意sql语法传入非法参数</li>
</ol>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>创建数据库如下：</p>
<pre><code>create table person(
    id int auto_increment primary key,
    name varchar(255),
    age int)default charset=utf8;</code></pre><p>新增数据：</p>
<pre><code>Connection con = getCon();
PreparedStatement psmt = null;

String sql = &quot;insert into person(name,age) values(?,?)&quot;;

try {
    psmt = con.prepareStatement(sql);
    psmt.setString(1, &quot;小张&quot;);
    psmt.setInt(2, 10);
    psmt.executeUpdate();
    psmt.close();
    con.close();
} catch (SQLException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
System.out.println(&quot;插入成功&quot;);</code></pre><p>删除数据：</p>
<pre><code>String sql = &quot;delete from person where id = ?&quot;;
try {
    psmt = con.prepareStatement(sql);
    psmt.setInt(1, 1);
    psmt.executeUpdate();
    psmt.close();
    con.close();
} catch (SQLException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
System.out.println(&quot;删除成功&quot;);</code></pre><p>修改数据：</p>
<pre><code>String sql = &quot;update person set age=? where id=2&quot;;
try {
    psmt = con.prepareStatement(sql);
    psmt.setInt(1, 20);
    psmt.executeUpdate();
    psmt.close();
    con.close();
} catch (SQLException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
System.out.println(&quot;修改成功&quot;);</code></pre><p>查找数据：</p>
<pre><code>String sql = &quot;select * from person where id = 2&quot;;
try {
    psmt = con.prepareStatement(sql);
    ResultSet rs = psmt.executeQuery();
    while (rs.next()) {
        int id = rs.getInt(&quot;id&quot;);
        String name = rs.getString(&quot;name&quot;);
        int age = rs.getInt(&quot;age&quot;);
        System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name+&quot; age:&quot;+age);
    }
} catch (SQLException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}</code></pre><h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><h4 id="preparestatement"><a href="#preparestatement" class="headerlink" title="preparestatement"></a>preparestatement</h4><p>只能批量进行相同操作，批量插入：</p>
<pre><code>String sql = &quot;insert into person(name,age) values(?,?)&quot;;
try {
    psmt = con.prepareStatement(sql);
    for (int i = 0; i &lt; 100; i++) {
        psmt.setString(1, &quot;李&quot;+i);
        psmt.setInt(2, i);
        psmt.addBatch();
    }
    psmt.executeBatch();
    psmt.close();
    con.close();
} catch (SQLException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}</code></pre><h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>可以批量执行不同类型操作，批量操作：</p>
<pre><code>Statement st = null;
try {
    st = con.createStatement();
    String sql1 = &quot;delete from person where id&gt;2 and id&lt;103&quot;;
    String sql2 = &quot;insert into person(name,age) values(&#39;小李    &#39;,&#39;50&#39;)&quot;;
    st.addBatch(sql1);
    st.addBatch(sql2);
    st.executeBatch();
    st.close();
    con.close();
} catch (SQLException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/LinkedHashMap/" itemprop="url">LinkedHashMap与LRU算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用LRU时，我们要用到这个构造函数</p>
<pre><code>    /**
     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the
     * specified initial capacity, load factor and ordering mode.
     *
     * @param  initialCapacity the initial capacity
     * @param  loadFactor      the load factor
     * @param  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for
     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order
     * @throws IllegalArgumentException if the initial capacity is negative
     *         or the load factor is nonpositive
     */
    public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }</code></pre><p>对于变量accessOrder，传入false时，集合中元素顺序基于插入顺序，传入true是，集合中元素基于访问顺序</p>
<pre><code>        LinkedHashMap&lt;Integer, String&gt; lhm = new LinkedHashMap&lt;Integer,String&gt;(8, 0.75f, true);
        lhm.put(3, &quot;3&quot;);
        lhm.put(2, &quot;2&quot;);
        lhm.put(1, &quot;1&quot;);
        lhm.put(6, &quot;6&quot;);
        lhm.put(5, &quot;5&quot;);
        lhm.put(4, &quot;4&quot;);
        lhm.get(2);
        lhm.forEach((a,b)-&gt;System.out.println(a));</code></pre><p>得到输出</p>
<p><code>3 1 6 5 4 2</code></p>
<p>查看get方法</p>
<pre><code>    public V get(Object key) {
        Node&lt;K,V&gt; e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder)//access为true时，将访问元素放到尾部
            afterNodeAccess(e);
        return e.value;
    }

        void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
        LinkedHashMap.Entry&lt;K,V&gt; last;
        if (accessOrder &amp;&amp; (last = tail) != e) {
            LinkedHashMap.Entry&lt;K,V&gt; p =
                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
            p.after = null;
            if (b == null)
                head = a;
            else
                b.after = a;
            if (a != null)
                a.before = b;
            else
                last = b;
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }</code></pre><p>调用get节点访问元素后，会继续调用afterNodeAccess将元素移动到尾部，要实现LinkedHashMap中元素个数大于容量*负载因子时，删除头部，即最近最少被访问的元素,先查看put方法，找到关键代码</p>
<pre><code>        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);</code></pre><p>进入该方法：</p>
<pre><code>    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry&lt;K,V&gt; first;
        if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }</code></pre><p>发现removeEldestEntry(first)，接着查看removeEldestEntry(first)</p>
<pre><code>    protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
        return false;
    }</code></pre><p>方法总是放回一个false，所以要实现移除头部，需要覆写本方法，我们新定义一个类继承LinkedHashMap</p>
<pre><code>class MyLinkedHashMap&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt;{
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    private int MaxSize;

    public MyLinkedHashMap(int capacity,float factor,boolean accessOrder,int MaxSize){
        super(capacity,factor,accessOrder);
        this.MaxSize = MaxSize;
    }

    /* (non-Javadoc)
     * @see java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry)
     */
    @Override
    protected boolean removeEldestEntry(Entry&lt;K, V&gt; eldest) {
        // TODO Auto-generated method stub
        return this.size()&gt;MaxSize;
    }


}</code></pre><p>构造方法调用父类上文提到那个，再加一个MaxSize表示集合元素最大个数，在removeEldestEntry方法中比较size和MaxSize大小，这样当集合中元素个数size超过设定最大个数MaxSize时，就会触发removeNode，移除头结点即最近最少使用的元素</p>
<pre><code>        LinkedHashMap&lt;Integer, String&gt; lhm = new MyLinkedHashMap&lt;Integer,String&gt;(8, 0.75f, true,6);
        lhm.put(3, &quot;3&quot;);
        lhm.put(2, &quot;2&quot;);
        lhm.put(1, &quot;1&quot;);
        lhm.put(6, &quot;6&quot;);
        lhm.put(5, &quot;5&quot;);
        lhm.put(4, &quot;4&quot;);
        lhm.put(7,&quot;7&quot;);
        lhm.forEach((a,b)-&gt;System.out.println(a+&quot; &quot;+b));</code></pre><p>输出</p>
<p><code>2 1 6 5 4 7</code></p>
<p>我们可以看到头结点Entry 3=3被移除</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/ModelAttribute%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/ModelAttribute%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/" itemprop="url">ModelAttribute注解笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>@ModelAttribute.这个注解可以用在方法参数上，或是方法声明上。这个注解的主要作用是绑定request或是form参数到模型对象。可以使用保存在request或session中的对象来组装模型对象。注意，被@ModelAttribute注解的方法会在controller方法（@RequestMapping注解的）之前执行。因为模型对象要先于controller方法之前创建。</p>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><pre><code>    @ModelAttribute
    public Person mda() {
        return new Person(&quot;zh&quot;, 14);
    }

    @RequestMapping(&quot;/test&quot;)
    public ModelAndView test(@ModelAttribute Person person,Model model) {
        ModelAndView mov = new ModelAndView(&quot;param&quot;);
        System.out.println(model.containsAttribute(&quot;person&quot;));
        mov.addObject(&quot;person&quot;, person);
        return mov;
    }

    //或者

    @ModelAttribute(&quot;attr&quot;)
    public void mda(Map map) {
//        Person person = new Person(&quot;li&quot;, 12);
        map.put(&quot;person&quot;, new Person(&quot;zh&quot;, 14));
    }</code></pre><ol>
<li>注解可以指定名称，如果没有指定，则以类名首字母小写为名字，若注解指定了名字，则在形参前面的ModelAttribute也要带上已指定的名字</li>
<li>在ModelAttribute中使用Map,Model保存的数据，可以在controller中的Map或Model获取</li>
<li>主要用来填充表格，当jsp页面表单项不包含该类所有属性时，可以先在ModelAttribute中根据相应变量先从数据库取出数据，然后表单数据提交到controller中对应方法时，覆盖用ModelAttribute注解修饰的形参，达到自动填充形参所有数据</li>
<li><a href="https://blog.csdn.net/m0_37893932/article/details/78327972" target="_blank" rel="noopener">关于SessionAttribute,当Model中找不到时转到Session中查找</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/InnerClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/InnerClass/" itemprop="url">内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是最普通的内部类，它在另一个类内部被定义，结构为</p>
<pre><code>class Outter{

    class Inner{

    }

}</code></pre><p>实例化内部类的方法为:</p>
<pre><code>Outter.Inner inner = new Outter().new Inner();</code></pre><ol>
<li><p>内部类中可以访问到外部类中所有方法和成员变量，即使是private或者static，同理外部类也可以访问私有内部类的成员变量</p>
</li>
<li><p><strong>普通内部类中不能定义static变量和方法，但可以定义静态常量</strong></p>
</li>
<li><p>外部类要访问内部类变量，必须先实例化一个内部类</p>
</li>
<li><p>静态内部类的访问可以直接用Outter.Inner(初始化时new Outter.Inner())，访问内部类静态成员变量Outter.Inner.valueName</p>
</li>
<li><p>静态内部类不能访问外部类的属性方法</p>
</li>
</ol>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内，结构为</p>
<pre><code>class Outter{
    public void print(final int a){
        class Inner{
            public void say(){
                System.out.println(a);
            }
        }
        new Inner().say();
    }
}</code></pre><p>1.拥有普通内部类特性</p>
<p>2.内部类的modifier只能为default</p>
<p>3.在内部类和方法传入的参数必须是final类型</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1.一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。</p>
<p>2.只是为了获得一个对象实例，不需要知道其实际类型。</p>
<p>3.类名没有意义，也就是不需要使用到。</p>
<p>例如在创建线程时</p>
<pre><code> Thread thread = new Thread(new Runnable(){
           public void run(){

        }
    });</code></pre><p>java8我们可以使用lambda来简化匿名内部类创建，以上代码可简化为</p>
<pre><code>Thread thread = new Thread(()-&gt;{});//Runnable为函数式接口</code></pre><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>关于匿名内部类和局部内部类访问局部变量或者形参时，这是因为局部变量或形参与内部类的生存周期不同，当局部变量或形参被回收后，内部类的实例仍在，若此时访问它们，将会出错，所以局部变量和形参都是以构造函数的参数形式传入到匿名内部类中，相当于是复制了一份放到匿名内部类中，为了保持原始数据和复制后的数据相同，所以要使用final。<a href="http://blog.csdn.net/u014805893/article/details/53310521?locationNum=5&fps=1" target="_blank" rel="noopener">查看原理</a></p>
<h3 id="java8新修改"><a href="#java8新修改" class="headerlink" title="java8新修改"></a>java8新修改</h3><p><strong>java8开始匿名内部类使用的外部变量不再被强制用final修饰。外部变量要么是final的，要么自初始化后值不会被改变，这两种都是可以在匿名内部类中使用且编译通过。</strong></p>
<p><strong>Local variable br defined in an enclosing scope must be final or effectively final</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/HashMap/" itemprop="url">HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>底层结构为数组加链表，插入元素是无序的，维护插入顺序时使用LinkedHashMap，它维护着一个双向循环链表，保证了我们遍历得到元素的顺序和我们插入的顺序一致</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></pre><p>初始化默认容量为16，且容量必须为2的幂</p>
<p><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></p>
<p>最大容量2的30次幂</p>
<p><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></p>
<p>默认负载因子0.75f，<strong>负载因子表示当元素个数达到负载因子乘于容量时就进行扩容，负载因子为final类型</strong></p>
<p>增大负载因子会减少hash表占用内存空间，但是会增加查询的时间开销</p>
<p>减少负载因子则相反</p>
<p><code>transient Node&lt;K,V&gt;[] table;</code></p>
<p>存储元素的链表数组</p>
<p><code>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code></p>
<p>HashMap中的键值对Entry组成的集合</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>public HashMap(int initialCapacity, float loadFactor)</code></p>
<p>由容量和负载因子作为参数来初始化HashMap</p>
<pre><code>    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }</code></pre><p>由容量作为参数，负载因子使用默认值来初始化HashMap</p>
<pre><code>    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }</code></pre><p>无参数时，负载因子为默认值，size为0</p>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>(1) foreach map.entrySet()</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
map.entrySet().forEach(e-&gt;System.out.println(e.getValue()+e.getKey()));</code></pre><p>(2) 显示调用map.entrySet()的集合迭代器</p>
<pre><code>Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry&lt;String, String&gt; entry = iterator.next();
    entry.getKey();
    entry.getValue();
}</code></pre><p>(3) for each map.keySet()，再调用get获取</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
for (String key : map.keySet()) {
    map.get(key);
}</code></pre><p>(4) map.forEach java8新增方法</p>
<pre><code>    map.forEach((k,v)-&gt;System.out.println(k+v))</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当我们使用put方法向HashMap中添加元素时，我们先对键调用hashCode()方法，返回的hashCode用于找到table中位置来储存Entry对象，当key的hashcode相同且equals不相等时，<strong>它们将在同一位置迭代成链表</strong>。此时调用get方法获取值对象时，先通过key的hashcode查找到位置，再通过key的equals方法在链表中查找目标Entry对象。</p>
<p>元素达到负载因子限制的容量时，自动扩容会重新分配Entry在table中的位置</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/Cache%20of%20base%20date%20type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/Cache%20of%20base%20date%20type/" itemprop="url">基本数据类型中的缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>不使用new方法创建Integer而是直接用Integer a = 3的方式的话，会自动使用Integer.valueOf(int i)进行封装操作</p>
<pre><code>        Integer a = 2;
        Integer b = 2;
        System.out.println(a==b);
        Integer c = 1000;
        Integer d = 1000;
        System.out.println(c==d);</code></pre><p><code>true false</code></p>
<p>这是因为Integer中的静态内部类IntegerCache对-128到127中的数据进行了缓存</p>
<pre><code>/**
     * Cache to support the object identity semantics of autoboxing for values between
     * -128 and 127 (inclusive) as required by JLS.
     *
     * The cache is initialized on first usage.  The size of the cache
     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.
     * During VM initialization, java.lang.Integer.IntegerCache.high property
     * may be set and saved in the private system properties in the
     * sun.misc.VM class.
     */

    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k &lt; cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high &gt;= 127;
        }

        private IntegerCache() {}
    }</code></pre><p>而自动装箱操作时调用的Integer.valueOf(int i)</p>
<pre><code>/**
     * Returns an {@code Integer} instance representing the specified
     * {@code int} value.  If a new {@code Integer} instance is not
     * required, this method should generally be used in preference to
     * the constructor {@link #Integer(int)}, as this method is likely
     * to yield significantly better space and time performance by
     * caching frequently requested values.
     *
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     *
     * @param  i an {@code int} value.
     * @return an {@code Integer} instance representing {@code i}.
     * @since  1.5
     */
    public static Integer valueOf(int i) {
        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }</code></pre><p><strong>如果值得范围在-128~127中，返回的是已缓存好的对象，所以为true</strong></p>
<p><strong>对于其他基本变量包装类</strong></p>
<p><strong>Byte(范围正好为-128<del>127),Short,Long也为-128</del>127缓存</strong></p>
<p><strong>Boolean全部缓存</strong></p>
<p><strong>Character为0~127的字符变量缓存</strong></p>
<p><strong>Float和Double不缓存</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/Function%20and%20Predicate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/Function%20and%20Predicate/" itemprop="url">Predicate和Function</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>Predicate接口为函数式接口</p>
<pre><code>    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);</code></pre><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>Function接口为函数式接口</p>
<pre><code>    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);</code></pre><p>与Consumer接口类似，但Function的抽象方法有返回值</p>
<pre><code>    /**
     * Returns a function that always returns its input argument.
     *
     * @param &lt;T&gt; the type of the input and output objects to the function
     * @return a function that always returns its input argument
     */
    static &lt;T&gt; Function&lt;T, T&gt; identity() {
        return t -&gt; t;
    }</code></pre><p>相当于用lambda实现apply抽象方法：u-&gt;u</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/HashMap%20and%20HashTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/HashMap%20and%20HashTable/" itemprop="url">HashMap与HashTable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.HashTable继承自Dictionary,而HashMap继承自AbstractMap</p>
<p>2.HashTable方法带有synchronized关键字，意味着HashTable是同步的，而HashMap是非同步的</p>
<p>3.HashTable中提供了一个类似Iterator的Enumeration(fail-safe),用来遍历自身，而HashMap中无迭代器</p>
<pre><code>    public synchronized Enumeration&lt;K&gt; keys() {
        return this.&lt;K&gt;getEnumeration(KEYS);
    }

    public synchronized Enumeration&lt;V&gt; elements() {
        return this.&lt;V&gt;getEnumeration(VALUES);
    }</code></pre><p>以keys为例</p>
<pre><code>    Hashtable&lt;String,String&gt; a = new Hashtable&lt;String,String&gt;();
    a.put(&quot;1&quot;, &quot;1&quot;);
    a.put(&quot;2&quot;, &quot;2&quot;);
    a.put(&quot;3&quot;, &quot;3&quot;);
    Enumeration&lt;String&gt; e = a.keys();
    while(e.hasMoreElements()){
        System.out.println(e.nextElement());
    }
    }</code></pre><p><code>3 2 1</code></p>
<p>结果是倒序的，我们看下源码</p>
<pre><code>        public T nextElement() {
            Entry&lt;?,?&gt; et = entry;
            int i = index;//index=table.length
            Entry&lt;?,?&gt;[] t = table;
            /* Use locals for faster loop iteration */
            while (et == null &amp;&amp; i &gt; 0) {
                et = t[--i];
            }
            entry = et;
            index = i;
            if (et != null) {
                Entry&lt;?,?&gt; e = lastReturned = entry;
                entry = e.next;
                return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);
            }
            throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;);
        }</code></pre><p>et = t[–i];所以结果是倒序的，但是我们还可以发现，与其他集合的Iterator不同，Enumerator的nextElement方法中没有检测modCount==expectedModCount，而HashMap中EntrySet的Iterator有检测这个。</p>
<pre><code>    Hashtable&lt;String,String&gt; a = new Hashtable&lt;String,String&gt;();
    a.put(&quot;1&quot;, &quot;1&quot;);
    a.put(&quot;2&quot;, &quot;2&quot;);
    a.put(&quot;3&quot;, &quot;3&quot;);
    a.put(&quot;4&quot;, &quot;4&quot;);
    a.put(&quot;5&quot;, &quot;5&quot;);
    a.put(&quot;6&quot;, &quot;6&quot;);
    Enumeration&lt;String&gt; e = a.keys();
    String b = null;
    while(e.hasMoreElements()){
        b = e.nextElement();
        if(b.equals(&quot;3&quot;)){
            a.remove(b);
        }
    }
    a.forEach((c,d)-&gt;System.out.println(c+&quot; &quot;+d));
    }</code></pre><p>输出</p>
<p><code>1 1 2 2 4 4 5 5 6 6</code></p>
<p>确实没有抛出ConcurrentModificationException，Enumerator是一个fail-safe迭代器</p>
<p>4.HashMap允许null作为key或value</p>
<p>5.HashMap默认容量16，Hashtable默认容量11</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinaill</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinaill</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <link rel="stylesheet" href="/lib/prettify/skins/sunburst.css" type="text/css">
<script src="/lib/prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
      prettyPrint();
  });
</script>
</body>
</html>
