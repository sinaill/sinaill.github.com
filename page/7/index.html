<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="article:author" content="sinaill">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringServletContainerInitializer%E4%B8%8Ejava%20config%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringServletContainerInitializer%E4%B8%8Ejava%20config%E9%85%8D%E7%BD%AE/" itemprop="url">SpringServletContainerInitializer与java config配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h3><p>这是<code>serlvet3.0</code>的特性，它主要是用来实现<code>java config</code>的方式来配置框架，比如ssm，它通过编程的方式代理<code>web.xml</code>配置文件，通过编程的方式注册<code>serlvet</code>、<code>filter</code>、<code>Listener</code>等组件</p>
<p><code>serlvet</code>容器在启动时会扫描应用中所有<code>jar</code>包下的<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>文件，文件中的内容为实现了<code>ServletContainerInitializer</code>的实现类的全限定名</p>
<p>容器会自动创建它的实例，并且调用接口方法<code>onStartup</code></p>
<p><code>@handlesTypes</code>注解在实现了<code>servletContainerInitializer</code>的类上，决定可以这个类可以处理的类型，作为第一个参数<code>set</code>类型，被传到<code>onStartup</code>方法中</p>
<h3 id="SpringServletContainerInitializer"><a href="#SpringServletContainerInitializer" class="headerlink" title="SpringServletContainerInitializer"></a>SpringServletContainerInitializer</h3><p>在<code>spring-web-4.17.RELEASE.jar</code>的<code>META-INF</code>目录的<code>services</code>下找到文件<code>javax.servlet.ServlerContainerInitializer</code>，其中内容为</p>
<pre><code class="highlight plain">org.springframework.web.SpringServletContainerInitializer</code></pre>

<p>查看这个类</p>
<pre><code class="highlight plain">@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;

	@Override
	public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)
			throws ServletException &#123;

		List&lt;WebApplicationInitializer&gt; initializers &#x3D; new LinkedList&lt;WebApplicationInitializer&gt;();

		if (webAppInitializerClasses !&#x3D; null) &#123;
			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;
				&#x2F;&#x2F; Be defensive: Some servlet containers provide us with invalid classes,
				&#x2F;&#x2F; no matter what @HandlesTypes says...
				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;
						WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;
					try &#123;
						initializers.add((WebApplicationInitializer) waiClass.newInstance());
					&#125;
					catch (Throwable ex) &#123;
						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);
					&#125;
				&#125;
			&#125;
		&#125;

		if (initializers.isEmpty()) &#123;
			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);
			return;
		&#125;

		AnnotationAwareOrderComparator.sort(initializers);
		servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers);

		for (WebApplicationInitializer initializer : initializers) &#123;
			initializer.onStartup(servletContext);
		&#125;
	&#125;

&#125;</code></pre>

<p>我们看到类上有<code>handlesTypes</code>注解，值为<code>WebApplicationInitializer.class</code></p>
<p>断点调试查看<code>onStartup</code>方法第一个参数</p>
<p><img src="https://raw.githubusercontent.com/sinaill/pic/master/wenAppInitializerClasses.jpg" alt="webApplicationInitializerClasses"></p>
<p>确实把我们定义的继承了<code>WebApplicationInitializer</code>的子类<code>AbstractAnnotationConfigDispatcherServletInitializer</code>的类传入了</p>
<pre><code class="highlight plain">public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;
    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;
        return new Class&lt;?&gt;[]&#123;RootConfig.class&#125;;
    &#125;

    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;
        return new Class&lt;?&gt;[]&#123;MvcConfig.class&#125;;
    &#125;

    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;&#x2F;&quot;&#125;;
    &#125;

&#125;</code></pre>

<h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><p>最后容器会调用<code>WebApplicationInitializer</code>接口的<code>onStartup</code>方法，也就是调用我们上面的那个类来开始配置</p>
<p>由于我们是继承的<code>AbstractAnnotationConfigDispatcherServletInitializer</code>，所以该方法调用的是<code>AbstractDispatcherServletInitializer</code>的<code>onStartup</code>方法</p>
<pre><code class="highlight plain">@Override
public void onStartup(ServletContext servletContext) throws ServletException &#123;
	super.onStartup(servletContext);
	registerDispatcherServlet(servletContext);
&#125;</code></pre>

<h4 id="super-onStartup-servletContext"><a href="#super-onStartup-servletContext" class="headerlink" title="super.onStartup(servletContext)"></a>super.onStartup(servletContext)</h4><p>调用了父类<code>AbstractContextLoaderInitializer</code>的<code>onStartup</code>方法</p>
<pre><code class="highlight plain">@Override
public void onStartup(ServletContext servletContext) throws ServletException &#123;
	registerContextLoaderListener(servletContext);
&#125;



protected void registerContextLoaderListener(ServletContext servletContext) &#123;
	WebApplicationContext rootAppContext &#x3D; createRootApplicationContext();
	if (rootAppContext !&#x3D; null) &#123;
		servletContext.addListener(new ContextLoaderListener(rootAppContext));
	&#125;
	else &#123;
		logger.debug(&quot;No ContextLoaderListener registered, as &quot; +
				&quot;createRootApplicationContext() did not return an application context&quot;);
	&#125;
&#125;</code></pre>

<p>这里调用了<code>createRootApplicationContext</code>方法创建<code>Spring</code>容器，然后创建了<code>ContextLoaderListener</code>监听器，注册到<code>servletContext</code>中，所以使用注解式配置ssm的时候，在<code>contextLoaderListener</code>被触发的时候，容器已经被创建好了，而使用配置文件的方式就是在触发<code>contextLoaderListener</code>的时候创建<code>Spring</code>容器和<code>SpringMVC</code>容器</p>
<pre><code class="highlight plain">@Override
protected WebApplicationContext createRootApplicationContext() &#123;
	Class&lt;?&gt;[] configClasses &#x3D; getRootConfigClasses();
	if (!ObjectUtils.isEmpty(configClasses)) &#123;
		&#x2F;&#x2F;创建Spring容器
		AnnotationConfigWebApplicationContext rootAppContext &#x3D; new AnnotationConfigWebApplicationContext();
		rootAppContext.register(configClasses);
		return rootAppContext;
	&#125;
	else &#123;
		return null;
	&#125;
&#125;</code></pre>

<p>可以看到创建了<code>Spring</code>容器并且调用了我们实现的<code>getRootConfigClasses</code>方法，把获得的<code>Class</code>注册到<code>Spring容器中</code>，然后只要调用<code>Spring</code>容器的<code>refresh</code>方法就能在容器中实例化它们</p>
<h4 id="registerDispatcherServlet-servletContext"><a href="#registerDispatcherServlet-servletContext" class="headerlink" title="registerDispatcherServlet(servletContext)"></a>registerDispatcherServlet(servletContext)</h4><pre><code class="highlight plain">protected void registerDispatcherServlet(ServletContext servletContext) &#123;
	String servletName &#x3D; getServletName();
	Assert.hasLength(servletName, &quot;getServletName() must not return empty or null&quot;);

	WebApplicationContext servletAppContext &#x3D; createServletApplicationContext();
	Assert.notNull(servletAppContext,
			&quot;createServletApplicationContext() did not return an application &quot; +
			&quot;context for servlet [&quot; + servletName + &quot;]&quot;);

	DispatcherServlet dispatcherServlet &#x3D; new DispatcherServlet(servletAppContext);
	ServletRegistration.Dynamic registration &#x3D; servletContext.addServlet(servletName, dispatcherServlet);
	Assert.notNull(registration,
			&quot;Failed to register servlet with name &#39;&quot; + servletName + &quot;&#39;.&quot; +
			&quot;Check if there is another servlet registered under the same name.&quot;);

	registration.setLoadOnStartup(1);
	registration.addMapping(getServletMappings());
	registration.setAsyncSupported(isAsyncSupported());

	Filter[] filters &#x3D; getServletFilters();
	if (!ObjectUtils.isEmpty(filters)) &#123;
		for (Filter filter : filters) &#123;
			registerServletFilter(servletContext, filter);
		&#125;
	&#125;

	customizeRegistration(registration);
&#125;</code></pre>

<p><code>createServletApplicationContext</code>创建<code>SpringMVC</code>容器</p>
<pre><code class="highlight plain">@Override
protected WebApplicationContext createServletApplicationContext() &#123;
	AnnotationConfigWebApplicationContext servletAppContext &#x3D; new AnnotationConfigWebApplicationContext();
	Class&lt;?&gt;[] configClasses &#x3D; getServletConfigClasses();
	if (!ObjectUtils.isEmpty(configClasses)) &#123;
		servletAppContext.register(configClasses);
	&#125;
	return servletAppContext;
&#125;</code></pre>

<p>同样创建了一个<code>AnnotationConfigWebApplicationContext</code>对象，然后调用我们实现的<code>getServletConfigClasses</code>将获取的<code>Class</code>注册到<code>SpringMVC</code>容器中</p>
<p>接着开始注册<code>DispatcherServlet</code>，创建<code>DispatcherServlet</code>对象绑定到<code>servetContext</code>中，并将<code>SpringMVC</code>容器传入<code>DispatcherServlet</code></p>
<pre><code class="highlight plain">registration.setLoadOnStartup(1);
registration.addMapping(getServletMappings());
registration.setAsyncSupported(isAsyncSupported());</code></pre>

<p>配置启动优先级，配置<code>serlvet</code>映射方式</p>
<p>还有后面调用<code>getServletFilters</code>方法获取过滤器</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在使用配置文件方式的时候，创建<code>SpringMVC</code>容器</p>
<pre><code class="highlight plain">wac &#x3D; createWebApplicationContext(rootContext);</code></pre>

<p>将<code>Spring</code>作为父容器传入，所以<code>SpringMVC</code>容器中能取出在<code>Spring</code>容器中的对象</p>
<p>而这里使用注解方式了，没发现两个容器的关联</p>
<p>原来在两个容器关联的代码在<code>ContextLoaderListener</code>中的<code>initWebApplicationContext</code>方法中</p>
<pre><code class="highlight plain">if (this.context instanceof ConfigurableWebApplicationContext) &#123;
	ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) this.context;
	if (!cwac.isActive()) &#123;
		&#x2F;&#x2F; The context has not yet been refreshed -&gt; provide services such as
		&#x2F;&#x2F; setting the parent context, setting the application context id, etc
		if (cwac.getParent() &#x3D;&#x3D; null) &#123;
			&#x2F;&#x2F; The context instance was injected without an explicit parent -&gt;
			&#x2F;&#x2F; determine parent for root web application context, if any.
			ApplicationContext parent &#x3D; loadParentContext(servletContext);
			cwac.setParent(parent);
		&#125;
		configureAndRefreshWebApplicationContext(cwac, servletContext);
	&#125;
&#125;</code></pre>

<p>调用了<code>setParent</code>方法将<code>Spring</code>容器作为<code>SpringMVC</code>的父容器</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E8%8E%B7%E5%8F%96HandlerExecutionChain%E5%92%8CHandlerAdapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E8%8E%B7%E5%8F%96HandlerExecutionChain%E5%92%8CHandlerAdapter/" itemprop="url">SpringMVC获取HandlerExecutionChain和HandlerAdapter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="重要类"><a href="#重要类" class="headerlink" title="重要类"></a>重要类</h3><h4 id="HandlerExecutionChain和HandlerAdapter"><a href="#HandlerExecutionChain和HandlerAdapter" class="headerlink" title="HandlerExecutionChain和HandlerAdapter"></a>HandlerExecutionChain和HandlerAdapter</h4><p><code>HandlerExecutionChain</code>中有如下成员变量</p>
<pre><code class="highlight plain">public class HandlerExecutionChain&#123;
	private static final Log logger &#x3D; LogFactory.getLog(HandlerExecutionChain.class);

	private final Object handler;

	private HandlerInterceptor[] interceptors;

	private List&lt;HandlerInterceptor&gt; interceptorList;

	private int interceptorIndex &#x3D; -1;
&#125;</code></pre>

<ul>
<li><code>handler</code>：执行一个<code>HandlerMethod</code>类型的对象</li>
<li><code>interceptors</code>：存放了所有拦截器的数组</li>
<li><code>interceptorList</code>：存放了所有拦截器的链表</li>
</ul>
<h4 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h4><p><code>HandlerMethod</code>是一个接口，它的成员变量如下</p>
<pre><code class="highlight plain">public class HandlerMethod &#123;

	&#x2F;** Logger that is available to subclasses *&#x2F;
	protected final Log logger &#x3D; LogFactory.getLog(getClass());

	private final Object bean;

	private final BeanFactory beanFactory;

	private final Class&lt;?&gt; beanType;

	private final Method method;

	private final Method bridgedMethod;

	private final MethodParameter[] parameters;
&#125;</code></pre>

<ul>
<li><code>Object</code>：存放了与<code>Handler</code>有关的信息，如Demo中指向了一个方法所在的类的名称</li>
<li><code>method</code>：指向本次请求的目标<code>Handler</code>对象的目标方法</li>
<li><code>parameters</code>：存放了本次请求的入参</li>
<li><code>beanType</code>：指向了对应方法所在的<code>Handler</code>对象的类对象<code>Class</code></li>
</ul>
<h4 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h4><p>Demo中用了<code>@RequestMapping</code>注解的方式来匹配url，所以只看它</p>
<p>在Debug中，查看<code>RequestMappingHandlerMapping</code>中的成员变量，发现</p>
<ul>
<li><code>applicationContext</code>：Spring容器，可以用来获取容器中创建了的对象</li>
<li><code>servletContext</code></li>
<li><code>urlMap</code>：属于<code>LinkedMultiValueMap</code>类，key值为请求中的<code>url(lookupPath)</code>，<code>value</code>值又是一个<code>linkedList</code>，可以存放多个<code>@RequestMappingInfo</code>类型的对象，该对象主要存放了<code>@RequestMapping</code>注解中的属性值，例如<code>value</code>和<code>method</code>属性，键值间的映射方式为<code>url(lookupPath)</code>与<code>@RequestMapping</code>注解的value值相同</li>
<li><code>handlerMethods</code>：是一个<code>LinkedHashMap</code>，键key为<code>RequestMappingInfo</code>对象，存放了<code>@RequestMapping</code>注解的属性，值value为对应方法的<code>HandlerMethod</code>对象的映射</li>
<li><code>mappedInterceptor</code>:是一个<code>ArrayList</code>，指向了配置中的所有拦截器</li>
</ul>
<h4 id="RequestMappingInfo"><a href="#RequestMappingInfo" class="headerlink" title="RequestMappingInfo"></a>RequestMappingInfo</h4><p><a href="https://my.oschina.net/u/157224/blog/974072" target="_blank" rel="noopener">MVC请求映射信息RequestMappingInfo详解</a></p>
<h3 id="获取HandlerExecutionChain"><a href="#获取HandlerExecutionChain" class="headerlink" title="获取HandlerExecutionChain"></a>获取HandlerExecutionChain</h3><p>获取HandlerExecutionChain的关键代码如下</p>
<pre><code class="highlight plain">&#x2F;&#x2F; Determine handler for the current request.
mappedHandler &#x3D; getHandler(processedRequest);</code></pre>

<p>跟进<code>getHandler</code>方法</p>
<pre><code class="highlight plain">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;
	for (HandlerMapping hm : this.handlerMappings) &#123;
		if (logger.isTraceEnabled()) &#123;
			logger.trace(
					&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
		&#125;
		HandlerExecutionChain handler &#x3D; hm.getHandler(request);
		if (handler !&#x3D; null) &#123;
			return handler;
		&#125;
	&#125;
	return null;
&#125;</code></pre>

<p>其中在<code>DispatchServelt</code>中，<code>this.HandlerMappings</code>为<code>SpringMvc</code>中系统已经注入了三种<code>HandlerMappings</code>，如图</p>
<p><img src="http://wx3.sinaimg.cn/large/96b7c0f4ly1g2blsrig3yj20bv04174a.jpg" alt="HandlerMapping"></p>
<p>源码中依次让三种<code>HandlerMapping</code>来执行本次代码<code>HandlerExecutionChain handler = hm.getHandler(request);</code>，然后判断返回的<code>handler</code>对象是否为空，来决定是否返回该<code>handler</code>对象，所以接着查看<code>getHandler</code>方法，三种<code>HandlerMapping</code>的<code>getHandler</code>方法都继承自<code>AbstractHandlerMapping</code></p>
<pre><code class="highlight plain">@Override
public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;
	Object handler &#x3D; getHandlerInternal(request);
	if (handler &#x3D;&#x3D; null) &#123;
		handler &#x3D; getDefaultHandler();
	&#125;
	if (handler &#x3D;&#x3D; null) &#123;
		return null;
	&#125;
	&#x2F;&#x2F; Bean name or resolved handler?
	if (handler instanceof String) &#123;
		String handlerName &#x3D; (String) handler;
		handler &#x3D; getApplicationContext().getBean(handlerName);
	&#125;
	return getHandlerExecutionChain(handler, request);
&#125;</code></pre>

<p>跟入<code>getHandlerInternal</code>方法发现，<code>RequestHandlerMapping</code>对象的<code>getHandlerInternal</code>来自<code>AbstractHandlerMapping</code>的继承类<code>AbstractHandlerMethodMapping</code>，另外两种<code>BeanNameUrlHandlerMapping</code>、<code>SimpleUrlHandlerMapping</code>则来自<code>AbstractHandlerMapping</code>的另一个继承类<code>AbstractUrlMethodMapping</code></p>
<p>先看<code>AbstractHandlerMethodMapping</code></p>
<pre><code class="highlight plain">@Override
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;
	String lookupPath &#x3D; getUrlPathHelper().getLookupPathForRequest(request);
	if (logger.isDebugEnabled()) &#123;
		logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);
	&#125;
	HandlerMethod handlerMethod &#x3D; lookupHandlerMethod(lookupPath, request);
	if (logger.isDebugEnabled()) &#123;
		if (handlerMethod !&#x3D; null) &#123;
			logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);
		&#125;
		else &#123;
			logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);
		&#125;
	&#125;
	return (handlerMethod !&#x3D; null ? handlerMethod.createWithResolvedBean() : null);
&#125;</code></pre>

<p>其中变量<code>lookupPath</code>为除掉服务器根目录后剩余的url，例如在Demo中本次请求url为”<a href="http://localhost:8080/Person?name=zhang&amp;age=13&quot;(pom文件中配置了服务器path为&quot;/&quot;)，则此处`lookupPath`为&quot;/person&quot;" target="_blank" rel="noopener">http://localhost:8080/Person?name=zhang&amp;age=13&quot;(pom文件中配置了服务器path为&quot;/&quot;)，则此处`lookupPath`为&quot;/person&quot;</a></p>
<p>接着<code>HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request)</code>返回了一个<code>HandlerMethod</code>类型的对象</p>
<pre><code class="highlight plain">protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123;
	List&lt;Match&gt; matches &#x3D; new ArrayList&lt;Match&gt;();
	List&lt;T&gt; directPathMatches &#x3D; this.urlMap.get(lookupPath);
	if (directPathMatches !&#x3D; null) &#123;
		addMatchingMappings(directPathMatches, matches, request);
	&#125;
	if (matches.isEmpty()) &#123;
		&#x2F;&#x2F; No choice but to go through all mappings...
		addMatchingMappings(this.handlerMethods.keySet(), matches, request);
		&#x2F;&#x2F;这条分支在Demo中测试得，由于urlMap映射中不包括模糊匹配&#x2F;*，所以directPathMatches
		&#x2F;&#x2F;将为空，不能精确匹配到RequestMappingInfo
		&#x2F;&#x2F;当有匹配了模糊匹配的request传进来，是直接用RequestMappingHandlerMapping
		&#x2F;&#x2F;中的HandlerMethods集合中的keySet，也就是使用RequestMappingInfo集合进行遍历寻找
		&#x2F;&#x2F;匹配的RquestMappingInfo
		&#x2F;&#x2F;由这个特性得，当既有精确匹配又有模糊匹配时，优先匹配精确，然后才是模糊匹配
		&#x2F;&#x2F;补充：当使用@PathVariable的时候，匹配不到也会走这条路径
	&#125;

	if (!matches.isEmpty()) &#123;
		Comparator&lt;Match&gt; comparator &#x3D; new MatchComparator(getMappingComparator(request));
		Collections.sort(matches, comparator);
		if (logger.isTraceEnabled()) &#123;
			logger.trace(&quot;Found &quot; + matches.size() + &quot; matching mapping(s) for [&quot; + lookupPath + &quot;] : &quot; + matches);
		&#125;
		Match bestMatch &#x3D; matches.get(0);
		if (matches.size() &gt; 1) &#123;
			Match secondBestMatch &#x3D; matches.get(1);
			if (comparator.compare(bestMatch, secondBestMatch) &#x3D;&#x3D; 0) &#123;
				Method m1 &#x3D; bestMatch.handlerMethod.getMethod();
				Method m2 &#x3D; secondBestMatch.handlerMethod.getMethod();
				throw new IllegalStateException(
						&quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; + request.getRequestURL() + &quot;&#39;: &#123;&quot; +
						m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;);
			&#125;
		&#125;
		handleMatch(bestMatch.mapping, lookupPath, request);
		return bestMatch.handlerMethod;
	&#125;
	else &#123;
		return handleNoMatch(handlerMethods.keySet(), lookupPath, request);
	&#125;
&#125;</code></pre>

<p>根据传入的<code>lookupPath</code>为key值从<code>urlMap</code>中获取对应的映射<code>linkedList</code>类型的对象<code>directPahtMatches</code>，链表中存放的是<code>RequestMappingInfo</code>类型的对象，存放<code>@RequestMapping</code>注解中的属性值。然后以该链表为入参进入<code>addMatchingMappings</code>方法。</p>
<p>这一步查找到与项目<code>ServletPath</code>匹配的<code>RequestMappingInfo</code>，由于一个<code>ServletPath</code>可以匹配多个属性不同的<code>RequestMappingInfo</code>，所以还要进一步筛选最终<code>RequestMappingInfo</code></p>
<pre><code class="highlight plain">private void addMatchingMappings(Collection&lt;T&gt; mappings, List&lt;Match&gt; matches, HttpServletRequest request) &#123;
	for (T mapping : mappings) &#123;
		T match &#x3D; getMatchingMapping(mapping, request);
		if (match !&#x3D; null) &#123;
			matches.add(new Match(match, this.handlerMethods.get(mapping)));
		&#125;
	&#125;
&#125;</code></pre>

<p>传入的<code>mappings</code>是与当前<code>url</code>映射的<code>RequestMappingInfo</code>链表，遍历该链表，进入<code>getMatchingMapping(mapping, request)</code>方法</p>
<p>这一步就是开始遍历上一步筛选的<code>RequestMappingInfo</code>，接下来是筛选方式</p>
<pre><code class="highlight plain">@Override
protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) &#123;
	return info.getMatchingCondition(request);
&#125;</code></pre>

<p>调用了传进来的<code>RequestMappingInfo</code>对象的<code>getMatchingCondition</code>方法</p>
<pre><code class="highlight plain">@Override
public RequestMappingInfo getMatchingCondition(HttpServletRequest request) &#123;
	RequestMethodsRequestCondition methods &#x3D; this.methodsCondition.getMatchingCondition(request);
	&#x2F;&#x2F;存放注解中指定请求的method类型， GET、POST、PUT、DELETE等
	ParamsRequestCondition params &#x3D; this.paramsCondition.getMatchingCondition(request);
	&#x2F;**
	 * 限定参数，用法例如
	 * 1.params&#x3D;&quot;myParam&#x3D;myValue&quot;,	必须存在参数myParam,并且值为myValue.
	 * 2.params&#x3D;&quot;myParam&quot;		必须存在参数myParam.
	 * &#x2F;
	&#x2F;&#x2F;存放注解中指定的header值
	HeadersRequestCondition headers &#x3D; this.headersCondition.getMatchingCondition(request);
	ConsumesRequestCondition consumes &#x3D; this.consumesCondition.getMatchingCondition(request);
	&#x2F;&#x2F;存放注解中指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;
	ProducesRequestCondition produces &#x3D; this.producesCondition.getMatchingCondition(request);
	&#x2F;&#x2F;存放注解中指定的返回的内容类型，例如Accept: *&#x2F;*
	if (methods &#x3D;&#x3D; null || params &#x3D;&#x3D; null || headers &#x3D;&#x3D; null || consumes &#x3D;&#x3D; null || produces &#x3D;&#x3D; null) &#123;
		return null;
	&#125;

	PatternsRequestCondition patterns &#x3D; this.patternsCondition.getMatchingCondition(request);
	if (patterns &#x3D;&#x3D; null) &#123;
		return null;
	&#125;

	RequestConditionHolder custom &#x3D; this.customConditionHolder.getMatchingCondition(request);
	if (custom &#x3D;&#x3D; null) &#123;
		return null;
	&#125;

	return new RequestMappingInfo(this.name, patterns,
			methods, params, headers, consumes, produces, custom.getCondition());
&#125;</code></pre>


<p>以上代码主要查看<code>RequestMappingInfo</code>和<code>request</code>是否匹配，是的话创建一个新的<code>RequestMappingInfo</code>然后返回，否则返回空</p>
<p>这一步确定最终的<code>RequestMappingInfo</code></p>
<pre><code class="highlight plain">private void addMatchingMappings(Collection&lt;T&gt; mappings, List&lt;Match&gt; matches, HttpServletRequest request) &#123;
	for (T mapping : mappings) &#123;
		T match &#x3D; getMatchingMapping(mapping, request);
		if (match !&#x3D; null) &#123;
			matches.add(new Match(match, this.handlerMethods.get(mapping)));
		&#125;
	&#125;
&#125;</code></pre>

<p>变量<code>match</code>接收返回的<code>RequestMappingInfo</code>，然后给传入的<code>ArrayList</code>类型的对象matches添加元素<code>new Match(match, this.handlerMethods.get(mapping))</code></p>
<p>这一步将最终确定的<code>RequestMappingInfo</code>和它相对应的<code>HandlerMethods</code>对象封装到<code>Match</code>类中</p>
<pre><code class="highlight plain">private class Match &#123;

	private final T mapping;

	private final HandlerMethod handlerMethod;

	public Match(T mapping, HandlerMethod handlerMethod) &#123;
		this.mapping &#x3D; mapping;
		this.handlerMethod &#x3D; handlerMethod;
	&#125;

	@Override
	public String toString() &#123;
		return this.mapping.toString();
	&#125;
&#125;</code></pre>

<p><code>Match</code>类为定义在<code>AbstractHandlerMethodMapping</code>的内部类，</p>
<p><code>this.handlerMethods.get(mapping)</code>，<code>handlerMethods</code>为<code>AbstractHandlerMethodMapping</code>类的成员变量，定义为<code>private final Map&lt;T, HandlerMethod&gt; handlerMethods = new LinkedHashMap&lt;T, HandlerMethod&gt;();</code>，键值key为<code>RequestMappingInfo</code>类型的对象，值value为<code>HandlerMethod</code>类型的对象，从Demo中看，映射关系为<code>Controller</code>中<code>RequestMappingInfo</code>和它对应的方法，在这里根据<code>RequestMappingInfo</code>类的变量<code>mapping</code>获取对应的<code>HandlerMethod</code>对象，创建<code>Match</code>对象后添加到<code>matches</code>中</p>
<p>至此，<code>addMappingMatchings</code>结束，回到<code>lookupHandlerMethod</code>方法</p>
<pre><code class="highlight plain">protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123;
	List&lt;Match&gt; matches &#x3D; new ArrayList&lt;Match&gt;();
	List&lt;T&gt; directPathMatches &#x3D; this.urlMap.get(lookupPath);
	if (directPathMatches !&#x3D; null) &#123;
		addMatchingMappings(directPathMatches, matches, request);
	&#125;
	if (matches.isEmpty()) &#123;
		&#x2F;&#x2F; No choice but to go through all mappings...
		addMatchingMappings(this.handlerMethods.keySet(), matches, request);
	&#125;

	if (!matches.isEmpty()) &#123;
		Comparator&lt;Match&gt; comparator &#x3D; new MatchComparator(getMappingComparator(request));
		Collections.sort(matches, comparator);
		if (logger.isTraceEnabled()) &#123;
			logger.trace(&quot;Found &quot; + matches.size() + &quot; matching mapping(s) for [&quot; + lookupPath + &quot;] : &quot; + matches);
		&#125;
		Match bestMatch &#x3D; matches.get(0);
		if (matches.size() &gt; 1) &#123;
			Match secondBestMatch &#x3D; matches.get(1);
			if (comparator.compare(bestMatch, secondBestMatch) &#x3D;&#x3D; 0) &#123;
				Method m1 &#x3D; bestMatch.handlerMethod.getMethod();
				Method m2 &#x3D; secondBestMatch.handlerMethod.getMethod();
				throw new IllegalStateException(
						&quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; + request.getRequestURL() + &quot;&#39;: &#123;&quot; +
						m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;);
			&#125;
		&#125;
		handleMatch(bestMatch.mapping, lookupPath, request);
		return bestMatch.handlerMethod;
	&#125;
	else &#123;
		return handleNoMatch(handlerMethods.keySet(), lookupPath, request);
	&#125;
&#125;</code></pre>
<p>这一步又一次对经过上一步筛选的<code>RequestMappingInfo</code>进行筛选(这一步不知道为什么还会有剩多个<code>RequestMappingInfo</code>，单纯的复制<code>Handler</code>中方法，编译期就报错)</p>
<p>接着查看<code>handleMatch(bestMatch.mapping, lookupPath, request)</code></p>
<pre><code class="highlight plain">@Override
protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) &#123;
	super.handleMatch(info, lookupPath, request);

	String bestPattern;
	Map&lt;String, String&gt; uriVariables;
	Map&lt;String, String&gt; decodedUriVariables;

	Set&lt;String&gt; patterns &#x3D; info.getPatternsCondition().getPatterns();
	if (patterns.isEmpty()) &#123;
		bestPattern &#x3D; lookupPath;
		uriVariables &#x3D; Collections.emptyMap();
		decodedUriVariables &#x3D; Collections.emptyMap();
	&#125;
	else &#123;
		bestPattern &#x3D; patterns.iterator().next();
		uriVariables &#x3D; getPathMatcher().extractUriTemplateVariables(bestPattern, lookupPath);
		decodedUriVariables &#x3D; getUrlPathHelper().decodePathVariables(request, uriVariables);
	&#125;

	request.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern);
	request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, decodedUriVariables);

	if (isMatrixVariableContentAvailable()) &#123;
		Map&lt;String, MultiValueMap&lt;String, String&gt;&gt; matrixVars &#x3D; extractMatrixVariables(request, uriVariables);
		request.setAttribute(HandlerMapping.MATRIX_VARIABLES_ATTRIBUTE, matrixVars);
	&#125;

	if (!info.getProducesCondition().getProducibleMediaTypes().isEmpty()) &#123;
		Set&lt;MediaType&gt; mediaTypes &#x3D; info.getProducesCondition().getProducibleMediaTypes();
		request.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);
	&#125;
&#125;</code></pre>

<p>这个方法将<code>uriVariable</code>变量以<code>HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>为key绑定到<code>Request</code>中，并且这个<code>uriVariable</code>是<code>Map&lt;String, String&gt;</code>类型的</p>
<p>上面一大段代码主要通过<code>ServetPath</code>-&gt;<code>RequestMappingInfo</code>-&gt;<code>HandlerMethod</code>-&gt;<code>March</code><br>此时变量<code>mathces</code>中就存放了这个<code>Match</code>，选取最优<code>Match</code>，返回<code>HandlerMethod</code>对象</p>
<p>执行完后回到<code>AbstractHandlerMethodMapping</code>的<code>getHandlerInternal</code>方法</p>
<pre><code class="highlight plain">@Override
protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;
	String lookupPath &#x3D; getUrlPathHelper().getLookupPathForRequest(request);
	if (logger.isDebugEnabled()) &#123;
		logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);
	&#125;
	HandlerMethod handlerMethod &#x3D; lookupHandlerMethod(lookupPath, request);
	if (logger.isDebugEnabled()) &#123;
		if (handlerMethod !&#x3D; null) &#123;
			logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);
		&#125;
		else &#123;
			logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);
		&#125;
	&#125;
	return (handlerMethod !&#x3D; null ? handlerMethod.createWithResolvedBean() : null);
&#125;</code></pre>

<p>获取到和当前<code>Request</code>对应的<code>HandlerMethod</code>之后，还要执行<code>handlerMethod.createWithResolvedBean()</code></p>
<pre><code class="highlight plain">public HandlerMethod createWithResolvedBean() &#123;
	Object handler &#x3D; this.bean;
	if (this.bean instanceof String) &#123;
		String beanName &#x3D; (String) this.bean;
		handler &#x3D; this.beanFactory.getBean(beanName);
	&#125;
	return new HandlerMethod(this, handler);
&#125;</code></pre>

<p>这里获取了<code>HandlerMethod</code>中的<code>bean</code>变量，在Demo中Debug得，<code>Object</code>类型的<code>bean</code>变量此时指向了一个字符串<code>String</code>对象，该对象存放的是<code>HandlerMethod</code>代表的方法所在的<code>Handler</code>控制器的类的名称</p>
<p>而<code>beanFactory</code>实际指向了<code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code>，经查询，是一个与Spring IOC相关的类，这里应该就是根据取得的<code>Handler</code>类的名称，从IOC容器中取出注解<code>@controller</code>的<code>Handler</code>，从而将<code>HandlerMethod</code>中的<code>Bean</code>变量从指向字符串转化为指向对应的<code>Handler</code>对象</p>
<p>返回后，执行回到<code>AbstractHandlerMapping</code>的<code>getHandler</code>方法</p>
<pre><code class="highlight plain">@Override
public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;
	Object handler &#x3D; getHandlerInternal(request);
	if (handler &#x3D;&#x3D; null) &#123;
		handler &#x3D; getDefaultHandler();
	&#125;
	if (handler &#x3D;&#x3D; null) &#123;
		return null;
	&#125;
	&#x2F;&#x2F; Bean name or resolved handler?
	if (handler instanceof String) &#123;
		String handlerName &#x3D; (String) handler;
		handler &#x3D; getApplicationContext().getBean(handlerName);
	&#125;
	return getHandlerExecutionChain(handler, request);
&#125;</code></pre>

<p><code>handler</code>变量接收了返回的<code>HandlerMethod</code>，如果为空，获取默认<code>Handler</code>，如果还为空，就返回null。<br>接着又对<code>handler</code>变量作了处理，最终调用<code>getHandlerExecutionChain(handler, request)</code>来获取我们最终需要的<code>HandlerExecutionChain</code></p>
<pre><code class="highlight plain">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;
	HandlerExecutionChain chain &#x3D; (handler instanceof HandlerExecutionChain ?
			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));
	chain.addInterceptors(getAdaptedInterceptors());

	String lookupPath &#x3D; this.urlPathHelper.getLookupPathForRequest(request);
	for (MappedInterceptor mappedInterceptor : this.mappedInterceptors) &#123;
		if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;
			chain.addInterceptor(mappedInterceptor.getInterceptor());
		&#125;
	&#125;

	return chain;
&#125;</code></pre>

<p>第一步对传进来的<code>handler</code>变量进行判断，是否属于类<code>HandlerExecutionChain</code>，如果是的话直接返回，否则用它作为形参调用构造方法创建一个<code>HandlerExecution</code>对象。</p>
<p>然后给它添加拦截器，根据当前查找到的<code>lookupPath</code>，也就是<code>ServletPath</code>，将配置了与<code>lookupPath</code>相关的拦截器添加到<code>HandlerMethod</code>中，然后返回</p>
<h3 id="获取HandlerAdapter"><a href="#获取HandlerAdapter" class="headerlink" title="获取HandlerAdapter"></a>获取HandlerAdapter</h3><pre><code class="highlight plain">&#x2F;&#x2F; Determine handler adapter for the current request.
HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());</code></pre>
<p>为当前请求获取一个handler adapter</p>
<pre><code class="highlight plain">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;
	for (HandlerAdapter ha : this.handlerAdapters) &#123;
		if (logger.isTraceEnabled()) &#123;
			logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);
		&#125;
		if (ha.supports(handler)) &#123;
			return ha;
		&#125;
	&#125;
	throw new ServletException(&quot;No adapter for handler [&quot; + handler +
			&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);
&#125;</code></pre>

<p>同样，Spring Mvc也配置了三种HandlerAdapter</p>
<p><img src="https://github.com/sinaill/pic/blob/master/handlerAdapter.PNG?raw=true" alt=""></p>
<p>遍历，依次检测<code>handler</code>，也就是<code>HandlerMethod</code>对象，三种<code>HandlerAdapter</code>对应了三种不同的配置方式，Demo中配置方式为@Controller和@ReqeustMapping注解实现</p>
<p>所以接下来查看<code>AbstractHandlerMethodAdapter</code>的<code>supports</code>方法</p>
<pre><code class="highlight plain">@Override
public final boolean supports(Object handler) &#123;
	return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));
&#125;</code></pre>

<p>判断传入的<code>handler</code>是否属于<code>HandlerMethod</code>，由于<code>handler</code>是来自<code>mappedHandler.getHandler()</code>，<br>所以直接返回<code>handler</code></p>
<p>而<code>supportsInternal((HandlerMethod) handler)</code></p>
<pre><code class="highlight plain">@Override
protected boolean supportsInternal(HandlerMethod handlerMethod) &#123;
	return true;
&#125;</code></pre>

<p>所以直接返回<code>RequestMappingHandlerAdapter</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E7%9A%84@ModelAttribute%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E7%9A%84@ModelAttribute%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/" itemprop="url">SpringMVC的@ModelAttribute注解原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ModelAttribute注解的方法给模型中添加数据"><a href="#ModelAttribute注解的方法给模型中添加数据" class="headerlink" title="@ModelAttribute注解的方法给模型中添加数据"></a>@ModelAttribute注解的方法给模型中添加数据</h3><pre><code class="highlight plain">private ModelAndView invokeHandleMethod(HttpServletRequest request,
		HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;

	ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);

	WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);
	ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);
	ServletInvocableHandlerMethod requestMappingMethod &#x3D; createRequestMappingMethod(handlerMethod, binderFactory);

	ModelAndViewContainer mavContainer &#x3D; new ModelAndViewContainer();
	mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
	modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);
	mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

	AsyncWebRequest asyncWebRequest &#x3D; WebAsyncUtils.createAsyncWebRequest(request, response);
	asyncWebRequest.setTimeout(this.asyncRequestTimeout);

	final WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);
	asyncManager.setTaskExecutor(this.taskExecutor);
	asyncManager.setAsyncWebRequest(asyncWebRequest);
	asyncManager.registerCallableInterceptors(this.callableInterceptors);
	asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

	if (asyncManager.hasConcurrentResult()) &#123;
		Object result &#x3D; asyncManager.getConcurrentResult();
		mavContainer &#x3D; (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
		asyncManager.clearConcurrentResult();

		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
		&#125;
		requestMappingMethod &#x3D; requestMappingMethod.wrapConcurrentResult(result);
	&#125;

	requestMappingMethod.invokeAndHandle(webRequest, mavContainer);

	if (asyncManager.isConcurrentHandlingStarted()) &#123;
		return null;
	&#125;

	return getModelAndView(mavContainer, modelFactory, webRequest);
&#125;</code></pre>

<p>这是在<code>RequestMappingHandlerAdapter</code>执行目标<code>Controller</code>的方法的主要流程</p>
<pre><code class="highlight plain">ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);</code></pre>

<p>这里创建了<code>ModelFactory</code>，里面有注入<code>@ModelAttribute</code>注解了的方法</p>
<pre><code class="highlight plain">modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</code></pre>

<p>后面用这个来初始化<code>Model</code></p>
<p>可以看源码，是怎么初始化的</p>
<pre><code class="highlight plain">public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)
		throws Exception &#123;

	Map&lt;String, ?&gt; sessionAttributes &#x3D; this.sessionAttributesHandler.retrieveAttributes(request);
	mavContainer.mergeAttributes(sessionAttributes);
	&#x2F;&#x2F;
	invokeModelAttributeMethods(request, mavContainer);

	for (String name : findSessionAttributeArguments(handlerMethod)) &#123;
		if (!mavContainer.containsAttribute(name)) &#123;
			Object value &#x3D; this.sessionAttributesHandler.retrieveAttribute(request, name);
			if (value &#x3D;&#x3D; null) &#123;
				throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);
			&#125;
			mavContainer.addAttribute(name, value);
		&#125;
	&#125;
&#125;</code></pre>

<p>进入<code>invokeModelAttributeMethods</code>，这里是调用<code>@ModelAttribute</code>注解的方法</p>
<pre><code class="highlight plain">private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)
		throws Exception &#123;

	while (!this.modelMethods.isEmpty()) &#123;
		InvocableHandlerMethod attrMethod &#x3D; getNextModelMethod(mavContainer).getHandlerMethod();
		String modelName &#x3D; attrMethod.getMethodAnnotation(ModelAttribute.class).value();
		if (mavContainer.containsAttribute(modelName)) &#123;
			continue;
		&#125;

		Object returnValue &#x3D; attrMethod.invokeForRequest(request, mavContainer);

		if (!attrMethod.isVoid())&#123;
			String returnValueName &#x3D; getNameForReturnValue(returnValue, attrMethod.getReturnType());
			if (!mavContainer.containsAttribute(returnValueName)) &#123;
				mavContainer.addAttribute(returnValueName, returnValue);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<h4 id="有返回值时"><a href="#有返回值时" class="headerlink" title="有返回值时"></a>有返回值时</h4><p>当<code>@ModelAttribute</code>注解的方法的返回值类型不为<code>void</code>时，也就是有返回值时，这里的<code>returnValueName</code>的命名规则可以看<code>getNameForReturnValue</code>方法</p>
<pre><code class="highlight plain">&#x2F;**
 * Derive the model attribute name for the given return value using one of:
 * &lt;ol&gt;
 * 	&lt;li&gt;The method &#123;@code ModelAttribute&#125; annotation value
 * 	&lt;li&gt;The declared return type if it is more specific than &#123;@code Object&#125;
 * 	&lt;li&gt;The actual return value type
 * &lt;&#x2F;ol&gt;
 * @param returnValue the value returned from a method invocation
 * @param returnType the return type of the method
 * @return the model name, never &#123;@code null&#125; nor empty
 *&#x2F;
public static String getNameForReturnValue(Object returnValue, MethodParameter returnType) &#123;
	ModelAttribute annotation &#x3D; returnType.getMethodAnnotation(ModelAttribute.class);
	if (annotation !&#x3D; null &amp;&amp; StringUtils.hasText(annotation.value())) &#123;
		return annotation.value();
	&#125;
	else &#123;
		Method method &#x3D; returnType.getMethod();
		Class&lt;?&gt; resolvedType &#x3D; GenericTypeResolver.resolveReturnType(method, returnType.getContainingClass());
		return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);
	&#125;
&#125;


public static String getVariableNameForReturnType(Method method, Class&lt;?&gt; resolvedType, Object value) &#123;
	Assert.notNull(method, &quot;Method must not be null&quot;);

	if (Object.class.equals(resolvedType)) &#123;
		if (value &#x3D;&#x3D; null) &#123;
			throw new IllegalArgumentException(&quot;Cannot generate variable name for an Object return type with null value&quot;);
		&#125;
		return getVariableName(value);
	&#125;

	Class&lt;?&gt; valueClass;
	boolean pluralize &#x3D; false;

	if (resolvedType.isArray()) &#123;
		valueClass &#x3D; resolvedType.getComponentType();
		pluralize &#x3D; true;
	&#125;
	else if (Collection.class.isAssignableFrom(resolvedType)) &#123;
		valueClass &#x3D; GenericCollectionTypeResolver.getCollectionReturnType(method);
		if (valueClass &#x3D;&#x3D; null) &#123;
			if (!(value instanceof Collection)) &#123;
				throw new IllegalArgumentException(
						&quot;Cannot generate variable name for non-typed Collection return type and a non-Collection value&quot;);
			&#125;
			Collection&lt;?&gt; collection &#x3D; (Collection&lt;?&gt;) value;
			if (collection.isEmpty()) &#123;
				throw new IllegalArgumentException(
						&quot;Cannot generate variable name for non-typed Collection return type and an empty Collection value&quot;);
			&#125;
			Object valueToCheck &#x3D; peekAhead(collection);
			valueClass &#x3D; getClassForValue(valueToCheck);
		&#125;
		pluralize &#x3D; true;
	&#125;
	else &#123;
		valueClass &#x3D; resolvedType;
	&#125;

	String name &#x3D; ClassUtils.getShortNameAsProperty(valueClass);
	return (pluralize ? pluralize(name) : name);
&#125;</code></pre>

<p>看到命名规则为</p>
<ul>
<li>取方法上<code>@ModelAttribute</code>注解的<code>value</code>值</li>
<li>直接取返回的值的类型<code>Class</code>的全限定名最后一个<code>.</code>之后的字符，但是当返回值的类型为<code>Object</code>时，要取其实际类型</li>
<li>返回值的类型为<code>Array</code>或者<code>Collection</code>，获取其中的值的类型的全限定名<code>.</code>后面的字符，然后在后面继续拼接<code>List</code></li>
</ul>
<p>然后看<code>mavContainer</code>中是否已经含有该属性名称的属性，如果没有的话，将该属性添加进去，否则则什么都不做</p>
<h4 id="没有返回值"><a href="#没有返回值" class="headerlink" title="没有返回值"></a>没有返回值</h4><p><code>@ModelAttribute</code>注解的方法不用返回值往模型<code>mavContainer</code>中添加数据的方法是在入参中定义一个<code>java.util.Map</code>类型的入参</p>
<pre><code class="highlight plain">@ModelAttribute
public void test(Map map)&#123;

&#125;</code></pre>

<p>然后我们在目标方法也定义一个入参<code>java.util.Map</code>，就能在方法中在这个入参里获取到我们之前在<code>@ModelAttribute</code>方法中添加的属性</p>
<p>从什么地方入手，我们看反射调用<code>@ModelAttribute</code>注解的方法的入参是什么</p>
<p>首先查看对入参类型为<code>java.util.Map</code>时选择的参数解析器<code>ArgumentResolver</code></p>
<pre><code class="highlight plain">if (this.argumentResolvers.supportsParameter(parameter)) &#123;
	try &#123;
		args[i] &#x3D; this.argumentResolvers.resolveArgument(
				parameter, mavContainer, request, this.dataBinderFactory);
		continue;
	&#125;
	catch (Exception ex) &#123;
		if (logger.isDebugEnabled()) &#123;
			logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
		&#125;
		throw ex;
	&#125;
&#125;</code></pre>

<p>选择的参数解析器<code>ArgumentResolver</code>为<code>MapMethodProcessor</code></p>
<p>我们查看它的<code>supportsParameter</code>方法和<code>resolveArgument</code>方法</p>
<pre><code class="highlight plain">@Override
public boolean supportsParameter(MethodParameter parameter) &#123;
	return Map.class.isAssignableFrom(parameter.getParameterType());
&#125;

@Override
public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
		NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;

	return mavContainer.getModel();
&#125;</code></pre>

<p>可以看到适用于入参为<code>Java.util.Map</code>的时候，所以<code>ModelMap</code>和<code>Model</code>也行</p>
<p>我们看它是怎么解析的，直接返回了<code>mavContainer</code>中的<code>BindingAwareModelMap</code>对象，也就是说我们在执行<code>Controller</code>中的方法的时候，入参为<code>java.util.Map</code>的时候，都回被解析成<code>mavContainer</code>中的<code>BindingAwareModelMap</code>，所以我们能在不同方法中使用同一个<code>java.util.Map</code>入参来共享变量，估计<code>@InitBinder</code>方法也可以这样</p>
<h3 id="与-SessionAttributes合用"><a href="#与-SessionAttributes合用" class="headerlink" title="与@SessionAttributes合用"></a>与@SessionAttributes合用</h3><p>在执行<code>@ModelAttribute</code>的方法之前，还有对<code>@SessionAttributes</code>注解属性的行为</p>
<pre><code class="highlight plain">public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)
		throws Exception &#123;

	Map&lt;String, ?&gt; sessionAttributes &#x3D; this.sessionAttributesHandler.retrieveAttributes(request);
	mavContainer.mergeAttributes(sessionAttributes);
	&#x2F;&#x2F;
	invokeModelAttributeMethods(request, mavContainer);

	for (String name : findSessionAttributeArguments(handlerMethod)) &#123;
		if (!mavContainer.containsAttribute(name)) &#123;
			Object value &#x3D; this.sessionAttributesHandler.retrieveAttribute(request, name);
			if (value &#x3D;&#x3D; null) &#123;
				throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);
			&#125;
			mavContainer.addAttribute(name, value);
		&#125;
	&#125;
&#125;</code></pre>

<p>首先，<code>Controller</code>类上的注解<code>@SessionAttributes</code>的<code>value</code>值，当往<code>Model</code>中添加属性时，属性名与这个<code>value</code>值相同时，会被放入<code>Session</code>中，然后这里会以<code>@SessionAttributes</code>注解的值为<code>key</code>，从<code>Session</code>中取出，合并到<code>mavContainer</code>的<code>BindingAwareModelMap</code>中</p>
<p>然后看调用<code>@ModelAttribute</code>方法之前</p>
<pre><code class="highlight plain">private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)
		throws Exception &#123;

	while (!this.modelMethods.isEmpty()) &#123;
		InvocableHandlerMethod attrMethod &#x3D; getNextModelMethod(mavContainer).getHandlerMethod();
		String modelName &#x3D; attrMethod.getMethodAnnotation(ModelAttribute.class).value();
		if (mavContainer.containsAttribute(modelName)) &#123;
			continue;
		&#125;

		Object returnValue &#x3D; attrMethod.invokeForRequest(request, mavContainer);

		if (!attrMethod.isVoid())&#123;
			String returnValueName &#x3D; getNameForReturnValue(returnValue, attrMethod.getReturnType());
			if (!mavContainer.containsAttribute(returnValueName)) &#123;
				mavContainer.addAttribute(returnValueName, returnValue);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p>这里先获取了<code>@ModelAttribute</code>的<code>value</code>，如果<code>BindingAwareModelMap</code>中已经有与<code>value</code>相同的<code>key</code>，则跳过这个<code>@ModelAttribute</code>方法的调用</p>
<p>还有一个特殊的用法，可以在<code>Controller</code>方法中使用<code>@ModelAttribute</code>注解入参，它的<code>value</code>与<code>SessionAttribute</code>的<code>value</code>相同时，这个入参也可以接收到<code>Session</code>中的属性</p>
<p>它的原理在于，我们看处理<code>@ModelAttribute</code>注解参数的处理解析器<code>ModelAttributeMethodProcessor</code></p>
<pre><code class="highlight plain">public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
		NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;

	String name &#x3D; ModelFactory.getNameForParameter(parameter);
	Object attribute &#x3D; (mavContainer.containsAttribute(name) ?
			mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

	WebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);
	if (binder.getTarget() !&#x3D; null) &#123;
		bindRequestParameters(binder, webRequest);
		validateIfApplicable(binder, parameter);
		if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;
			throw new BindException(binder.getBindingResult());
		&#125;
	&#125;

	&#x2F;&#x2F; Add resolved attribute and BindingResult at the end of the model
	Map&lt;String, Object&gt; bindingResultModel &#x3D; binder.getBindingResult().getModel();
	mavContainer.removeAttributes(bindingResultModel);
	mavContainer.addAllAttributes(bindingResultModel);

	return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
&#125;</code></pre>

<p>它先获取了入参<code>@ModelAttribute</code>的<code>value</code>，然后如果<code>BindingAwareModelMap</code>有与该值相同的<code>key</code>，取出该属性<code>attribute</code>，后面就是将<code>request</code>请求中的属性绑定到这个<code>attribute</code>了，然后这个<code>attribute</code>就作为调用该<code>Controller</code>方法的参数来反射调用</p>
<p>此时在整个流程中，在完成以上动作前，<code>@ModelAttribute</code>方法已经执行完了，所以已经完成了将<code>Session</code>中属性合并到<code>BindingAwareModelMap</code>中</p>
<p>其实一般入参分两种情况，属于简单类的，例如<code>CharSequence</code>、<code>Number</code>、<code>Date</code>、<code>Class</code>，是由<code>RequestParamMethodArgumentResolver</code>这个类负责解析，其他复杂类，例如我们自定义的类，和用<code>@ModelAttribute</code>注解的入参都是由<code>ServletModelAttributeMethodProcessor</code>负责处理</p>
<p>所以复杂类入参没有<code>@ModelAttribute</code>注解也可以接收到<code>Session</code>中属性</p>
<p>但是如果我们要这样使用<code>@SessionAttributes</code>和<code>@ModelAttribute</code>的话，注意以下</p>
<pre><code class="highlight plain">public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)
		throws Exception &#123;

	Map&lt;String, ?&gt; sessionAttributes &#x3D; this.sessionAttributesHandler.retrieveAttributes(request);
	mavContainer.mergeAttributes(sessionAttributes);

	invokeModelAttributeMethods(request, mavContainer);

	for (String name : findSessionAttributeArguments(handlerMethod)) &#123;
		if (!mavContainer.containsAttribute(name)) &#123;
			Object value &#x3D; this.sessionAttributesHandler.retrieveAttribute(request, name);
			if (value &#x3D;&#x3D; null) &#123;
				throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);
			&#125;
			mavContainer.addAttribute(name, value);
		&#125;
	&#125;
&#125;


private List&lt;String&gt; findSessionAttributeArguments(HandlerMethod handlerMethod) &#123;
	List&lt;String&gt; result &#x3D; new ArrayList&lt;String&gt;();
	for (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;
		if (parameter.hasParameterAnnotation(ModelAttribute.class)) &#123;
			String name &#x3D; getNameForParameter(parameter);
			if (this.sessionAttributesHandler.isHandlerSessionAttribute(name, parameter.getParameterType())) &#123;
				result.add(name);
			&#125;
		&#125;
	&#125;
	return result;
&#125;


public static String getNameForParameter(MethodParameter parameter) &#123;
	ModelAttribute annot &#x3D; parameter.getParameterAnnotation(ModelAttribute.class);
	String attrName &#x3D; (annot !&#x3D; null) ? annot.value() : null;
	return StringUtils.hasText(attrName) ? attrName :  Conventions.getVariableNameForParameter(parameter);
&#125;</code></pre>

<p>可以看到执行完<code>@ModelAttribute</code>方法之后，在执行<code>Controller</code>目标方法之前，它要判断<code>BindingAwareModelMap</code>中对应的那个属性是否为空，空的话会抛出异常</p>
<p>也就是说要这样用的话，要保证在<code>@ModelAttribute</code>方法中就将要传递的属性和与<code>@SessionAttributes</code>和入参<code>@ModelAttribute</code>对应的属性名放入<code>BindingAwareModelMap</code>中，或者已经在<code>Session</code>中含有该属性和对应属性名，然后会在调用<code>@ModelAttribute</code>方法前被合并到<code>BindingAwareModelMap</code>中，否则会抛出异常</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81/" itemprop="url">SpringMVC拦截器运行流程源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HandlerInterceptorAdapter"><a href="#HandlerInterceptorAdapter" class="headerlink" title="HandlerInterceptorAdapter"></a>HandlerInterceptorAdapter</h3><p><code>HandlerInterceptorAdapter</code>是SpringMvc给我们用来实现拦截器的抽象类</p>
<pre><code class="highlight plain">public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor &#123;

	&#x2F;**
	 * This implementation always returns &#123;@code true&#125;.
	 *&#x2F;
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
		throws Exception &#123;
		return true;
	&#125;

	&#x2F;**
	 * This implementation is empty.
	 *&#x2F;
	@Override
	public void postHandle(
			HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
			throws Exception &#123;
	&#125;

	&#x2F;**
	 * This implementation is empty.
	 *&#x2F;
	@Override
	public void afterCompletion(
			HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception &#123;
	&#125;

	&#x2F;**
	 * This implementation is empty.
	 *&#x2F;
	@Override
	public void afterConcurrentHandlingStarted(
			HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception &#123;
	&#125;

&#125;</code></pre>

<h3 id="preHandle"><a href="#preHandle" class="headerlink" title="preHandle"></a>preHandle</h3><p>SpringMvc执行拦截器<code>preHandle</code>方法</p>
<p>在<code>DispatcherServlet</code>中执行拦截器的<code>preHandle</code>方法，刚好在<code>Handler</code>方法被执行前执行</p>
<pre><code class="highlight plain">if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
	return;
&#125;</code></pre>

<p>跟入<code>HandlerExecutionChain</code>的<code>applyPreHandle</code>方法</p>
<pre><code class="highlight plain">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
	HandlerInterceptor[] interceptors &#x3D; getInterceptors();
	if (!ObjectUtils.isEmpty(interceptors)) &#123;
		for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;
			HandlerInterceptor interceptor &#x3D; interceptors[i];
			if (!interceptor.preHandle(request, response, this.handler)) &#123;
				triggerAfterCompletion(request, response, null);
				return false;
			&#125;
			this.interceptorIndex &#x3D; i;
		&#125;
	&#125;
	return true;
&#125;</code></pre>

<p><code>getInterceptors</code>方法获取<code>HandlerExecutionChain</code>中的拦截器数组<code>interceptors</code>，按照配置顺序从前到后执行拦截器的<code>preHandle</code>方法，如果有拦截器返回的结果为<code>false</code>，则进入<code>triggerAfterCompletion</code>方法</p>
<pre><code class="highlight plain">&#x2F;**
 * Trigger afterCompletion callbacks on the mapped HandlerInterceptors.
 * Will just invoke afterCompletion for all interceptors whose preHandle invocation
 * has successfully completed and returned true.
 *&#x2F;
void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)
		throws Exception &#123;

	HandlerInterceptor[] interceptors &#x3D; getInterceptors();
	if (!ObjectUtils.isEmpty(interceptors)) &#123;
		for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;
			HandlerInterceptor interceptor &#x3D; interceptors[i];
			try &#123;
				interceptor.afterCompletion(request, response, this.handler, ex);
			&#125;
			catch (Throwable ex2) &#123;
				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p>从英文注释中看出这个方法会在所有拦截器被成功执行并且返回<code>true</code>时触发，从<code>applyPreHandle</code>方法可以看到，当有拦截器返回了<code>false</code>时，这个方法也会被触发，然后执行所有拦截器的<code>afterCompletion</code>方法</p>
<h3 id="applyPostHandle"><a href="#applyPostHandle" class="headerlink" title="applyPostHandle"></a>applyPostHandle</h3><pre><code class="highlight plain">mappedHandler.applyPostHandle(processedRequest, response, mv);</code></pre>

<p><code>applyPostHandle</code>方法在执行完<code>Handler</code>的目标方法后被执行，所以形参中有类型为<code>ModelAndView</code>变量<code>mv</code></p>
<pre><code class="highlight plain">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;
	HandlerInterceptor[] interceptors &#x3D; getInterceptors();
	if (!ObjectUtils.isEmpty(interceptors)) &#123;
		for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;
			HandlerInterceptor interceptor &#x3D; interceptors[i];
			interceptor.postHandle(request, response, this.handler, mv);
		&#125;
	&#125;
&#125;</code></pre>

<p>注意到获取到拦截器数组<code>interceptors</code>后，是从高位往地位顺序执行拦截器的<code>postHandle</code>方法，在其中，我们可以对<code>Handler</code>返回的视图<code>ModelAndView</code>进行修改</p>
<h3 id="triggerAfterCompletion"><a href="#triggerAfterCompletion" class="headerlink" title="triggerAfterCompletion"></a>triggerAfterCompletion</h3><p><code>triggerAfterCompletion</code>的调用是在<code>processDispatchResult</code>方法里，在渲染完视图之后</p>
<pre><code class="highlight plain">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)
		throws Exception &#123;

	HandlerInterceptor[] interceptors &#x3D; getInterceptors();
	if (!ObjectUtils.isEmpty(interceptors)) &#123;
		for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;
			HandlerInterceptor interceptor &#x3D; interceptors[i];
			try &#123;
				interceptor.afterCompletion(request, response, this.handler, ex);
			&#125;
			catch (Throwable ex2) &#123;
				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p>执行完拦截器的<code>applyHandle</code>，处理器<code>Controller Handler</code>的方法，然后执行<code>postHandle</code>方法，再渲染视图，最后调用这个方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E5%AF%B9Controller%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Emav%E7%9A%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E5%AF%B9Controller%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Emav%E7%9A%84%E5%A4%84%E7%90%86/" itemprop="url">SpringMVC对Controller目标方法返回mav的处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>在<code>DispatchServlet</code>中</p>
<pre><code class="highlight plain">mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre>

<p>执行完<code>Controller</code>的目标方法后，然后一个带有<code>Model</code>和<code>view</code>的<code>ModelAndView</code>对象</p>
<p>接下来就是对视图的处理</p>
<pre><code class="highlight plain">applyDefaultViewName(request, mv);


private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception &#123;
	if (mv !&#x3D; null &amp;&amp; !mv.hasView()) &#123;
		mv.setViewName(getDefaultViewName(request));
	&#125;
&#125;</code></pre>

<p>判断当<code>ModelAndView</code>对象中的<code>view</code>为空时，设置默认视图名</p>
<pre><code class="highlight plain">@Override
public String getViewName(HttpServletRequest request) &#123;
	String lookupPath &#x3D; this.urlPathHelper.getLookupPathForRequest(request);
	return (this.prefix + transformPath(lookupPath) + this.suffix);
&#125;</code></pre>

<p>这是设置默认视图名的代码段，这里获取的<code>lookupPath</code>为<code>getServletPath()</code>的返回结果，也就是除了项目名名以外的后面部分，<code>transformPath</code>方法的作用是将<code>lookupPath</code>的前后的<code>/</code>去掉，然后将最后一个<code>.</code>和后面的字符去掉，取剩余的部分</p>
<p>然后开始处理视图结果</p>
<pre><code class="highlight plain">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);




private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
		HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception &#123;

	boolean errorView &#x3D; false;

	if (exception !&#x3D; null) &#123;
		if (exception instanceof ModelAndViewDefiningException) &#123;
			logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);
			mv &#x3D; ((ModelAndViewDefiningException) exception).getModelAndView();
		&#125;
		else &#123;
			Object handler &#x3D; (mappedHandler !&#x3D; null ? mappedHandler.getHandler() : null);
			mv &#x3D; processHandlerException(request, response, handler, exception);
			errorView &#x3D; (mv !&#x3D; null);
		&#125;
	&#125;

	&#x2F;&#x2F; Did the handler return a view to render?
	if (mv !&#x3D; null &amp;&amp; !mv.wasCleared()) &#123;
		render(mv, request, response);
		if (errorView) &#123;
			WebUtils.clearErrorRequestAttributes(request);
		&#125;
	&#125;
	else &#123;
		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &#39;&quot; + getServletName() +
					&quot;&#39;: assuming HandlerAdapter completed request handling&quot;);
		&#125;
	&#125;

	if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;
		&#x2F;&#x2F; Concurrent handling started during a forward
		return;
	&#125;

	if (mappedHandler !&#x3D; null) &#123;
		mappedHandler.triggerAfterCompletion(request, response, null);
	&#125;
&#125;</code></pre>

<p>传进来的<code>excetpion</code>为<code>null</code></p>
<p>判断<code>ModelAndView</code>引用不为空，并且<code>ModelAndView</code>内部的<code>Model</code>和<code>View</code>也不为空时，开始渲染视图</p>
<pre><code class="highlight plain">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
	&#x2F;&#x2F; Determine locale for request and apply it to the response.
	&#x2F;&#x2F;locale表示使用者当地语言
	Locale locale &#x3D; this.localeResolver.resolveLocale(request);
	response.setLocale(locale);

	View view;
	if (mv.isReference()) &#123;
		&#x2F;&#x2F; We need to resolve the view name.
		view &#x3D; resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
		if (view &#x3D;&#x3D; null) &#123;
			throw new ServletException(&quot;Could not resolve view with name &#39;&quot; + mv.getViewName() +
					&quot;&#39; in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
		&#125;
	&#125;
	else &#123;
		&#x2F;&#x2F; No need to lookup: the ModelAndView object contains the actual View object.
		view &#x3D; mv.getView();
		if (view &#x3D;&#x3D; null) &#123;
			throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
					&quot;View object in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
		&#125;
	&#125;

	&#x2F;&#x2F; Delegate to the View object for rendering.
	if (logger.isDebugEnabled()) &#123;
		logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
	&#125;
	try &#123;
		view.render(mv.getModelInternal(), request, response);
	&#125;
	catch (Exception ex) &#123;
		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#39;&quot; +
					getServletName() + &quot;&#39;&quot;, ex);
		&#125;
		throw ex;
	&#125;
&#125;</code></pre>

<p><code>mv.isReference()</code>判断<code>ModelAndView</code>中的<code>view</code>属于<code>String</code>类型的时候，对视图进行处理</p>
<pre><code class="highlight plain">protected View resolveViewName(String viewName, Map&lt;String, Object&gt; model, Locale locale,
		HttpServletRequest request) throws Exception &#123;

	for (ViewResolver viewResolver : this.viewResolvers) &#123;
		View view &#x3D; viewResolver.resolveViewName(viewName, locale);
		if (view !&#x3D; null) &#123;
			return view;
		&#125;
	&#125;
	return null;
&#125;</code></pre>

<p>这里的视图解析器<code>viewResolver</code>来自于我们在配置文件中注入</p>
<pre><code class="highlight plain">&lt;!-- 3.配置jsp 显示ViewResolver --&gt;
&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
	&lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot; &#x2F;&gt;
	&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;
	&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>

<p>这里调用的<code>InternalResourceViewResolver</code>对视图名进行解析处理</p>
<pre><code class="highlight plain">@Override
public View resolveViewName(String viewName, Locale locale) throws Exception &#123;
	if (!isCache()) &#123;
		return createView(viewName, locale);
	&#125;
	else &#123;
		Object cacheKey &#x3D; getCacheKey(viewName, locale);
		View view &#x3D; this.viewAccessCache.get(cacheKey);
		if (view &#x3D;&#x3D; null) &#123;
			synchronized (this.viewCreationCache) &#123;
				view &#x3D; this.viewCreationCache.get(cacheKey);
				if (view &#x3D;&#x3D; null) &#123;
					&#x2F;&#x2F; Ask the subclass to create the View object.
					view &#x3D; createView(viewName, locale);
					if (view &#x3D;&#x3D; null &amp;&amp; this.cacheUnresolved) &#123;
						view &#x3D; UNRESOLVED_VIEW;
					&#125;
					if (view !&#x3D; null) &#123;
						this.viewAccessCache.put(cacheKey, view);
						this.viewCreationCache.put(cacheKey, view);
						if (logger.isTraceEnabled()) &#123;
							logger.trace(&quot;Cached view [&quot; + cacheKey + &quot;]&quot;);
						&#125;
					&#125;
				&#125;
			&#125;
		&#125;
		return (view !&#x3D; UNRESOLVED_VIEW ? view : null);
	&#125;
&#125;</code></pre>

<p>前面是对于缓存的处理，然后是<code>createView(viewName, locale)</code>创建视图对象<code>View</code></p>
<pre><code class="highlight plain">@Override
protected View createView(String viewName, Locale locale) throws Exception &#123;
	&#x2F;&#x2F; If this resolver is not supposed to handle the given view,
	&#x2F;&#x2F; return null to pass on to the next resolver in the chain.
	if (!canHandle(viewName, locale)) &#123;
		return null;
	&#125;
	&#x2F;&#x2F; Check for special &quot;redirect:&quot; prefix.
	if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;
		String redirectUrl &#x3D; viewName.substring(REDIRECT_URL_PREFIX.length());
		RedirectView view &#x3D; new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());
		return applyLifecycleMethods(viewName, view);
	&#125;
	&#x2F;&#x2F; Check for special &quot;forward:&quot; prefix.
	if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;
		String forwardUrl &#x3D; viewName.substring(FORWARD_URL_PREFIX.length());
		return new InternalResourceView(forwardUrl);
	&#125;
	&#x2F;&#x2F; Else fall back to superclass implementation: calling loadView.
	return super.createView(viewName, locale);
&#125;</code></pre>

<p>先看<code>canHandle(viewName, locale)</code></p>
<pre><code class="highlight plain">protected boolean canHandle(String viewName, Locale locale) &#123;
	String[] viewNames &#x3D; getViewNames();
	return (viewNames &#x3D;&#x3D; null || PatternMatchUtils.simpleMatch(viewNames, viewName));
&#125;</code></pre>

<p>字符串数组<code>viewNames</code>也是在配置<code>InternalResourceViewResolver</code>的时候配置好的，根据这个决定是否处理这个视图</p>
<p>然后可以看到这里根据视图前缀创建不同类型的视图对象<code>View</code>，分别是以<code>redirect:</code>开头的重定向<code>RedirectView</code>，以<code>forward:</code>开头的内部转发<code>InternalResourceView</code>，和第三种没有前缀的如下，调用了父类的<code>createView</code>方法</p>
<pre><code class="highlight plain">protected View createView(String viewName, Locale locale) throws Exception &#123;
	return loadView(viewName, locale);
&#125;


@Override
protected View loadView(String viewName, Locale locale) throws Exception &#123;
	AbstractUrlBasedView view &#x3D; buildView(viewName);
	View result &#x3D; applyLifecycleMethods(viewName, view);
	return (view.checkResource(locale) ? result : null);
&#125;

@Override
protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123;
	InternalResourceView view &#x3D; (InternalResourceView) super.buildView(viewName);
	if (this.alwaysInclude !&#x3D; null) &#123;
		view.setAlwaysInclude(this.alwaysInclude);
	&#125;
	view.setPreventDispatchLoop(true);
	return view;
&#125;

protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123;
	AbstractUrlBasedView view &#x3D; (AbstractUrlBasedView) BeanUtils.instantiateClass(getViewClass());
	view.setUrl(getPrefix() + viewName + getSuffix());

	String contentType &#x3D; getContentType();
	if (contentType !&#x3D; null) &#123;
		view.setContentType(contentType);
	&#125;

	view.setRequestContextAttribute(getRequestContextAttribute());
	view.setAttributesMap(getAttributesMap());
	&#x2F;&#x2F;决定是否将PathVariable合并到Model中
	Boolean exposePathVariables &#x3D; getExposePathVariables();
	if (exposePathVariables !&#x3D; null) &#123;
		view.setExposePathVariables(exposePathVariables);
	&#125;
	Boolean exposeContextBeansAsAttributes &#x3D; getExposeContextBeansAsAttributes();
	if (exposeContextBeansAsAttributes !&#x3D; null) &#123;
		view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
	&#125;
	String[] exposedContextBeanNames &#x3D; getExposedContextBeanNames();
	if (exposedContextBeanNames !&#x3D; null) &#123;
		view.setExposedContextBeanNames(exposedContextBeanNames);
	&#125;

	return view;
&#125;</code></pre>

<p><code>getViewClass()</code>获取配置文件中<code>InternalResourceViewResolver</code>中的<code>viewClass</code>，这里我们配置的是<code>JstlView</code>，这里用反射的方式实例化，<code>getPrefix()</code>和<code>getSuffix()</code>对应我们配置的前后缀，来拼凑成有效的<code>url</code>，后面的都是读取<code>InternalResourceViewResolver</code>中配置的属性来初始化<code>JstlView</code></p>
<p>此外我们看到创建好视图后，还对视图进行了一些处理<code>applyLifecycleMethods(viewName, view)</code></p>
<pre><code class="highlight plain">private View applyLifecycleMethods(String viewName, AbstractView view) &#123;
	return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName);
&#125;</code></pre>

<p>因为<code>JstlView</code>实现了<code>BeanNameAware</code>接口，所以这里将<code>viewName</code>设置到<code>view</code>的<code>BeanName</code>属性中，然后还将<code>applicationContext</code>注入到<code>View</code>中，还没看<code>Spring</code>，这里跳过</p>
<p>回到<code>DispatchServlet</code>的<code>render</code>方法中，创建好视图对象之后，调用视图对象的<code>render</code>方法渲染视图</p>
<pre><code class="highlight plain">@Override
public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
	if (logger.isTraceEnabled()) &#123;
		logger.trace(&quot;Rendering view with name &#39;&quot; + this.beanName + &quot;&#39; with model &quot; + model +
			&quot; and static attributes &quot; + this.staticAttributes);
	&#125;

	Map&lt;String, Object&gt; mergedModel &#x3D; createMergedOutputModel(model, request, response);
	prepareResponse(request, response);
	renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
&#125;</code></pre>

<p>这里创建了一个<code>Map</code>类型的对象</p>
<pre><code class="highlight plain">protected Map&lt;String, Object&gt; createMergedOutputModel(Map&lt;String, ?&gt; model, HttpServletRequest request,
		HttpServletResponse response) &#123;

	@SuppressWarnings(&quot;unchecked&quot;)
	Map&lt;String, Object&gt; pathVars &#x3D; (this.exposePathVariables ?
			(Map&lt;String, Object&gt;) request.getAttribute(View.PATH_VARIABLES) : null);

	&#x2F;&#x2F; Consolidate static and dynamic model attributes.
	int size &#x3D; this.staticAttributes.size();
	size +&#x3D; (model !&#x3D; null ? model.size() : 0);
	size +&#x3D; (pathVars !&#x3D; null ? pathVars.size() : 0);

	Map&lt;String, Object&gt; mergedModel &#x3D; new LinkedHashMap&lt;String, Object&gt;(size);
	mergedModel.putAll(this.staticAttributes);
	if (pathVars !&#x3D; null) &#123;
		mergedModel.putAll(pathVars);
	&#125;
	if (model !&#x3D; null) &#123;
		mergedModel.putAll(model);
	&#125;

	&#x2F;&#x2F; Expose RequestContext?
	if (this.requestContextAttribute !&#x3D; null) &#123;
		mergedModel.put(this.requestContextAttribute, createRequestContext(request, response, mergedModel));
	&#125;

	return mergedModel;
&#125;</code></pre>

<p><code>exposePathVariables</code>变量是我们在初始化<code>JstlView</code>的注入的，来源于<code>InternalResourceViewResolver</code>，默认为<code>true</code>，用来获取<code>url</code>中{}属性和值</p>
<p>这里合并<code>ModelAndView</code>中的<code>ModelMap</code>和<code>pathVars</code>，然后返回</p>
<p>然后使用合并之后的<code>ModelMap</code>继续渲染视图</p>
<pre><code class="highlight plain">@Override
protected void renderMergedOutputModel(
		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;

	&#x2F;&#x2F; Expose the model object as request attributes.
	exposeModelAsRequestAttributes(model, request);

	&#x2F;&#x2F; Expose helpers as request attributes, if any.
	exposeHelpers(request);

	&#x2F;&#x2F; Determine the path for the request dispatcher.
	String dispatcherPath &#x3D; prepareForRendering(request, response);

	&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).
	RequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);
	if (rd &#x3D;&#x3D; null) &#123;
		throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
				&quot;]: Check that the corresponding file exists within your web application archive!&quot;);
	&#125;

	&#x2F;&#x2F; If already included or response already committed, perform include, else forward.
	if (useInclude(request, response)) &#123;
		response.setContentType(getContentType());
		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
		&#125;
		rd.include(request, response);
	&#125;

	else &#123;
		&#x2F;&#x2F; Note: The forwarded resource is supposed to determine the content type itself.
		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
		&#125;
		rd.forward(request, response);
	&#125;
&#125;</code></pre>

<p>先看<code>exposeModelAsRequestAttributes(model, request);</code></p>
<pre><code class="highlight plain">protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123;
	for (Map.Entry&lt;String, Object&gt; entry : model.entrySet()) &#123;
		String modelName &#x3D; entry.getKey();
		Object modelValue &#x3D; entry.getValue();
		if (modelValue !&#x3D; null) &#123;
			request.setAttribute(modelName, modelValue);
			if (logger.isDebugEnabled()) &#123;
				logger.debug(&quot;Added model object &#39;&quot; + modelName + &quot;&#39; of type [&quot; + modelValue.getClass().getName() +
						&quot;] to request in view with name &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
			&#125;
		&#125;
		else &#123;
			request.removeAttribute(modelName);
			if (logger.isDebugEnabled()) &#123;
				logger.debug(&quot;Removed model object &#39;&quot; + modelName +
						&quot;&#39; from request in view with name &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p>这里将合并之后的<code>ModelMap</code>中不为空的属性全部放入<code>request</code>中，所以我们能在<code>jsp</code>中获取到我们在<code>Controller</code>给<code>Map</code>入参中添加的属性</p>
<p><code>preventDispatchLoop</code>属性在创建<code>JstlView</code>的时候设置为了<code>true</code></p>
<p>然后看<code>prepareForRendering(request, response)</code></p>
<pre><code class="highlight plain">protected String prepareForRendering(HttpServletRequest request, HttpServletResponse response)
		throws Exception &#123;

	String path &#x3D; getUrl();
	if (this.preventDispatchLoop) &#123;
		String uri &#x3D; request.getRequestURI();
		if (path.startsWith(&quot;&#x2F;&quot;) ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) &#123;
			throw new ServletException(&quot;Circular view path [&quot; + path + &quot;]: would dispatch back &quot; +
					&quot;to the current handler URL [&quot; + uri + &quot;] again. Check your ViewResolver setup! &quot; +
					&quot;(Hint: This may be the result of an unspecified view, due to default view name generation.)&quot;);
		&#125;
	&#125;
	return path;
&#125;</code></pre>

<p><code>getUrl</code>返回我们创建视图传入的目的资源的<code>url</code></p>
<p><code>request.getRequestURI</code>返回的结果是<code>/</code>+项目名称+剩余<code>uri</code></p>
<p>这里要防止当前<code>url</code>和跳转后的<code>url</code>相同变成死循环，检测到相同时抛出异常</p>
<p>注意到<code>StringUtils.applyRelativePath(uri, path))</code>，应该是和拼接最终<code>url</code>相关</p>
<pre><code class="highlight plain">public static String applyRelativePath(String path, String relativePath) &#123;
	int separatorIndex &#x3D; path.lastIndexOf(FOLDER_SEPARATOR);
	if (separatorIndex !&#x3D; -1) &#123;
		String newPath &#x3D; path.substring(0, separatorIndex);
		if (!relativePath.startsWith(FOLDER_SEPARATOR)) &#123;
			newPath +&#x3D; FOLDER_SEPARATOR;
		&#125;
		return newPath + relativePath;
	&#125;
	else &#123;
		return relativePath;
	&#125;
&#125;</code></pre>

<p>拼接路径的方式为原本请求路径中去掉最后一个<code>/</code>和后面的字符，当第二个值不存在<code>/</code>，也就是<code>url</code>中项目名和后面的字符全为空，这里则直接返回创建好的视图的<code>url</code>，否则去掉最后一个<code>/</code>和后面的字符，然后拼接上我们视图的<code>url</code></p>
<p>回到</p>
<pre><code class="highlight plain">@Override
protected void renderMergedOutputModel(
		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;

	&#x2F;&#x2F; Expose the model object as request attributes.
	exposeModelAsRequestAttributes(model, request);

	&#x2F;&#x2F; Expose helpers as request attributes, if any.
	exposeHelpers(request);

	&#x2F;&#x2F; Determine the path for the request dispatcher.
	String dispatcherPath &#x3D; prepareForRendering(request, response);

	&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).
	RequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);
	if (rd &#x3D;&#x3D; null) &#123;
		throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
				&quot;]: Check that the corresponding file exists within your web application archive!&quot;);
	&#125;

	&#x2F;&#x2F; If already included or response already committed, perform include, else forward.
	if (useInclude(request, response)) &#123;
		response.setContentType(getContentType());
		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
		&#125;
		rd.include(request, response);
	&#125;

	else &#123;
		&#x2F;&#x2F; Note: The forwarded resource is supposed to determine the content type itself.
		if (logger.isDebugEnabled()) &#123;
			logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
		&#125;
		rd.forward(request, response);
	&#125;
&#125;</code></pre>

<p>剩下最后一个判断<code>useInclude(request, response)</code>，查了下，<code>include</code>的作用应该是属于内嵌的一种，就是将另一个servlet/jsp处理过后的内容拿过来与本身的servlet的内容一同输出</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>当<code>ModelAndView</code>的<code>View</code>为<code>null</code>时，取默认视图名，该视图名与当前<code>url</code>有关</p>
</li>
<li><p>获取配置好的<code>InternalResourceViewResolver</code>，用来解析处理<code>ModelAndView</code>中的<code>View</code>(Object类型)</p>
</li>
<li><p>根据<code>View</code>前缀决定创建的<code>View</code>视图对象的类型</p>
</li>
<li><p>将<code>@PathVariable</code>的属性和<code>ModelAndView</code>的<code>Model</code>合并</p>
</li>
<li><p>不是重定向时，将合并后的<code>Model</code>的值放入<code>request</code>中，然后跳转</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E4%B8%ADHandler%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E4%B8%ADHandler%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C/" itemprop="url">SpringMVC中Handler方法的执行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="需要注意的类"><a href="#需要注意的类" class="headerlink" title="需要注意的类"></a>需要注意的类</h3><h4 id="invocableHandlerMethod"><a href="#invocableHandlerMethod" class="headerlink" title="invocableHandlerMethod"></a>invocableHandlerMethod</h4><h4 id="HandlerMethodParameter"><a href="#HandlerMethodParameter" class="headerlink" title="HandlerMethodParameter"></a>HandlerMethodParameter</h4><p><code>HandlerMethodParameter</code>为<code>HandlerMethod</code>的内部类和<code>MethodParameter</code>的子类</p>
<p>先看<code>MethodParameter</code></p>
<pre><code class="highlight plain">private final Method method
&#x2F;&#x2F;指向方法
private final int parameterIndex;
&#x2F;&#x2F;本方法参数在方法中的形参位置index，从0开始</code></pre>



<pre><code class="highlight plain">
</code></pre>


<h4 id="argumentResolver"><a href="#argumentResolver" class="headerlink" title="argumentResolver"></a>argumentResolver</h4><p>创建<code>InvocableHandlerMethod</code>的时候，将<code>Spring</code>给<code>RequestMappingHandlerAdapter</code>注入的<code>argumentResovlers</code>参数传递给<code>InvocableHandlerMethod</code>，用来对通过<code>GenericTypeResolver</code>确定方法参数类型之后的<code>MethodParameter</code>进行处理</p>
<p>例如<code>RequestParamMethodArgumentResolver</code>，它的<code>supportParameter</code>方法，即验证是否适用于当前参数</p>
<pre><code class="highlight plain">@Override
public boolean supportsParameter(MethodParameter parameter) &#123;
	Class&lt;?&gt; paramType &#x3D; parameter.getParameterType();
	if (parameter.hasParameterAnnotation(RequestParam.class)) &#123;
		&#x2F;&#x2F;与instanceof作用相同，只不过这个是判断类之间的管理
		&#x2F;&#x2F;判断传入的类与这个类是否相同或者是不是传入的这个类的超类或者超接口
		if (Map.class.isAssignableFrom(paramType)) &#123;
			String paramName &#x3D; parameter.getParameterAnnotation(RequestParam.class).value();
			return StringUtils.hasText(paramName);
		&#125;
		else &#123;
			return true;
		&#125;
	&#125;
	else &#123;
		if (parameter.hasParameterAnnotation(RequestPart.class)) &#123;
			return false;
		&#125;
		else if (MultipartFile.class.equals(paramType) || &quot;javax.servlet.http.Part&quot;.equals(paramType.getName())) &#123;
			return true;
		&#125;
		else if (this.useDefaultResolution) &#123;
			return BeanUtils.isSimpleProperty(paramType);
		&#125;
		else &#123;
			return false;
		&#125;
	&#125;
&#125;</code></pre>



<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><code>Handler</code>方法的执行由<code>handlerAdapter</code>接口的实现类的<code>handle</code>方法为入口</p>
<pre><code class="highlight plain">&#x2F;&#x2F; Actually invoke the handler.
mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());
&#96;&#96;&#96; 

本Demo中配置方式决定了&#96;ha&#96;变量为&#96;RequestMappingHandlerAdapter&#96;实例对象，调用该对象的&#96;handle&#96;方法
，&#96;handle&#96;方法为它父类&#96;AbstractHandlerMethodAdapter&#96;中的方法</code></pre>
<p>@Override<br>public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)<br>        throws Exception {</p>
<pre><code>return handleInternal(request, response, (HandlerMethod) handler);</code></pre><p>}</p>
<pre><code class="highlight plain">
接着又调用该对象的&#96;handleInternal&#96;方法</code></pre>
<p>@Override<br>protected ModelAndView handleInternal(HttpServletRequest request,<br>        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {</p>
<pre><code>//判断是否有@SessionAttributes注解
if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
    // Always prevent caching in case of session attribute management.
    checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
}
else {
    // Uses configured default cacheSeconds setting.
    checkAndPrepare(request, response, true);
}

// Execute invokeHandlerMethod in synchronized block if required.
if (this.synchronizeOnSession) {
    HttpSession session = request.getSession(false);
    if (session != null) {
        Object mutex = WebUtils.getSessionMutex(session);
        synchronized (mutex) {
            return invokeHandleMethod(request, response, handlerMethod);
        }
    }
}

return invokeHandleMethod(request, response, handlerMethod);</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;getSessionAttributesHandler&#96;方法</code></pre>
<p>private SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) {<br>    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>    SessionAttributesHandler sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);<br>    if (sessionAttrHandler == null) {<br>        synchronized (this.sessionAttributesHandlerCache) {<br>            sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);<br>            if (sessionAttrHandler == null) {<br>                sessionAttrHandler = new SessionAttributesHandler(handlerType, sessionAttributeStore);<br>                this.sessionAttributesHandlerCache.put(handlerType, sessionAttrHandler);<br>            }<br>        }<br>    }<br>    return sessionAttrHandler;<br>}</p>
<pre><code class="highlight plain">
单例模式创建&#96;SessionAttributesHandler&#96;，看构造方法</code></pre>
<p>public SessionAttributesHandler(Class&lt;?&gt; handlerType, SessionAttributeStore sessionAttributeStore) {<br>    Assert.notNull(sessionAttributeStore, “SessionAttributeStore may not be null.”);<br>    this.sessionAttributeStore = sessionAttributeStore;</p>
<pre><code>SessionAttributes annotation = AnnotationUtils.findAnnotation(handlerType, SessionAttributes.class);
if (annotation != null) {
    this.attributeNames.addAll(Arrays.asList(annotation.value()));
    this.attributeTypes.addAll(Arrays.&lt;Class&lt;?&gt;&gt;asList(annotation.types()));
}

for (String attributeName : this.attributeNames) {
    this.knownAttributeNames.add(attributeName);
}</code></pre><p>}</p>
<pre><code class="highlight plain">
查看&#96;Controller&#96;有没有&#96;@SessionAttributes&#96;注解

把注解中的&#96;value&#96;值放入成员变量&#96;knownAttributeNames&#96;集合中

跟入&#96;invokeHandleMethod&#96;</code></pre>
<p>/**</p>
<ul>
<li><p>Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}</p>
</li>
<li><p>if view resolution is required.</p>
</li>
<li><p>/<br>private ModelAndView invokeHandleMethod(HttpServletRequest request,</p>
<pre><code>HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {</code></pre><p>  ServletWebRequest webRequest = new ServletWebRequest(request, response);</p>
<p>  WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);<br>  ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);<br>  ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</p>
<p>  ModelAndViewContainer mavContainer = new ModelAndViewContainer();<br>  mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));<br>  modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);<br>  mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</p>
<p>  AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);<br>  asyncWebRequest.setTimeout(this.asyncRequestTimeout);</p>
<p>  final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<br>  asyncManager.setTaskExecutor(this.taskExecutor);<br>  asyncManager.setAsyncWebRequest(asyncWebRequest);<br>  asyncManager.registerCallableInterceptors(this.callableInterceptors);<br>  asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</p>
<p>  if (asyncManager.hasConcurrentResult()) {</p>
<pre><code>Object result = asyncManager.getConcurrentResult();
mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
asyncManager.clearConcurrentResult();

if (logger.isDebugEnabled()) {
    logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
}
requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</code></pre><p>  }</p>
<p>  requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</p>
<p>  if (asyncManager.isConcurrentHandlingStarted()) {</p>
<pre><code>return null;</code></pre><p>  }</p>
<p>  return getModelAndView(mavContainer, modelFactory, webRequest);<br>}</p>
<pre><code class="highlight plain">
先看&#96;WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);&#96;，进入&#96;getDataBinderFactory&#96;</code></pre>
<p>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {<br>  Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>  Set<Method> methods = this.initBinderCache.get(handlerType);<br>  if (methods == null) {</p>
<pre><code>methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);
this.initBinderCache.put(handlerType, methods);</code></pre><p>  }<br>  List<InvocableHandlerMethod> initBinderMethods = new ArrayList<InvocableHandlerMethod>();<br>  // Global methods first<br>  for (Entry&lt;ControllerAdviceBean, Set<Method>&gt; entry : this.initBinderAdviceCache .entrySet()) {</p>
<pre><code>if (entry.getKey().isApplicableToBeanType(handlerType)) {
    Object bean = entry.getKey().resolveBean();
    for (Method method : entry.getValue()) {
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }
}</code></pre><p>  }<br>  for (Method method : methods) {</p>
<pre><code>Object bean = handlerMethod.getBean();
initBinderMethods.add(createInitBinderMethod(bean, method));</code></pre><p>  }<br>  return createDataBinderFactory(initBinderMethods);<br>}</p>
<pre><code class="highlight plain">
&#96;initBinderCache&#96;字面看是&#96;@initBinder&#96;方法的缓存，看&#96;selectMethod&#96;方法</code></pre>
<p>public static Set<Method> selectMethods(final Class<?> handlerType, final MethodFilter handlerMethodFilter) {
  final Set<Method> handlerMethods = new LinkedHashSet<Method>();
  Set<Class<?>&gt; handlerTypes = new LinkedHashSet&lt;Class<?>>();
  Class<?> specificHandlerType = null;<br>  if (!Proxy.isProxyClass(handlerType)) {</p>
<pre><code>handlerTypes.add(handlerType);
specificHandlerType = handlerType;</code></pre><p>  }<br>  handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));<br>  for (Class&lt;?&gt; currentHandlerType : handlerTypes) {</p>
<pre><code>final Class&lt;?&gt; targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);
ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
    @Override
    public void doWith(Method method) {
        Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
        Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
        if (handlerMethodFilter.matches(specificMethod) &amp;&amp;
                (bridgedMethod == specificMethod || !handlerMethodFilter.matches(bridgedMethod))) {
            handlerMethods.add(specificMethod);
        }
    }
}, ReflectionUtils.USER_DECLARED_METHODS);</code></pre><p>  }<br>  return handlerMethods;<br>}</p>
<pre><code class="highlight plain">
判断传入的&#96;handlerType&#96;是不是代理类，不是的话添加到集合&#96;handlerTypes&#96;中，再让&#96;specificHandlerYtpe&#96;指向它，如果事代理类的话，将代理类实现的接口添加到集合&#96;handlerTypes&#96;中。
下一步对&#96;handlerTypes&#96;进行处理，当&#96;handlerType&#96;不是代理类时，这一步处理的就是&#96;handlerType&#96;本身，
调用了类&#96;ReflectionUtils&#96;的&#96;doWithMethods&#96;方法对&#96;handlerType&#96;进行处理</code></pre>
<p>public static void doWithMethods(Class&lt;?&gt; clazz, MethodCallback mc, MethodFilter mf) {<br>  // Keep backing up the inheritance hierarchy.<br>  Method[] methods = getDeclaredMethods(clazz);<br>  for (Method method : methods) {</p>
<pre><code>if (mf != null &amp;&amp; !mf.matches(method)) {
    continue;
}
try {
    mc.doWith(method);
}
catch (IllegalAccessException ex) {
    throw new IllegalStateException(&quot;Not allowed to access method &apos;&quot; + method.getName() + &quot;&apos;: &quot; + ex);
}</code></pre><p>  }<br>  if (clazz.getSuperclass() != null) {</p>
<pre><code>doWithMethods(clazz.getSuperclass(), mc, mf);</code></pre><p>  }<br>  else if (clazz.isInterface()) {</p>
<pre><code>for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) {
    doWithMethods(superIfc, mc, mf);
}</code></pre><p>  }<br>}</p>
<pre><code class="highlight plain">
&#96;mf&#96;为&#96;MethodFilter&#96;接口的实现类，作用为判断如果传入的&#96;method&#96;为非桥接方法和非&#96;Object&#96;中的方法就返回&#96;true&#96;，否则返回&#96;false&#96;。</code></pre>
<p>public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {</p>
<p>  @Override<br>  public boolean matches(Method method) {</p>
<pre><code>return (!method.isBridge() &amp;&amp; method.getDeclaringClass() != Object.class);</code></pre><p>  }<br>}</p>
</li>
</ul>
<pre><code class="highlight plain">

接着获取上一步的&#96;handlerType&#96;的方法，&#96;getDeclaredMethod&#96;获取的是类中定义的所有类型的方法，不包括从父类继承的。然后通过&#96;mf&#96;过滤掉桥接方法，然后使用&#96;mc&#96;的&#96;dowith&#96;方法遍历所有它们，&#96;mc&#96;为&#96;selectMehtod&#96;中的用匿名内部类的方法构造。</code></pre>
<p>new ReflectionUtils.MethodCallback() {<br>            @Override<br>            public void doWith(Method method) {<br>                Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);<br>                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);<br>                if (handlerMethodFilter.matches(specificMethod) &amp;&amp;<br>                        (bridgedMethod == specificMethod || !handlerMethodFilter.matches(bridgedMethod))) {<br>                    handlerMethods.add(specificMethod);<br>                }<br>            }<br>        }</p>
<pre><code class="highlight plain">
其中&#96;ClassUtils&#96;的&#96;getMostSpecificmethod&#96;方法，通过&#96;method&#96;查找方法名和变量名在&#96;targetClass&#96;中相同的&#96;method&#96;，&#96;BridgeMethodResolver.findBridgedMethod&#96;api的英文解释，Find the original method for the supplied bridge Method.从源码看是通过传入的桥接方法获取到Class，然后获取所有方法，匹配名字和参数个数相同的方法。接下来是&#96;handlerMethodFilter&#96;过滤器的匹配，这个过滤器定义在&#96;RequestMappingHandlerAdapter&#96;中</code></pre>
<p>public static final MethodFilter INIT_BINDER_METHODS = new MethodFilter() {</p>
<pre><code>@Override
public boolean matches(Method method) {
    return AnnotationUtils.findAnnotation(method, InitBinder.class) != null;
}</code></pre><p>};</p>
<pre><code class="highlight plain">
作用是查看方法是否有&#96;@initBinder&#96;注解，如果有返回&#96;true&#96;，没有就返回&#96;false&#96;，当&#96;specificMethod&#96;不是&#96;@initBinder&#96;注解的方法，切不是桥接方法或桥接方法为&#96;@initBinder&#96;方法时，将&#96;specificMethod&#96;添加到&#96;handlerMethods&#96;中，然后返回</code></pre>

<p>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {<br>    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>    Set<Method> methods = this.initBinderCache.get(handlerType);<br>    if (methods == null) {<br>        methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);<br>        this.initBinderCache.put(handlerType, methods);<br>    }<br>    List<InvocableHandlerMethod> initBinderMethods = new ArrayList<InvocableHandlerMethod>();<br>    // Global methods first<br>    for (Entry&lt;ControllerAdviceBean, Set<Method>&gt; entry : this.initBinderAdviceCache .entrySet()) {<br>        if (entry.getKey().isApplicableToBeanType(handlerType)) {<br>            Object bean = entry.getKey().resolveBean();<br>            for (Method method : entry.getValue()) {<br>                initBinderMethods.add(createInitBinderMethod(bean, method));<br>            }<br>        }<br>    }<br>    for (Method method : methods) {<br>        Object bean = handlerMethod.getBean();<br>        initBinderMethods.add(createInitBinderMethod(bean, method));<br>    }<br>    return createDataBinderFactory(initBinderMethods);<br>}</p>
<pre><code class="highlight plain">
这样返回的&#96;methods&#96;集合中就有了和当前&#96;handlerType&#96;(当前&#96;request&#96;对应的&#96;controller&#96;)对应的&#96;@initBinder&#96;方法，并且存放在了缓存&#96;initBinderCache&#96;中，&#96;initBinderAdviceCache&#96;存放的是在&#96;@controllerAdvice&#96;中的全局&#96;@initBinder&#96;方法。

然后调用&#96;createInitBinderMethod&#96;方法创建一个&#96;invocableHandlerMethod&#96;</code></pre>
<p>private InvocableHandlerMethod createInitBinderMethod(Object bean, Method method) {<br>    InvocableHandlerMethod binderMethod = new InvocableHandlerMethod(bean, method);<br>    binderMethod.setHandlerMethodArgumentResolvers(this.initBinderArgumentResolvers);<br>    binderMethod.setDataBinderFactory(new DefaultDataBinderFactory(this.webBindingInitializer));<br>    binderMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);<br>    return binderMethod;<br>}</p>
<pre><code class="highlight plain">
然后将全局&#96;@initBinder&#96;方法和控制器中的&#96;@initBinder&#96;方法放入集合&#96;initBinderMethods&#96;中，并且用它来创建数据绑定工厂</code></pre>
<p>protected InitBinderDataBinderFactory createDataBinderFactory(List<InvocableHandlerMethod> binderMethods)<br>        throws Exception {</p>
<pre><code>return new ServletRequestDataBinderFactory(binderMethods, getWebBindingInitializer());</code></pre><p>}</p>
<pre><code class="highlight plain">
</code></pre>
<p>WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</p>
<pre><code class="highlight plain">
以上主要查找了控制器中和全局&#96;@initBinder&#96;方法，然后和&#96;webBindingInitializer&#96;一同创建&#96;servletRequestDataBinderFactory&#96;

接下来看</code></pre>
<p>ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory)</p>
<pre><code class="highlight plain">
</code></pre>
<p>private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {<br>    SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);<br>    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>    Set<Method> methods = this.modelAttributeCache.get(handlerType);<br>    if (methods == null) {<br>        methods = HandlerMethodSelector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);<br>        this.modelAttributeCache.put(handlerType, methods);<br>    }<br>    List<InvocableHandlerMethod> attrMethods = new ArrayList<InvocableHandlerMethod>();<br>    // Global methods first<br>    for (Entry&lt;ControllerAdviceBean, Set<Method>&gt; entry : this.modelAttributeAdviceCache.entrySet()) {<br>        if (entry.getKey().isApplicableToBeanType(handlerType)) {<br>            Object bean = entry.getKey().resolveBean();<br>            for (Method method : entry.getValue()) {<br>                attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));<br>            }<br>        }<br>    }<br>    for (Method method : methods) {<br>        Object bean = handlerMethod.getBean();<br>        attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));<br>    }<br>    return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);<br>}</p>
<pre><code class="highlight plain">
主要是处理&#96;@modelAttribute&#96;注解方法

&#96;getSessionAttributesHandler&#96;方法获取创建好的&#96;SessionAttributesHandler&#96;

接着从当前&#96;modelAttributeCache&#96;根据当前&#96;handlerType&#96;查找集合&#96;methods&#96;</code></pre>
<p>methods = HandlerMethodSelector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</p>
<pre><code class="highlight plain">
熟悉的方法，不过过滤器换成了&#96;MODEL_ATTRIBUTE_METHODS&#96;</code></pre>
<p>public static final MethodFilter MODEL_ATTRIBUTE_METHODS = new MethodFilter() {</p>
<pre><code>@Override
public boolean matches(Method method) {
    return ((AnnotationUtils.findAnnotation(method, RequestMapping.class) == null) &amp;&amp;
            (AnnotationUtils.findAnnotation(method, ModelAttribute.class) != null));
}</code></pre><p>};</p>
<pre><code class="highlight plain">
查找当前&#96;handlerType&#96;中没有被&#96;@requestMapping&#96;注解并且有&#96;@modelAttribute&#96;注解的方法，然后再从&#96;@controllerAdvice&#96;注解的类中也找相同的全局&#96;@modelAttribute&#96;方法，然后创建&#96;modelFactory&#96;</code></pre>
<p>ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</p>
<pre><code class="highlight plain">
创建&#96;ServletInvocableHandlerMethod&#96;对象</code></pre>
<p>private ServletInvocableHandlerMethod createRequestMappingMethod(<br>        HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {</p>
<pre><code>ServletInvocableHandlerMethod requestMethod;
requestMethod = new ServletInvocableHandlerMethod(handlerMethod);
requestMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
requestMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
requestMethod.setDataBinderFactory(binderFactory);
requestMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
return requestMethod;</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;argumentResolver&#96;是&#96;HandlerMethodArgumentResolver&#96;类的实例，用来做参数解析，&#96;returnValueHandlers&#96;是&#96;HandlerMethodReturnValueHandlerComposite&#96;类的实例，用来对返回结果做处理，&#96;parameterNameDiscoverer&#96;用来记录参数名解析器</code></pre>
<p>ModelAndViewContainer mavContainer = new ModelAndViewContainer();</p>
<pre><code class="highlight plain">
ModelAndViewContainer主要是用来返回&#96;Model&#96;对象的，当然里面还有变量&#96;view&#96;存放视图

此时&#96;Model&#96;为默认&#96;Model&#96;，是新建的&#96;BindingAwareModelMap&#96;类的实例</code></pre>
<p>modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</p>
<pre><code class="highlight plain">
文档是这样写的</code></pre>
<p>/**</p>
<ul>
<li><p>Populate the model in the following order:</p>
</li>
<li><ol></li>
<li><li>Retrieve "known" session attributes listed as {@code @SessionAttributes}.</li>
<li><li>Invoke {@code @ModelAttribute} methods</li>
<li><li>Find {@code @ModelAttribute} method arguments also listed as</li>
<li><p>{@code @SessionAttributes} and ensure they’re present in the model raising</p>
</li>
<li><p>an exception if necessary.</p>
</li>
<li></ol></li>
<li><p>@param request the current request</p>
</li>
<li><p>@param mavContainer a container with the model to be initialized</p>
</li>
<li><p>@param handlerMethod the method for which the model is initialized</p>
</li>
<li><p>@throws Exception may arise from {@code @ModelAttribute} methods</p>
</li>
<li><p>/<br>public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)</p>
<pre><code>throws Exception {</code></pre><p>  Map&lt;String, ?&gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);<br>  mavContainer.mergeAttributes(sessionAttributes);</p>
<p>  invokeModelAttributeMethods(request, mavContainer);</p>
<p>  for (String name : findSessionAttributeArguments(handlerMethod)) {</p>
<pre><code>if (!mavContainer.containsAttribute(name)) {
    Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
    if (value == null) {
        throw new HttpSessionRequiredException(&quot;Expected session attribute &apos;&quot; + name + &quot;&apos;&quot;);
    }
    mavContainer.addAttribute(name, value);
}</code></pre><p>  }<br>}</p>
<pre><code class="highlight plain">
当与&#96;@SessionAttribute&#96;注解的&#96;value&#96;值相同的变量名在控制器某个方法被实例化放入&#96;model&#96;中，也就是被放入&#96;Session&#96;中后，在此处会获得这个注解的变量名的属性，源码也就是变量&#96;sessionAttributesHandler&#96;中有个变量&#96;knownAttributeNames&#96;集合，存放了&#96;@SessionAttribute&#96;注解的&#96;value&#96;值，这里通过&#96;request&#96;获取&#96;Session&#96;，然后取出&#96;value&#96;对应属性

然后&#96;mergeAttributes&#96;将获取到的属性复制一份放到&#96;mavContainer&#96;的&#96;model&#96;中

查看&#96;invokeModelAttributeMethods&#96;方法</code></pre>
<p>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)</p>
<pre><code>throws Exception {</code></pre><p>  while (!this.modelMethods.isEmpty()) {</p>
<pre><code>InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
if (mavContainer.containsAttribute(modelName)) {
    continue;
}

Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

if (!attrMethod.isVoid()){
    String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
    if (!mavContainer.containsAttribute(returnValueName)) {
        mavContainer.addAttribute(returnValueName, returnValue);
    }
}</code></pre><p>  }<br>}</p>
<pre><code class="highlight plain">
此处的&#96;modelMethods&#96;在前几步的&#96;getModelFactory&#96;中，是获取的控制器和全局&#96;@ModelAttribute&#96;方法的集合。

我们看&#96;getNextModelMethod(mavContainer).getHandlerMethod()&#96;</code></pre>
<p>private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {<br>  for (ModelMethod modelMethod : this.modelMethods) {</p>
<pre><code>if (modelMethod.checkDependencies(mavContainer)) {
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Selected @ModelAttribute method &quot; + modelMethod);
    }
    this.modelMethods.remove(modelMethod);
    return modelMethod;
}</code></pre><p>  }<br>  ModelMethod modelMethod = this.modelMethods.get(0);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>logger.trace(&quot;Selected @ModelAttribute method (not present: &quot; +
        modelMethod.getUnresolvedDependencies(mavContainer)+ &quot;) &quot; + modelMethod);</code></pre><p>  }<br>  this.modelMethods.remove(modelMethod);<br>  return modelMethod;<br>}</p>
<pre><code class="highlight plain">
对集合&#96;modelMethods&#96;进行遍历，查找合适条件的&#96;modelMethod&#96;，这里用的&#96;modelMethod&#96;的&#96;checkDependencies&#96;方法</code></pre>
<p>public boolean checkDependencies(ModelAndViewContainer mavContainer) {<br>  for (String name : this.dependencies) {</p>
<pre><code>if (!mavContainer.containsAttribute(name)) {
    return false;
}</code></pre><p>  }<br>  return true;<br>}</p>
<pre><code class="highlight plain">
关于&#96;ModelMethod&#96;的&#96;denpendencies&#96;变量，需要往前追溯一下变量&#96;modelMethod&#96;是怎么创建的

回到&#96;getModelFactory&#96;方法</code></pre>
<p>attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</p>
<pre><code class="highlight plain">
将获取到的带&#96;@ModelAttribute&#96;注解的方法&#96;method&#96;包装为&#96;InvocableHandlerMethod&#96;类型然后添加到&#96;List&lt;InvocableHandlerMethod&gt;&#96;的集合中&#96;attrMethods&#96;中，在创建&#96;ModelFactory&#96;类的实例的时候利用构造函数将其集合类型转化为&#96;List&lt;ModelMethod&gt;&#96;的集合&#96;modelMethods&#96;</code></pre>
<p>public ModelFactory(List<InvocableHandlerMethod> invocableMethods, WebDataBinderFactory dataBinderFactory,</p>
<pre><code>SessionAttributesHandler sessionAttributesHandler) {</code></pre><p>  if (invocableMethods != null) {</p>
<pre><code>for (InvocableHandlerMethod method : invocableMethods) {
    this.modelMethods.add(new ModelMethod(method));
}</code></pre><p>  }<br>  this.dataBinderFactory = dataBinderFactory;<br>  this.sessionAttributesHandler = sessionAttributesHandler;<br>}</p>
<pre><code class="highlight plain">
在构造函数里，集合&#96;attrMethods&#96;中的&#96;invocableHandlerMethod&#96;类的实例被包装为&#96;ModelMethod&#96;类的实例
&#96;new ModelMethod(method)&#96;

我们看&#96;ModelMethod&#96;的构造函数是怎么处理&#96;dependencies&#96;变量的</code></pre>
<p>private ModelMethod(InvocableHandlerMethod handlerMethod) {<br>  this.handlerMethod = handlerMethod;<br>  for (MethodParameter parameter : handlerMethod.getMethodParameters()) {</p>
<pre><code>if (parameter.hasParameterAnnotation(ModelAttribute.class)) {
    this.dependencies.add(getNameForParameter(parameter));
}</code></pre><p>  }<br>}</p>
<pre><code class="highlight plain">
&#96;getMethodParameters&#96;获取方法的所有参数，返回一个&#96;MethodParameter&#96;集合，接下来遍历这些参数，如果有带&#96;@ModelAttribute&#96;注解的，获取参数的名字放入类型为&#96;Set&lt;String&gt;&#96;集合的&#96;dependencies&#96;中

接下来就知道&#96;checkDependencies&#96;方法是做什么的了</code></pre>
<p>public boolean checkDependencies(ModelAndViewContainer mavContainer) {<br>  for (String name : this.dependencies) {</p>
<pre><code>if (!mavContainer.containsAttribute(name)) {
    return false;
}</code></pre><p>  }<br>  return true;<br>}</p>
<pre><code class="highlight plain">
&#96;!mavContainer.containsAttribute(name)&#96;，对方法的所有参数名字遍历</code></pre>
<p>public boolean containsAttribute(String name) {<br>  return getModel().containsAttribute(name);<br>}</p>
<pre><code class="highlight plain">
以上将&#96;@ModelAttribute&#96;方法的集合做了包装，&#96;invocableHandlerMethod -&gt; ModelMethod&#96;，多了个&#96;dependencies&#96;属性，类型为&#96;Set&lt;String&gt;&#96;，用来存放当前方法中带了&#96;@ModelAttribute&#96;注解的**形参**的参数名

接着遍历包装后的集合，&#96;mavContainer&#96;中的&#96;model&#96;必须拥有&#96;dependencies&#96;中所有的属性名，此时&#96;checkDependencies&#96;方法返回&#96;true&#96;，当&#96;ModelMethod&#96;的&#96;dependencies&#96;为空时，也返回&#96;true&#96;，其他返回&#96;false&#96;

回到变量&#96;ModelFactory&#96;的&#96;getNextModelMethod(mavContainer).getHandlerMethod()&#96;</code></pre>
<p>private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {<br>  for (ModelMethod modelMethod : this.modelMethods) {</p>
<pre><code>if (modelMethod.checkDependencies(mavContainer)) {
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Selected @ModelAttribute method &quot; + modelMethod);
    }
    this.modelMethods.remove(modelMethod);
    return modelMethod;
}</code></pre><p>  }<br>  ModelMethod modelMethod = this.modelMethods.get(0);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>logger.trace(&quot;Selected @ModelAttribute method (not present: &quot; +
        modelMethod.getUnresolvedDependencies(mavContainer)+ &quot;) &quot; + modelMethod);</code></pre><p>  }<br>  this.modelMethods.remove(modelMethod);<br>  return modelMethod;<br>}</p>
<pre><code class="highlight plain">
由于当前Demo中&#96;@ModelAttribute&#96;方法的形参没有带&#96;@ModelAttribute&#96;注解，所以这里&#96;dependencies&#96;为空，返回&#96;true&#96;

将符合条件的&#96;ModelMethod&#96;返回，然后移除，下面再依次返回不符合条件的&#96;ModelMethod&#96;

往回&#96;invokeModelAttributeMethods&#96;方法</code></pre>
<p>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)</p>
<pre><code>throws Exception {</code></pre><p>  while (!this.modelMethods.isEmpty()) {</p>
<pre><code>InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
if (mavContainer.containsAttribute(modelName)) {
    continue;
}

Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

if (!attrMethod.isVoid()){
    String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
    if (!mavContainer.containsAttribute(returnValueName)) {
        mavContainer.addAttribute(returnValueName, returnValue);
    }
}</code></pre><p>  }<br>}</p>
<pre><code class="highlight plain">
&#96;getNextModelMethod&#96;获取到&#96;ModelMetod&#96;后，将它解包装回&#96;InvocableHandlerMethod&#96;，获取当前方法注解&#96;@ModelAttribute&#96;的&#96;value&#96;值，如果当前&#96;mavContainer&#96;中的&#96;Model&#96;已经有与&#96;value&#96;同名的属性名，则跳过，**在之前的代码，我们知道此时**&#96;Model&#96;**中的属性来自于**&#96;@SessionAttributes&#96;

然后调用&#96;InvocableHandlerMethod&#96;的&#96;invokeForRequest&#96;方法来完成执行&#96;ModelAttribute&#96;方法，取得返回值</code></pre>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,</p>
<pre><code>Object... providedArgs) throws Exception {</code></pre><p>  Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
sb.append(Arrays.asList(args));
logger.trace(sb.toString());</code></pre><p>  }<br>  Object returnValue = doInvoke(args);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);</code></pre><p>  }<br>  return returnValue;<br>}</p>
<pre><code class="highlight plain">
获取方法参数数组</code></pre>
<p>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,</p>
<pre><code>Object... providedArgs) throws Exception {</code></pre><p>  MethodParameter[] parameters = getMethodParameters();<br>  Object[] args = new Object[parameters.length];<br>  for (int i = 0; i &lt; parameters.length; i++) {</p>
<pre><code>MethodParameter parameter = parameters[i];
parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
args[i] = resolveProvidedArgument(parameter, providedArgs);
if (args[i] != null) {
    continue;
}
if (this.argumentResolvers.supportsParameter(parameter)) {
    try {
        args[i] = this.argumentResolvers.resolveArgument(
                parameter, mavContainer, request, this.dataBinderFactory);
        continue;
    }
    catch (Exception ex) {
        if (logger.isDebugEnabled()) {
            logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
        }
        throw ex;
    }
}
if (args[i] == null) {
    String msg = getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);
    throw new IllegalStateException(msg);
}</code></pre><p>  }<br>  return args;<br>}</p>
<pre><code class="highlight plain">
获取了方法参数类型数组&#96;MethodParameter[]&#96;

遍历该数组，&#96;resolveParameterType&#96;确定每个方法参数的类型，&#96;getBean().getClass()&#96;传入方法所在的类的&#96;Class&#96;</code></pre>
<p>public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {<br>  Assert.notNull(methodParam, “MethodParameter must not be null”);<br>  Assert.notNull(clazz, “Class must not be null”);<br>  methodParam.setContainingClass(clazz);<br>  methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve());<br>  return methodParam.getParameterType();<br>}</p>
<pre><code class="highlight plain">
设置成员变量&#96;containClass&#96;和&#96;parameterType&#96;，先看&#96;forMethodParameter&#96;方法</code></pre>
<p>public static ResolvableType forMethodParameter(MethodParameter methodParameter) {<br>  return forMethodParameter(methodParameter, (Type) null);<br>}</p>
</li>
</ul>
<p>public static ResolvableType forMethodParameter(MethodParameter methodParameter, Type targetType) {<br>    Assert.notNull(methodParameter, “MethodParameter must not be null”);<br>    //获取方法参数所在的类的ResolvableType,其它参数TypeProvider和variableResolve为空<br>    ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());<br>    //typeProvider由methodParameter为参数，提供参数的真正类型<br>    //以owner创建它的内部类new DefaultVariableResolver<br>    return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).<br>            getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);<br>}</p>
<pre><code class="highlight plain">
&#96;forType&#96;是用来创建&#96;ResolveType&#96;类型的变量</code></pre>
<p>public static ResolvableType forType(Type type) {<br>    return forType(type, null, null);<br>}</p>
<p>static ResolvableType forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver) {<br>    if (type == null &amp;&amp; typeProvider != null) {<br>        type = SerializableTypeWrapper.forTypeProvider(typeProvider);<br>    }<br>    if (type == null) {<br>        return NONE;<br>    }</p>
<pre><code>// Purge empty entries on access since we don&apos;t have a clean-up thread or the like.
cache.purgeUnreferencedEntries();

// For simple Class references, build the wrapper right away -
// no expensive resolution necessary, so not worth caching...
if (type instanceof Class) {
    return new ResolvableType(type, typeProvider, variableResolver, null);
}

// Check the cache - we may have a ResolvableType which has been resolved before...
ResolvableType key = new ResolvableType(type, typeProvider, variableResolver);
ResolvableType resolvableType = cache.get(key);
if (resolvableType == null) {
    resolvableType = new ResolvableType(type, typeProvider, variableResolver, null);
    cache.put(resolvableType, resolvableType);
}
return resolvableType;</code></pre><p>}</p>
<pre><code class="highlight plain">
这里先用单独一个&#96;type&#96;，这里是&#96;containClass&#96;即方法参数所在的类，创建一个&#96;ResolveType&#96;</code></pre>
<p>private ResolvableType(<br>        Type type, TypeProvider typeProvider, VariableResolver variableResolver, ResolvableType componentType) {</p>
<pre><code>this.type = type;
this.typeProvider = typeProvider;
this.variableResolver = variableResolver;
this.componentType = componentType;
this.resolved = resolveClass();</code></pre><p>}</p>
<p>private Class<?> resolveClass() {
    if (this.type instanceof Class || this.type == null) {
        return (Class<?>) this.type;<br>    }<br>    if (this.type instanceof GenericArrayType) {<br>        Class&lt;?&gt; resolvedComponent = getComponentType().resolve();<br>        return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);<br>    }<br>    return resolveType().resolve();<br>}</p>
<pre><code class="highlight plain">
因为传来的&#96;type&#96;是&#96;invocableHandlerMethod&#96;中的&#96;bean&#96;，所以&#96;type&#96;&#x3D;&#x3D;&#96;resolved&#96;

第二次使用了为&#96;null&#96;的&#96;targetType&#96;，&#96;new MethodParameterTypeProvider(methodParameter)&#96;和&#96;owner.asVariableResolver()&#96;</code></pre>
<p>public MethodParameterTypeProvider(MethodParameter methodParameter) {<br>    if (methodParameter.getMethod() != null) {<br>        this.methodName = methodParameter.getMethod().getName();<br>        this.parameterTypes = methodParameter.getMethod().getParameterTypes();<br>    }<br>    else {<br>        this.methodName = null;<br>        this.parameterTypes = methodParameter.getConstructor().getParameterTypes();<br>    }<br>    this.declaringClass = methodParameter.getDeclaringClass();<br>    this.parameterIndex = methodParameter.getParameterIndex();<br>    this.methodParameter = methodParameter;<br>}</p>
<p>VariableResolver asVariableResolver() {<br>    if (this == NONE) {<br>        return null;<br>    }<br>    return new DefaultVariableResolver();<br>}</p>
<pre><code class="highlight plain">
创建这个&#96;TypeProvider&#96;通过构造函数传入了&#96;methodParameter&#96;，并且将它的一些属性注入到自己中

因为传入的&#96;targetType&#96;为&#96;null&#96;</code></pre>
<p>if (type == null &amp;&amp; typeProvider != null) {<br>    type = SerializableTypeWrapper.forTypeProvider(typeProvider);<br>}</p>
<p>static Type forTypeProvider(final TypeProvider provider) {<br>    Assert.notNull(provider, “Provider must not be null”);<br>    if (provider.getType() instanceof Serializable || provider.getType() == null) {<br>        return provider.getType();<br>    }<br>    Type cached = cache.get(provider.getType());<br>    if (cached != null) {<br>        return cached;<br>    }<br>    for (Class<?> type : SUPPORTED_SERIALIZABLE_TYPES) {
        if (type.isAssignableFrom(provider.getType().getClass())) {
            ClassLoader classLoader = provider.getClass().getClassLoader();
            Class<?>[] interfaces = new Class&lt;?&gt;[] { type,<br>                SerializableTypeProxy.class, Serializable.class };<br>            InvocationHandler handler = new TypeProxyInvocationHandler(provider);<br>            cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);<br>            cache.put(provider.getType(), cached);<br>            return cached;<br>        }<br>    }<br>    throw new IllegalArgumentException(“Unsupported Type class “ + provider.getType().getClass().getName());<br>}</p>
<pre><code class="highlight plain">
&#96;provider.getType()&#96;，变量&#96;provider&#96;为前面传来&#96;MethodParameterTypeProvider&#96;类型的变量，决定了参数的具体类型，它的父类&#96;TypeProvoider&#96;实现了&#96;serializable&#96;接口</code></pre>
<p>@Override<br>public Type getType() {<br>    return this.methodParameter.getGenericParameterType();<br>}</p>
<p>public Type getGenericParameterType() {<br>    if (this.genericParameterType == null) {<br>        if (this.parameterIndex &lt; 0) {<br>            this.genericParameterType = (this.method != null ? this.method.getGenericReturnType() : null);<br>        }<br>        else {<br>            this.genericParameterType = (this.method != null ?<br>                this.method.getGenericParameterTypes()[this.parameterIndex] :<br>                this.constructor.getGenericParameterTypes()[this.parameterIndex]);<br>        }<br>    }<br>    return this.genericParameterType;<br>}</p>
<pre><code class="highlight plain">
调用了类&#96;TypeProvider&#96;的&#96;getType&#96;，通过之前注入的变量&#96;MethodParameter&#96;

因为创建类&#96;HandlerMethodParameter&#96;的时候注入了&#96;Method&#96;</code></pre>
<p>public HandlerMethodParameter(int index) {<br>    super(HandlerMethod.this.bridgedMethod, index);<br>}</p>
<pre><code class="highlight plain">
所以这里能获取到参数所在的方法的所有方法参数类型&#96;this.method.getGenericParameterTypes()[this.parameterIndex]&#96;

然后利用这返回的方法参数的类型用来创建&#96;ResolveType&#96;</code></pre>
<p>if (type instanceof Class) {<br>    return new ResolvableType(type, typeProvider, variableResolver, null);<br>}</p>
<pre><code class="highlight plain">
返回的参数类型的&#96;type&#96;，又用来和之前的&#96;TypeProvider&#96;和&#96;VariableResolve&#96;创建新&#96;ResolveType&#96;

再回到之前的方法</code></pre>
<p>public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {<br>    Assert.notNull(methodParam, “MethodParameter must not be null”);<br>    Assert.notNull(clazz, “Class must not be null”);<br>    methodParam.setContainingClass(clazz);<br>    methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve());<br>    return methodParam.getParameterType();<br>}</p>
<pre><code class="highlight plain">
这里再次调用创建好的&#96;ResolveType&#96;的&#96;resolve&#96;方法</code></pre>
<p>public Class&lt;?&gt; resolve() {<br>    return resolve(null);<br>}</p>
<p>public Class<?> resolve(Class<?> fallback) {<br>    return (this.resolved != null ? this.resolved : fallback);<br>}</p>
<pre><code class="highlight plain">
这里&#96;ResolveType&#96;的成员变量&#96;resolve&#96;和&#96;type&#96;指向的都是方法的参数类型

所以这里通过&#96;ResolvableType.forMethodParameter(methodParam).resolve()&#96;来找到方法参数的具体类型，然后设置到&#96;methodParam&#96;的&#96;ParameterType&#96;中

通过这样确定了方法参数的具体类型

回到&#96;InvocalbleHandlerMethod&#96;</code></pre>
<p>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>MethodParameter[] parameters = getMethodParameters();
Object[] args = new Object[parameters.length];
for (int i = 0; i &lt; parameters.length; i++) {
    MethodParameter parameter = parameters[i];
    parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
    GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
    args[i] = resolveProvidedArgument(parameter, providedArgs);
    if (args[i] != null) {
        continue;
    }
    if (this.argumentResolvers.supportsParameter(parameter)) {
        try {
            args[i] = this.argumentResolvers.resolveArgument(
                    parameter, mavContainer, request, this.dataBinderFactory);
            continue;
        }
        catch (Exception ex) {
            if (logger.isDebugEnabled()) {
                logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
            }
            throw ex;
        }
    }
    if (args[i] == null) {
        String msg = getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);
        throw new IllegalStateException(msg);
    }
}
return args;</code></pre><p>}</p>
<pre><code class="highlight plain">
确定方法参数的具体类型之后，接着调用&#96;InvocableHandlerMethod&#96;自身的&#96;resolveProvidedArgument&#96;方法处理对方法参数进行处理</code></pre>
<p>private Object resolveProvidedArgument(MethodParameter parameter, Object… providedArgs) {<br>    if (providedArgs == null) {<br>        return null;<br>    }<br>    for (Object providedArg : providedArgs) {<br>        if (parameter.getParameterType().isInstance(providedArg)) {<br>            return providedArg;<br>        }<br>    }<br>    return null;<br>}</p>
<pre><code class="highlight plain">
Demo中源码传入得入参&#96;providedArgs&#96;为&#96;[]&#96;，所以这里返回空

接着判断&#96;this.argumentResolvers.supportsParameter(parameter)&#96;</code></pre>
<p>@Override<br>public boolean supportsParameter(MethodParameter parameter) {<br>    return getArgumentResolver(parameter) != null;<br>}</p>
<p>private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {<br>    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);<br>    if (result == null) {<br>        for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {<br>            if (logger.isTraceEnabled()) {<br>                logger.trace(“Testing if argument resolver [“ + methodArgumentResolver + “] supports [“ +<br>                        parameter.getGenericParameterType() + “]”);<br>            }<br>            if (methodArgumentResolver.supportsParameter(parameter)) {<br>                result = methodArgumentResolver;<br>                this.argumentResolverCache.put(parameter, result);<br>                break;<br>            }<br>        }<br>    }<br>    return result;<br>}</p>
<pre><code class="highlight plain">
&#96;argumentResolvers&#96;属于类&#96;HandlerMethodArgumentResolverComposite&#96;，实现了&#96;HandlerMethodArgumentResolver&#96;接口，用来解析方法参数

遍历成员变量&#96;argumentResolvers&#96;，查找一个支持当前参数类型得参数解析器，放入缓存

当前Demo正在执行&#96;@ModelAttribute&#96;方法</code></pre>
<p>@ModelAttribute(“attr”)<br>public void mda(Map map) {<br>    Person person = new Person(“li”, 12);<br>    map.put(“person”, new Person(“zh”, 14));<br>}</p>
<pre><code class="highlight plain">
这里适用于这个的解析器为&#96;MapMethodProcessor&#96;

有支持当前参数的参数解析器，所以返回&#96;true&#96;

之后对方法参数变量&#96;MethodParameter&#96;进行处理</code></pre>
<p>args[i] = this.argumentResolvers.resolveArgument(<br>        parameter, mavContainer, request, this.dataBinderFactory);</p>
<pre><code class="highlight plain">
接下来</code></pre>
<p>@Override<br>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
Assert.notNull(resolver, &quot;Unknown parameter type [&quot; + parameter.getParameterType().getName() + &quot;]&quot;);
return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;getArgumentResover(parameter)&#96;返回&#96;MapMethodProcessor&#96;

查看&#96;MapMethodProcessor&#96;的&#96;resolveArgument&#96;方法</code></pre>
<p>@Override<br>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>return mavContainer.getModel();</code></pre><p>}</p>
<pre><code class="highlight plain">
返回容器中的默认&#96;BindingAwareModelMap&#96;

也就是说，此时&#96;@ModelAttribute&#96;方法中的&#96;Map&#96;类型的参数指向了&#96;mavContainer&#96;中的&#96;Model&#96;

方法在最后返回方法参数&#96;args[]&#96;数组

回到&#96;InvocableHandlerMethod&#96;的&#96;invokeForRequest&#96;方法</code></pre>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) {
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
}
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
}
return returnValue;</code></pre><p>}</p>
<pre><code class="highlight plain">
这里接收返回的参数之后，调用&#96;doInvoke(args)&#96;真正对&#96;@ModelAttribute&#96;方法执行</code></pre>
<p>protected Object doInvoke(Object… args) throws Exception {<br>    ReflectionUtils.makeAccessible(getBridgedMethod());<br>    try {<br>        return getBridgedMethod().invoke(getBean(), args);<br>    }<br>    catch (IllegalArgumentException ex) {<br>        assertTargetBean(getBridgedMethod(), getBean(), args);<br>        throw new IllegalStateException(getInvocationErrorMessage(ex.getMessage(), args), ex);<br>    }<br>    catch (InvocationTargetException ex) {<br>        // Unwrap for HandlerExceptionResolvers …<br>        Throwable targetException = ex.getTargetException();<br>        if (targetException instanceof RuntimeException) {<br>            throw (RuntimeException) targetException;<br>        }<br>        else if (targetException instanceof Error) {<br>            throw (Error) targetException;<br>        }<br>        else if (targetException instanceof Exception) {<br>            throw (Exception) targetException;<br>        }<br>        else {<br>            String msg = getInvocationErrorMessage(“Failed to invoke controller method”, args);<br>            throw new IllegalStateException(msg, targetException);<br>        }<br>    }<br>}</p>
<pre><code class="highlight plain">
这里使用了反射的方式来执行方法，然后返回返回值，所以我们现在也知道了操作&#96;@ModelAttribute&#96;方法中的&#96;Map&#96;入参，就等于是在操作&#96;mavContainer&#96;的&#96;Model&#96;

回到&#96;ModelFactory&#96;的&#96;invokeModelAttributeMethods&#96;</code></pre>
<p>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)<br>        throws Exception {</p>
<pre><code>while (!this.modelMethods.isEmpty()) {
    InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
    String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
    if (mavContainer.containsAttribute(modelName)) {
        continue;
    }

    Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

    if (!attrMethod.isVoid()){
        String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
        if (!mavContainer.containsAttribute(returnValueName)) {
            mavContainer.addAttribute(returnValueName, returnValue);
        }
    }
}</code></pre><p>}</p>
<pre><code class="highlight plain">
如果&#96;@ModelAttribute&#96;方法不是&#96;void&#96;类型

传入参数为&#96;@ModelAttribute&#96;方法的返回值和&#96;attrMethod.getReturnType()&#96;</code></pre>
<p>public MethodParameter getReturnType() {<br>    return new HandlerMethodParameter(-1);<br>}</p>
<pre><code class="highlight plain">
接下来获取返回值名</code></pre>
<p>public static String getNameForReturnValue(Object returnValue, MethodParameter returnType) {<br>    ModelAttribute annotation = returnType.getMethodAnnotation(ModelAttribute.class);<br>    if (annotation != null &amp;&amp; StringUtils.hasText(annotation.value())) {<br>        return annotation.value();<br>    }<br>    else {<br>        Method method = returnType.getMethod();<br>        Class&lt;?&gt; resolvedType = GenericTypeResolver.resolveReturnType(method, returnType.getContainingClass());<br>        return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);<br>    }<br>}</p>
<pre><code class="highlight plain">
第一行获取方法参数所在方法是否有&#96;@ModelAttribute&#96;注解</code></pre>
<p>public <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {<br>    return getAnnotatedElement().getAnnotation(annotationType);<br>}</p>
<p>public AnnotatedElement getAnnotatedElement() {<br>    // NOTE: no ternary expression to retain JDK &lt;8 compatibility even when using<br>    // the JDK 8 compiler (potentially selecting java.lang.reflect.Executable<br>    // as common type, with that new base class not available on older JDKs)<br>    if (this.method != null) {<br>        return this.method;<br>    }<br>    else {<br>        return this.constructor;<br>    }<br>}</p>
<pre><code class="highlight plain">
如果存在注解，返回注解的&#96;value&#96;属性

然后检测&#96;mavContainer&#96;中的&#96;Model&#96;是否已经包含该&#96;value&#96;属性的值为&#96;key&#96;的键值对，如果不包含，则将&#96;value&#96;和返回值添加到&#96;Model&#96;中

回到&#96;ModelFactory&#96;的&#96;initModel&#96;方法</code></pre>
<p>public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)<br>        throws Exception {</p>
<pre><code>Map&lt;String, ?&gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);
mavContainer.mergeAttributes(sessionAttributes);

invokeModelAttributeMethods(request, mavContainer);

for (String name : findSessionAttributeArguments(handlerMethod)) {
    if (!mavContainer.containsAttribute(name)) {
        Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
        if (value == null) {
            throw new HttpSessionRequiredException(&quot;Expected session attribute &apos;&quot; + name + &quot;&apos;&quot;);
        }
        mavContainer.addAttribute(name, value);
    }
}</code></pre><p>}</p>
<pre><code class="highlight plain">
上面执行完&#96;invokeModelAttributeMethods(request, mavContainer)&#96;之后

&#96;findSessionAttributeArguments(handlerMethod)&#96;返回的结果是响应的&#96;Handler&#96;方法中参数带&#96;@ModelAttribute&#96;注解的&#96;value&#96;值和&#96;@SessionAttributes&#96;注解的&#96;value&#96;相同时的&#96;value&#96;，或者带&#96;@ModelAttribute&#96;注解的方法参数属于&#96;@SessionAttributes&#96;注解的&#96;Types&#96;范围内的&#96;value&#96;

然后将&#96;value&#96;作为&#96;key&#96;取出因为&#96;Session&#96;中相应属性，添加到&#96;mavContainer&#96;的&#96;Model&#96;中

取出的值为null时，抛出异常，也就是说当&#96;@SessionAttributes&#96;和&#96;Handler&#96;方法中参数的&#96;@ModelAttribute&#96;对应时，例如&#96;value&#96;相同，在执行完ModelAttribute方法之后，&#96;mavContainer&#96;中必须有值能传给这个&#96;@ModelAttribute&#96;方法参数

以上就是&#96;modelFactory.initModel(webRequest, mavContainer, requestMappingMethod)&#96;完成的事

接下来是对&#96;Controller&#96;中响应网页请求的方法的执行

该方法</code></pre>
<p>@RequestMapping(“/Person”)<br>public String testParam(Person person,HttpSession session) {<br>    System.out.println(person.getName()+” “+person.getAge());<br>    session.setAttribute(“person”, person);<br>    return “person”;<br>}</p>
<pre><code class="highlight plain">
依旧回到&#96;RequestMappingHandlerAdapter&#96;</code></pre>
<p>requestMappingMethod.invokeAndHandle(webRequest, mavContainer)</p>
<pre><code class="highlight plain">
其中&#96;requestMappingMethod&#96;是由&#96;InvocableHandlerMethod&#96;包装成的&#96;ServletInvocableHandlerMethod&#96;，它指向响应了客户端请求的方法</code></pre>
<p>ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory)</p>
<p>private ServletInvocableHandlerMethod createRequestMappingMethod(<br>        HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {</p>
<pre><code>ServletInvocableHandlerMethod requestMethod;
requestMethod = new ServletInvocableHandlerMethod(handlerMethod);
requestMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
requestMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
requestMethod.setDataBinderFactory(binderFactory);
requestMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
return requestMethod;</code></pre><p>}</p>
<pre><code class="highlight plain">
进入&#96;invokeAndHandle(webRequest, mavContainer)&#96;，调用响应方法</code></pre>
<p>public void invokeAndHandle(ServletWebRequest webRequest,<br>        ModelAndViewContainer mavContainer, Object… providedArgs) throws Exception {</p>
<pre><code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
setResponseStatus(webRequest);

if (returnValue == null) {
    if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
        mavContainer.setRequestHandled(true);
        return;
    }
}
else if (StringUtils.hasText(this.responseReason)) {
    mavContainer.setRequestHandled(true);
    return;
}

mavContainer.setRequestHandled(false);
try {
    this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
}
catch (Exception ex) {
    if (logger.isTraceEnabled()) {
        logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
    }
    throw ex;
}</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;invokeForRequest&#96;方法调用响应方法获取返回值</code></pre>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) {
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
}
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
}
return returnValue;</code></pre><p>}</p>
<pre><code class="highlight plain">
接下来的步骤与执行&#96;@ModelAttribute&#96;方法差不多，通过&#96;GenericTypeResolver&#96;确认了&#96;MethodParameter&#96;中的&#96;ParameterType&#96;

接着获取适用&#96;HandlerMethodArgumentResolver&#96;时，这里使用的是&#96;ServletModelAttributeMethodProcessor&#96;</code></pre>
<p>public boolean supportsParameter(MethodParameter parameter) {<br>    if (parameter.hasParameterAnnotation(ModelAttribute.class)) {<br>        return true;<br>    }<br>    else if (this.annotationNotRequired) {<br>        return !BeanUtils.isSimpleProperty(parameter.getParameterType());<br>    }<br>    else {<br>        return false;<br>    }<br>}</p>
<pre><code class="highlight plain">
&#96;BeanUtils.isSimpleProperty(parameter.getParameterType()&#96;方法确认了&#96;MethodParameter&#96;不是简单属性，英文解释如下

Check if the given type represents a &quot;simple&quot; value type:a primitive, a String or other CharSequence, a Number, a Date,a URI, a URL, a Locale or a Class.

然后使用&#96;argumentResolver&#96;处理&#96;MethodParameter&#96;</code></pre>
<p>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>String name = ModelFactory.getNameForParameter(parameter);
Object attribute = (mavContainer.containsAttribute(name) ?
        mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
if (binder.getTarget() != null) {
    bindRequestParameters(binder, webRequest);
    validateIfApplicable(binder, parameter);
    if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
        throw new BindException(binder.getBindingResult());
    }
}

// Add resolved attribute and BindingResult at the end of the model
Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
mavContainer.removeAttributes(bindingResultModel);
mavContainer.addAllAttributes(bindingResultModel);

return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;getNameForParameter(parameter)&#96;决定了变量的名字，如果变量被&#96;@ModelAttribute&#96;注解修饰，则&#96;name&#96;取此&#96;value&#96;属性，当变量为&#96;Array&#96;或者&#96;Collection&#96;或者普通&#96;Class&#96;，则取成员变量或者全限定名最后一个.之后的字符作为&#96;name&#96;

接着如果&#96;mavContainer&#96;中存在&#96;key&#96;为&#96;name&#96;，则取出对应的值，否则&#96;createAttribute&#96;方法获取&#96;MethodParameter&#96;的&#96;Class&#96;来创建新对象

接着&#96;binderFactory.createBinder&#96;创建一个数据绑定器</code></pre>
<p>@Override<br>public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)<br>        throws Exception {<br>    WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);<br>    if (this.initializer != null) {<br>        this.initializer.initBinder(dataBinder, webRequest);<br>    }<br>    initBinder(dataBinder, webRequest);<br>    return dataBinder;<br>}</p>
<pre><code class="highlight plain">
创建&#96;binderFactory&#96;的时候，&#96;RequestMappingHandlerAdapter&#96;给它注入了一个&#96;ConfigurableWebBindinginitializer&#96;类的变量，然后用它来初步初始化&#96;dataBinder&#96;，这个&#96;dataBinder&#96;的类型为&#96;ExtendedServletRequestDataBinder&#96;</code></pre>
<p>@Override<br>public void initBinder(WebDataBinder binder, WebRequest request) {<br>    binder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);<br>    if (this.directFieldAccess) {<br>        binder.initDirectFieldAccess();<br>    }<br>    if (this.messageCodesResolver != null) {<br>        binder.setMessageCodesResolver(this.messageCodesResolver);<br>    }<br>    if (this.bindingErrorProcessor != null) {<br>        binder.setBindingErrorProcessor(this.bindingErrorProcessor);<br>    }<br>    if (this.validator != null &amp;&amp; binder.getTarget() != null &amp;&amp;<br>            this.validator.supports(binder.getTarget().getClass())) {<br>        binder.setValidator(this.validator);<br>    }<br>    if (this.conversionService != null) {<br>        binder.setConversionService(this.conversionService);<br>    }<br>    if (this.propertyEditorRegistrars != null) {<br>        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {<br>            propertyEditorRegistrar.registerCustomEditors(binder);<br>        }<br>    }<br>}</p>
<pre><code class="highlight plain">
&#96;initializer&#96;中有个重要变量&#96;conversionService&#96;，属于接口&#96;ConversionService&#96;，它指向了一个&#96;DefaultFormattingConversionService&#96;类的实例，该实例也是由&#96;SpringMvc&#96;注入，存放&#96;SpringMvc&#96;自带的类型转换器converters

接着由&#96;binderFactory&#96;的&#96;init&#96;方法初始化&#96;dataBinder&#96;</code></pre>
<p>@Override<br>public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {<br>    for (InvocableHandlerMethod binderMethod : this.binderMethods) {<br>        if (isBinderMethodApplicable(binderMethod, binder)) {<br>            Object returnValue = binderMethod.invokeForRequest(request, null, binder);<br>            if (returnValue != null) {<br>                throw new IllegalStateException(“@InitBinder methods should return void: “ + binderMethod);<br>            }<br>        }<br>    }<br>}</p>
<pre><code class="highlight plain">
这里真正调用我们使用&#96;@InitBinder&#96;注解的方法，同样的&#96;invokeForRequest&#96;方法，这里传入的&#96;binder&#96;，会作为调用该方法的参数</code></pre>
<p>@InitBinder<br>public void initBinder(WebDataBinder binder) {<br>    SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);<br>    sdf.setLenient(false);<br>    binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));<br>}</p>
<pre><code class="highlight plain">
所以我们&#96;@InitBinder&#96;的方法，其实就是在初始化&#96;SpringMvc&#96;为每个请求创建的&#96;dataBinder&#96;

我们这里使用了&#96;registerCustomEditor&#96;注册了它&#96;SpringMvc&#96;中已经定义好的&#96;PropertyEditor&#96;，用来将字符串转化为&#96;java.util.Date&#96;，它继承了&#96;PropertyEditorSupport&#96;，如果要使用我们自定义的&#96;PropertyEditor&#96;，也是如此，覆写&#96;getAsText&#96;和&#96;setAsText&#96;方法，然后注册</code></pre>
<p>@Override<br>public String getAsText() {<br>    Date value = (Date) getValue();<br>    return (value != null ? this.dateFormat.format(value) : “”);<br>}</p>
<p>@Override<br>public void setAsText(String text) throws IllegalArgumentException {<br>    if (this.allowEmpty &amp;&amp; !StringUtils.hasText(text)) {<br>        // Treat empty String as null value.<br>        setValue(null);<br>    }<br>    //exactDateLength可以指定需要转化成Date类型的字符串长度<br>    else if (text != null &amp;&amp; this.exactDateLength &gt;= 0 &amp;&amp; text.length() != this.exactDateLength) {<br>        throw new IllegalArgumentException(<br>                “Could not parse date: it is not exactly” + this.exactDateLength + “characters long”);<br>    }<br>    else {<br>        try {<br>            //使用我们注入的DateFormat将字符串转化成Date<br>            setValue(this.dateFormat.parse(text));<br>        }<br>        catch (ParseException ex) {<br>            throw new IllegalArgumentException(“Could not parse date: “ + ex.getMessage(), ex);<br>        }<br>    }<br>}</p>
<pre><code class="highlight plain">
我们看是怎么用&#96;dataBinder&#96;注册的</code></pre>
<p>@Override<br>public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {<br>    getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);<br>}</p>
<pre><code class="highlight plain">
获取&#96;PropertyEditorRegistry&#96;</code></pre>
<p>protected PropertyEditorRegistry getPropertyEditorRegistry() {<br>    if (getTarget() != null) {<br>        return getInternalBindingResult().getPropertyAccessor();<br>    }<br>    else {<br>        return getSimpleTypeConverter();<br>    }<br>}</p>
<p>protected AbstractPropertyBindingResult getInternalBindingResult() {<br>    if (this.bindingResult == null) {<br>        initBeanPropertyAccess();<br>    }<br>    return this.bindingResult;<br>}</p>
<p>public void initBeanPropertyAccess() {<br>    Assert.state(this.bindingResult == null,<br>            “DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods”);<br>    this.bindingResult = new BeanPropertyBindingResult(<br>            getTarget(), getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());<br>    if (this.conversionService != null) {<br>        this.bindingResult.initConversion(this.conversionService);<br>    }<br>}</p>
<pre><code class="highlight plain">
这里创建了一个&#96;BeanPropertyBindingResult&#96;类的实例，将&#96;dataBinder&#96;中的&#96;target&#96;和&#96;objectName&#96;传入，让&#96;dataBinder&#96;的&#96;bindingResult&#96;指向它，然后返回这个对象

然后调用这个实例的&#96;getPropertyAccessor&#96;方法，获取属性存取器</code></pre>
<p>@Override<br>public final ConfigurablePropertyAccessor getPropertyAccessor() {<br>    if (this.beanWrapper == null) {<br>        this.beanWrapper = createBeanWrapper();<br>        this.beanWrapper.setExtractOldValueForEditor(true);<br>        this.beanWrapper.setAutoGrowNestedPaths(this.autoGrowNestedPaths);<br>        this.beanWrapper.setAutoGrowCollectionLimit(this.autoGrowCollectionLimit);<br>    }<br>    return this.beanWrapper;<br>}</p>
<p>protected BeanWrapper createBeanWrapper() {<br>    Assert.state(this.target != null, “Cannot access properties on null bean instance ‘“ + getObjectName() + “‘!”);<br>    return PropertyAccessorFactory.forBeanPropertyAccess(this.target);<br>}</p>
<p>public static BeanWrapper forBeanPropertyAccess(Object target) {<br>    return new BeanWrapperImpl(target);<br>}</p>
<pre><code class="highlight plain">
最后返回的是一个&#96;BeanWrapperImpl&#96;类的实例，并且让&#96;BeanPropertyBindingResult&#96;的&#96;beanWrapper&#96;指向它，这个类继承了&#96;AbstractPropertyAccessor&#96;和&#96;PropertyEditorRegistrySupport&#96;

然后开始注册&#96;PropertyEditor&#96;，也就是执行我们自定义的&#96;@InitBinder&#96;注解的方法</code></pre>
<p>@Override<br>public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {<br>    registerCustomEditor(requiredType, null, propertyEditor);<br>}</p>
<p>@Override<br>public void registerCustomEditor(Class<?> requiredType, String propertyPath, PropertyEditor propertyEditor) {
    if (requiredType == null && propertyPath == null) {
        throw new IllegalArgumentException("Either requiredType or propertyPath is required");
    }
    if (propertyPath != null) {
        if (this.customEditorsForPath == null) {
            this.customEditorsForPath = new LinkedHashMap<String, CustomEditorHolder>(16);
        }
        this.customEditorsForPath.put(propertyPath, new CustomEditorHolder(propertyEditor, requiredType));
    }
    else {
        if (this.customEditors == null) {
            this.customEditors = new LinkedHashMap<Class<?>, PropertyEditor&gt;(16);<br>        }<br>        this.customEditors.put(requiredType, propertyEditor);<br>        this.customEditorCache = null;<br>    }<br>}</p>
<pre><code class="highlight plain">
然后将&#96;PropertyEditor&#96;放入&#96;customEditors&#96;，此时，&#96;@InitBinder&#96;注解的方法执行完毕</code></pre>
<p>@Override<br>public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {<br>    for (InvocableHandlerMethod binderMethod : this.binderMethods) {<br>        if (isBinderMethodApplicable(binderMethod, binder)) {<br>            Object returnValue = binderMethod.invokeForRequest(request, null, binder);<br>            if (returnValue != null) {<br>                throw new IllegalStateException(“@InitBinder methods should return void: “ + binderMethod);<br>            }<br>        }<br>    }<br>}</p>
<pre><code class="highlight plain">
这里可以看到&#96;@InitBinder&#96;注解的方法不能有返回值</code></pre>
<p>@Override<br>public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)<br>        throws Exception {<br>    WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);<br>    if (this.initializer != null) {<br>        this.initializer.initBinder(dataBinder, webRequest);<br>    }<br>    initBinder(dataBinder, webRequest);<br>    return dataBinder;<br>}</p>
<p>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>String name = ModelFactory.getNameForParameter(parameter);
Object attribute = (mavContainer.containsAttribute(name) ?
        mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
if (binder.getTarget() != null) {
    bindRequestParameters(binder, webRequest);
    validateIfApplicable(binder, parameter);
    if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
        throw new BindException(binder.getBindingResult());
    }
}</code></pre><pre><code class="highlight plain">
初始化完&#96;dataBinder&#96;之后，开始绑定请求数据&#96;bindRequestParameters(binder, webRequest)&#96;</code></pre>
<pre><code>protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
    ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
    ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
    servletBinder.bind(servletRequest);
}</code></pre><pre><code class="highlight plain">
&#96;RequestFacade&#96;在前面被封装成&#96;ServletWebRequest&#96;，这里又解包装
然后将&#96;binder&#96;从&#96;ExtendedServletRequestDataBinder&#96;向上转型为&#96;ServletRequestDataBinder&#96;</code></pre>
<p>public void bind(ServletRequest request) {<br>    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);<br>    MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);<br>    if (multipartRequest != null) {<br>        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);<br>    }<br>    addBindValues(mpvs, request);<br>    doBind(mpvs);<br>}</p>
<pre><code class="highlight plain">
看mpvs是什么</code></pre>
<p>public ServletRequestParameterPropertyValues(ServletRequest request) {<br>    this(request, null, null);<br>}</p>
<p>public ServletRequestParameterPropertyValues(ServletRequest request, String prefix, String prefixSeparator) {<br>    super(WebUtils.getParametersStartingWith(<br>            request, (prefix != null ? prefix + prefixSeparator : null)));<br>}</p>
<p>public static Map&lt;String, Object&gt; getParametersStartingWith(ServletRequest request, String prefix) {<br>    Assert.notNull(request, “Request must not be null”);<br>    Enumeration<String> paramNames = request.getParameterNames();<br>    Map&lt;String, Object&gt; params = new TreeMap&lt;String, Object&gt;();<br>    if (prefix == null) {<br>        prefix = “”;<br>    }<br>    while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {<br>        String paramName = paramNames.nextElement();<br>        if (“”.equals(prefix) || paramName.startsWith(prefix)) {<br>            String unprefixed = paramName.substring(prefix.length());<br>            String[] values = request.getParameterValues(paramName);<br>            if (values == null || values.length == 0) {<br>                // Do nothing, no values found at all.<br>            }<br>            else if (values.length &gt; 1) {<br>                params.put(unprefixed, values);<br>            }<br>            else {<br>                params.put(unprefixed, values[0]);<br>            }<br>        }<br>    }<br>    return params;<br>}</p>
<pre><code class="highlight plain">
这里&#96;request.getParameterNames()&#96;获取请求中传来的参数的名字的枚举集合，然后&#96;request.getParameterValues(paramName)&#96;获取请求中参数的值

继续构造方法</code></pre>
<p>public MutablePropertyValues(Map<?, ?> original) {<br>    // We can optimize this because it’s all new:<br>    // There is no replacement of existing property values.<br>    if (original != null) {<br>        this.propertyValueList = new ArrayList<PropertyValue>(original.size());<br>        for (Map.Entry<?, ?> entry : original.entrySet()) {<br>            this.propertyValueList.add(new PropertyValue(entry.getKey().toString(), entry.getValue()));<br>        }<br>    }<br>    else {<br>        this.propertyValueList = new ArrayList<PropertyValue>(0);<br>    }<br>}</p>
<pre><code class="highlight plain">
&#96;original&#96;存放了请求中参数的名和值，将其从&#96;Map&#96;类型转换到&#96;PropertyValue&#96;的数组队列</code></pre>
<p>public void bind(ServletRequest request) {<br>    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);<br>    MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);<br>    if (multipartRequest != null) {<br>        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);<br>    }<br>    addBindValues(mpvs, request);<br>    doBind(mpvs);<br>}</p>
<pre><code class="highlight plain">
&#96;addBindValues(mpvc,request)&#96;将&#96;pathVariable&#96;变量添加入&#96;mpvs&#96;中，&#96;key&#96;重复时跳过

然后&#96;doBind(mpvs)&#96;把&#96;mvps&#96;中的参数绑定到&#96;dataBinder&#96;的&#96;target&#96;中，也就是目标&#96;handlerMethod&#96;方法得参数中，中间利用到的转换器有默认的&#96;ConversionService&#96;中注入的转换器，例如&#96;java.lang.String&#96;转换到&#96;java.lang.Integer&#96;的转换器&#96;StringToNumber&#96;</code></pre>
<p>final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; {</p>
<pre><code>@Override
public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
    return new StringToNumber&lt;T&gt;(targetType);
}

private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; {

    private final Class&lt;T&gt; targetType;

    public StringToNumber(Class&lt;T&gt; targetType) {
        this.targetType = targetType;
    }

    @Override
    public T convert(String source) {
        if (source.length() == 0) {
            return null;
        }
        return NumberUtils.parseNumber(source, this.targetType);
    }
}</code></pre><p>}</p>
<pre><code class="highlight plain">
回到&#96;ServletModelAttributeMethodProcessor&#96;的&#96;resolveArgument&#96;</code></pre>
<p>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>String name = ModelFactory.getNameForParameter(parameter);
Object attribute = (mavContainer.containsAttribute(name) ?
        mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
if (binder.getTarget() != null) {
    bindRequestParameters(binder, webRequest);
    validateIfApplicable(binder, parameter);
    if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
        throw new BindException(binder.getBindingResult());
    }
}

// Add resolved attribute and BindingResult at the end of the model
Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
mavContainer.removeAttributes(bindingResultModel);
mavContainer.addAllAttributes(bindingResultModel);

return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;validateIfApplicable(binder,webRequest)&#96;这句的作用在&#96;@validated&#96;注解的使用，对&#96;POJO&#96;类的属性进行jrs303验证

最后将&#96;dataBinder&#96;中的&#96;BeanPropertyBindingResult&#96;的已经和请求中的参数做了数据绑定之后的&#96;target&#96;和处理&#96;@validated&#96;注解之后的&#96;BeanPropertyBindingResult&#96;也就是它自身绑定到&#96;mavContainer&#96;的&#96;Model&#96;中

回到最初执行控制器&#96;Controller&#96;的&#96;ServletInvocableHandlerMethod&#96;</code></pre>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) {
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
}
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
}
return returnValue;</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;getMethodArgumentValues&#96;方法中，&#96;argumentResolver&#96;对形参&#96;methodParameter&#96;解析之后，获取到要执行的方法的参数的具体的值

然后利用反射执行方法，然后返回返回值</code></pre>
<p>public void invokeAndHandle(ServletWebRequest webRequest,<br>        ModelAndViewContainer mavContainer, Object… providedArgs) throws Exception {</p>
<pre><code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
setResponseStatus(webRequest);

if (returnValue == null) {
    if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
        mavContainer.setRequestHandled(true);
        return;
    }
}
else if (StringUtils.hasText(this.responseReason)) {
    mavContainer.setRequestHandled(true);
    return;
}

mavContainer.setRequestHandled(false);
try {
    this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
}
catch (Exception ex) {
    if (logger.isTraceEnabled()) {
        logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
    }
    throw ex;
}</code></pre><p>}</p>
<pre><code class="highlight plain">
&#96;Controller&#96;中方法返回值一般就是&#96;view&#96;了

&#96;RequestMappingHandlerAdapter&#96;在将&#96;Controller&#96;中目标方法包装成&#96;ServletInvocableHandlerMethod&#96;时注入了&#96;HandlerMethodReturnValueHandlerComposite&#96;的实例，其中包含了许多处理返回值的&#96;HandlerMethodReturnValueHandler&#96;


其中这里处理&#96;view&#96;视图的是&#96;ViewNameMethodReturnValueHandler&#96;</code></pre>
<p>@Override<br>public void handleReturnValue(Object returnValue, MethodParameter returnType,<br>        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {</p>
<pre><code>if (returnValue == null) {
    return;
}
else if (returnValue instanceof String) {
    String viewName = (String) returnValue;
    mavContainer.setViewName(viewName);
    if (isRedirectViewName(viewName)) {
        mavContainer.setRedirectModelScenario(true);
    }
}
else {
    // should not happen
    throw new UnsupportedOperationException(&quot;Unexpected return type: &quot; +
            returnType.getParameterType().getName() + &quot; in method: &quot; + returnType.getMethod());
}</code></pre><p>}</p>
<pre><code class="highlight plain">


返回值为&#96;String&#96;类型的时候，将它作为&#96;viewName&#96;放入&#96;mavContainer&#96;，然后判断&#96;viewName&#96;中是否以&#96;redirect:&#96;开头的设置&#96;redirectModelScenario&#96;属性

此时，&#96;RequestMappingHandlerAdapter&#96;的&#96;InvokeHandleMethod&#96;，也就是&#96;handler&#96;方法执行的入口就只剩下最后一步</code></pre>
<p>return getModelAndView(mavContainer, modelFactory, webRequest);</p>
<p>private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,<br>        ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {</p>
<pre><code>modelFactory.updateModel(webRequest, mavContainer);
if (mavContainer.isRequestHandled()) {
    return null;
}
ModelMap model = mavContainer.getModel();
ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model);
if (!mavContainer.isViewReference()) {
    mav.setView((View) mavContainer.getView());
}
if (model instanceof RedirectAttributes) {
    Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
    HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
    RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
}
return mav;</code></pre><p>}</p>
<p>```</p>
<p>前面看到返回值为空时，设置<code>requestHandled</code>为<code>true</code>，使用<code>mavContainer</code>中的<code>Model</code>和<code>viewName</code>创建一个<code>ModelAndView</code>返回，接下来就是对视图进行处理</p>
<h3 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h3><ol>
<li><p>创建<code>WebDataBinderFactory</code>，用来处理请求中属性绑定到形参</p>
</li>
<li><p>创建<code>ModelFactory</code>，处理<code>@ModelAttribute</code>方法</p>
</li>
<li><p>创建<code>ModelAndViewContainer</code>，用来作为<code>Model</code>和<code>View</code>的容器</p>
</li>
<li><p>执行<code>@ModelAttribute</code>方法，在这之前先将<code>@SessionAttributes</code>注解的属性从<code>Session</code>中取出放入<code>mavContainer</code>的<code>Model</code>中</p>
</li>
<li><p>执行<code>Controller</code>目标方法，主要通过获取方法的形参，然后根据形参选择适用的<code>HandlerMethodArgumentResolver</code>对形参进行解析处理，并且在其中使用<code>WebDataBinderFactory</code>创建<code>DataBinder</code>将请求中附带的属性绑定到形参中，然后利用反射的方式来执行方法</p>
</li>
<li><p>获取到方法的返回值过后，利用合适的<code>HandlerMethodReturnValueHandler</code>对返回值也就是<code>view</code>进行处理，然后放入<code>mavContainer</code></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/ReentrantReadWriteLock%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E4%BA%AB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/ReentrantReadWriteLock%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E4%BA%AB%E9%94%81/" itemprop="url">ReentrantReadWriteLock的共享锁和独享锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="共享锁和独享锁操作state"><a href="#共享锁和独享锁操作state" class="headerlink" title="共享锁和独享锁操作state"></a>共享锁和独享锁操作state</h3><p>ReentrantReadWriteLock中共享锁和独享锁对锁的操作还是共同操作一个变量<code>state</code>，那怎么区分这个<code>state</code>是共享锁取得锁还是独享锁取得锁呢</p>
<p>从ReentrantReadWriteLock的源码我们来看</p>
<pre><code class="highlight plain">static final int SHARED_SHIFT   &#x3D; 16

static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1

&#x2F;** Returns the number of shared holds represented in count  *&#x2F;
static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;
&#x2F;** Returns the number of exclusive holds represented in count  *&#x2F;
static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</code></pre>

<p>下面两个方法传入<code>state</code>，返回共享锁取得锁次数和独享锁取得锁次数</p>
<p>其中获取共享锁次数的方式为将<code>state</code>无符号右移16位</p>
<p>获取独享锁次数的方式为将<code>state</code>与<code>EXCLUSIVE_MASK</code>进行并运算，<code>EXCLUSIVE_MASK</code>为32位int型，前16位为0，后16位为1</p>
<p>所以<code>state</code>区分独享锁和共享锁次数的方法为，将<code>state</code>32位一分为二，前16位用来表示共享锁获取次数，后16位用来表示独享锁获取次数</p>
<h3 id="共享锁和独享锁在获取锁时的区别"><a href="#共享锁和独享锁在获取锁时的区别" class="headerlink" title="共享锁和独享锁在获取锁时的区别"></a>共享锁和独享锁在获取锁时的区别</h3><p>读锁用的就是共享锁，我们知道多个线程是可以同时获取读锁的</p>
<p>读锁获取锁的源码如下</p>
<pre><code class="highlight plain">public final void acquireShared(int arg) &#123;
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
&#125;</code></pre>

<p>而写锁获取锁的源码如下</p>
<pre><code class="highlight plain">public final void acquire(int arg) &#123;
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
&#125;</code></pre>

<p>都是一样的先尝试获取锁，失败之后放入<code>waitingqueue</code>等待唤醒</p>
<p>我们看获取锁有什么区别，下面是获取独享锁</p>
<pre><code class="highlight plain">protected final boolean tryAcquire(int acquires) &#123;
    &#x2F;*
     * Walkthrough:
     * 1. If read count nonzero or write count nonzero
     *    and owner is a different thread, fail.
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     *&#x2F;
    Thread current &#x3D; Thread.currentThread();
    int c &#x3D; getState();
    int w &#x3D; exclusiveCount(c);
    if (c !&#x3D; 0) &#123;
        &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)
        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        &#x2F;&#x2F; Reentrant acquire
        setState(c + acquires);
        return true;
    &#125;
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
&#125;</code></pre>

<p>当c!=0且w==0时，说明存在线程获取了读锁，没有线程获取了写锁，此时想要获取写锁，则需要进入waitingqueue排队</p>
<p>当c==0时，即没有线程获取写锁和读锁，线程直接获取写锁</p>
<p>读锁想重入写锁需要进入waitingqueue</p>
<p>下面是获取共享锁</p>
<pre><code class="highlight plain">protected final int tryAcquireShared(int unused) &#123;
    &#x2F;*
     * Walkthrough:
     * 1. If write lock held by another thread, fail.
     * 2. Otherwise, this thread is eligible for
     *    lock wrt state, so ask if it should block
     *    because of queue policy. If not, try
     *    to grant by CASing state and updating count.
     *    Note that step does not check for reentrant
     *    acquires, which is postponed to full version
     *    to avoid having to check hold count in
     *    the more typical non-reentrant case.
     * 3. If step 2 fails either because thread
     *    apparently not eligible or CAS fails or count
     *    saturated, chain to version with full retry loop.
     *&#x2F;
    Thread current &#x3D; Thread.currentThread();
    int c &#x3D; getState();
    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;
        getExclusiveOwnerThread() !&#x3D; current)
        return -1;
    int r &#x3D; sharedCount(c);
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) &#123;
        if (r &#x3D;&#x3D; 0) &#123;
            firstReader &#x3D; current;
            firstReaderHoldCount &#x3D; 1;
        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;
            firstReaderHoldCount++;
        &#125; else &#123;
            HoldCounter rh &#x3D; cachedHoldCounter;
            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))
                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();
            else if (rh.count &#x3D;&#x3D; 0)
                readHolds.set(rh);
            rh.count++;
        &#125;
        return 1;
    &#125;
    return fullTryAcquireShared(current);
&#125;</code></pre>
<p>共享锁对应的也先获取独享锁获取次数，如果已经有获取独享锁的线程了，那就进waitingqueue</p>
<p>如果此时没有线程获取独享锁，且waitingqueue中也没有exclusive模式的Node在排队，直接获取读锁，并且因为不像独享锁，它的特性exclusive使得它可以用<code>state</code>来记录重入的次数，而共享锁可以多个线程同时获取锁，所以这里用了<code>ThreadLocal</code>在线程中存放每个读锁重入的次数</p>
<p>如果是写锁要重入读锁，可以直接获取读锁</p>
<p><strong>根据以上特性我们可以初步总结到，当没有线程获取到写锁时，多个线程都可以获取到读锁，并且不需要进入waitingqueue，但是当有线程尝试获取写锁时，由于已经有线程获取了读锁，所以它要进入waitingqueue，此时后续想要获取读锁的线程也只能进入waitingqueue</strong></p>
<h3 id="共享锁和独享锁唤醒successor的区别"><a href="#共享锁和独享锁唤醒successor的区别" class="headerlink" title="共享锁和独享锁唤醒successor的区别"></a>共享锁和独享锁唤醒successor的区别</h3><h4 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h4><p>我们知道，独享锁只有在<code>unlock()</code>的时候才会唤醒下个被挂起的线程，而waitingqueue中共享锁模式的Node总共有两次换新下个被挂起的线程，一次在被唤醒获取到锁之后，一次是在<code>unlock()</code></p>
<pre><code class="highlight plain">private void setHeadAndPropagate(Node node, int propagate) &#123;
    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below
    setHead(node);
    &#x2F;*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don&#39;t know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires&#x2F;releases, so most need signals now or soon
     * anyway.
     *&#x2F;
    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||
        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;
        Node s &#x3D; node.next;
        if (s &#x3D;&#x3D; null || s.isShared())
            doReleaseShared();
    &#125;
&#125;</code></pre>

<p>当Node中线程获取到锁之后，会将自己设置为头节点Head，但是共享锁比起独享锁在这一步多了操作</p>
<pre><code class="highlight plain">private void setHeadAndPropagate(Node node, int propagate) &#123;
    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below
    setHead(node);
    &#x2F;*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don&#39;t know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires&#x2F;releases, so most need signals now or soon
     * anyway.
     *&#x2F;
    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||
        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;
        Node s &#x3D; node.next;
        if (s &#x3D;&#x3D; null || s.isShared())
            doReleaseShared();
    &#125;
&#125;</code></pre>

<p>可以看到最后调用了<code>doReleaseShared()</code>方法，唤醒下一个节点如果这个节点模式也为<code>Shared</code></p>
<p>而在<code>unlock()</code>中</p>
<pre><code class="highlight plain">public final boolean releaseShared(int arg) &#123;
    if (tryReleaseShared(arg)) &#123;
        doReleaseShared();
        return true;
    &#125;
    return false;
&#125;</code></pre>

<p>也调用了<code>doReleaseShared()</code>方法唤醒下一个节点</p>
<pre><code class="highlight plain">private void doReleaseShared() &#123;
    &#x2F;*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires&#x2F;releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     *&#x2F;
    for (;;) &#123;
        Node h &#x3D; head;
        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;
            int ws &#x3D; h.waitStatus;
            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            &#x2F;&#x2F; loop to recheck cases
                unparkSuccessor(h);
            &#125;
            else if (ws &#x3D;&#x3D; 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                &#x2F;&#x2F; loop on failed CAS
        &#125;
        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed
            break;
    &#125;
&#125;</code></pre>

<p>这就是唤醒下一个节点的源码，是一个for循环，只有<code>h==head</code>才能跳出循环</p>
<p>共享锁多出的这一步获取锁之后唤醒下一个模式为<code>shared</code>的节点的线程，目的应该是将多个连续的<code>shared</code>节点的线程都唤醒</p>
<p>但是在这一步可能会出现的问题是，如果唤醒下一个<code>shared</code>，在它获取锁将自己设置为Head之前，此时来到<code>h==head</code>，则循环结束，正好是一个链式唤醒<br>如果在下一个<code>shared</code>获取锁将自己设置为Head之后，此时h!=head，这样会造成什么后果，多个线程在执行自己代码之前，循环唤醒下个节点，这叫”调用风暴”，这极大地加速了唤醒后继节点的速度，提升了效率，同时该方法内部的CAS操作又保证了多个线程同时唤醒一个节点时，只有一个线程能操作成功。<br>直到下一个<code>exclusive</code>，因为有线程持有读锁，所以唤醒的线程获取不了写锁，唤醒终止，此时<code>head</code>不变，<code>h==head</code>恒成立，所有<code>doReleaseShared</code>循环结束，获取读锁的线程执行自己代码</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><p>两种锁在这一步相似</p>
<pre><code class="highlight plain">protected final boolean tryReleaseShared(int unused) &#123;
    Thread current &#x3D; Thread.currentThread();
    if (firstReader &#x3D;&#x3D; current) &#123;
        &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;
        if (firstReaderHoldCount &#x3D;&#x3D; 1)
            firstReader &#x3D; null;
        else
            firstReaderHoldCount--;
    &#125; else &#123;
        HoldCounter rh &#x3D; cachedHoldCounter;
        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))
            rh &#x3D; readHolds.get();
        int count &#x3D; rh.count;
        if (count &lt;&#x3D; 1) &#123;
            readHolds.remove();
            if (count &lt;&#x3D; 0)
                throw unmatchedUnlockException();
        &#125;
        --rh.count;
    &#125;
    for (;;) &#123;
        int c &#x3D; getState();
        int nextc &#x3D; c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            &#x2F;&#x2F; Releasing the read lock has no effect on readers,
            &#x2F;&#x2F; but it may allow waiting writers to proceed if
            &#x2F;&#x2F; both read and write locks are now free.
            return nextc &#x3D;&#x3D; 0;
    &#125;
&#125;</code></pre>

<p>最后这个for循环作用，只用当读锁全部释放完，且没有线程占有写锁的情况下，共享锁会唤醒下一个节点</p>
<p>为什么要强调没有线程占有写锁，我想可能是写锁重入读锁的问题，当写锁重入读锁，读锁<code>unlock()</code>的时候，也就是这一步，加这个条件，此时会尝试唤醒下一个线程，并且会改变<code>waitStatus</code>的状态为0(每次要唤醒下一个节点，都会把头节点<code>waitStatus</code>从<code>signal</code>变为0)，会导致什么后果呢</p>
<pre><code class="highlight plain">public final boolean release(int arg) &#123;
    if (tryRelease(arg)) &#123;
        Node h &#x3D; head;
        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)
            unparkSuccessor(h);
        return true;
    &#125;
    return false;
&#125;</code></pre>

<p><code>waitStatus</code>变为0，这里无法唤醒下一个waitingqueue节点的线程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMVC%E4%B8%ADdataBinder%E5%85%A5%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMVC%E4%B8%ADdataBinder%E5%85%A5%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" itemprop="url">SpringMVC中DataBinder对入参类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="DataBinder"><a href="#DataBinder" class="headerlink" title="DataBinder"></a>DataBinder</h3><p><code>DataBinder</code>在<code>SpringMVC</code>中起的作用主要是为<code>Request</code>中参数转化为对应的入参类型</p>
<h3 id="注册自己的PropertyEditor"><a href="#注册自己的PropertyEditor" class="headerlink" title="注册自己的PropertyEditor"></a>注册自己的PropertyEditor</h3><p>由于<code>DataBinder</code>实现了<code>PropertyEditorRegistry</code>接口，所以有了注册属性编辑器的方法，我们可以手动添加我们需要的<code>PropertyEditor</code>，如下</p>
<pre><code class="highlight plain">@InitBinder
public void initBinder(WebDataBinder binder) &#123;
	SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
	sdf.setLenient(false);
	binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));
&#125;</code></pre>

<p>这个方法会被收录在<code>WebDataBinderFactory</code>中，然后在创建和初始化<code>DataBinder</code>对象时，将<code>DataBinder</code>作为入参调用这个方法来注入<code>PropertyEditor</code></p>
<h3 id="conversionservice"><a href="#conversionservice" class="headerlink" title="conversionservice"></a>conversionservice</h3><pre><code class="highlight plain">&lt;mvc:annotation-driven &#x2F;&gt;</code></pre>

<p>这个配置默认注册了<code>FormattingConversionServiceFactoryBean</code>来创将一个<code>DefaultFormattingConversionService</code>，其中注册了许多<code>converter</code>用来进行类型转换</p>
<h3 id="转化过程"><a href="#转化过程" class="headerlink" title="转化过程"></a>转化过程</h3><p>既然是将参数转化为入参需要的类型，那应该发生在参数解析的时候，先看简单的例如<code>int</code>类型的转化</p>
<p>解析它的参数解析器为<code>RequestParamMethodArgumentResolver</code></p>
<pre><code class="highlight plain">@Override
public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
		NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;
	&#x2F;&#x2F;获取这个入参的参数类型
	Class&lt;?&gt; paramType &#x3D; parameter.getParameterType();
	&#x2F;&#x2F;获取@RequestParam的值
	NamedValueInfo namedValueInfo &#x3D; getNamedValueInfo(parameter);
	&#x2F;&#x2F;根据@RequestParam从request获取该参数的值
	Object arg &#x3D; resolveName(namedValueInfo.name, parameter, webRequest);
	if (arg &#x3D;&#x3D; null) &#123;
		if (namedValueInfo.defaultValue !&#x3D; null) &#123;
			arg &#x3D; resolveDefaultValue(namedValueInfo.defaultValue);
		&#125;
		else if (namedValueInfo.required &amp;&amp; !parameter.getParameterType().getName().equals(&quot;java.util.Optional&quot;)) &#123;
			handleMissingValue(namedValueInfo.name, parameter);
		&#125;
		arg &#x3D; handleNullValue(namedValueInfo.name, arg, paramType);
	&#125;
	else if (&quot;&quot;.equals(arg) &amp;&amp; namedValueInfo.defaultValue !&#x3D; null) &#123;
		arg &#x3D; resolveDefaultValue(namedValueInfo.defaultValue);
	&#125;

	if (binderFactory !&#x3D; null) &#123;
		&#x2F;&#x2F;创建DataBinder
		WebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, null, namedValueInfo.name);
		&#x2F;&#x2F;将从Request中获取的参数值转化为入参需要的类型paramType
		arg &#x3D; binder.convertIfNecessary(arg, paramType, parameter);
	&#125;

	handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);

	return arg;
&#125;</code></pre>

<p>转化过程发生在<code>arg = binder.convertIfNecessary(arg, paramType, parameter);</code></p>
<p>先看<code>DataBinder</code>初始化</p>
<pre><code class="highlight plain">@Override
public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)
		throws Exception &#123;
	WebDataBinder dataBinder &#x3D; createBinderInstance(target, objectName, webRequest);
	if (this.initializer !&#x3D; null) &#123;
		&#x2F;&#x2F;target为null的话，只将conversionservice注入到DataBinder
		&#x2F;&#x2F;否则也一并注入到DataBinder内部变量BindingResult和它的
		&#x2F;&#x2F;内部变量BeanWrapperImpl中
		this.initializer.initBinder(dataBinder, webRequest);
	&#125;
	&#x2F;&#x2F;调用@InitBinder方法
	initBinder(dataBinder, webRequest);
	return dataBinder;
&#125;

&#x2F;&#x2F;调用的构造函数
public DataBinder(Object target, String objectName) &#123;
	if (target !&#x3D; null &amp;&amp; target.getClass().equals(javaUtilOptionalClass)) &#123;
		this.target &#x3D; OptionalUnwrapper.unwrap(target);
	&#125;
	else &#123;
		this.target &#x3D; target;
	&#125;
	this.objectName &#x3D; objectName;
&#125;</code></pre>

<p>在这里<code>target</code>为<code>null</code></p>
<pre><code class="highlight plain">@Override
public &lt;T&gt; T convertIfNecessary(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)
		throws TypeMismatchException &#123;

	return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
&#125;</code></pre>

<p><code>getTypeConverter()</code>获取转换器</p>
<pre><code class="highlight plain">protected TypeConverter getTypeConverter() &#123;
	if (getTarget() !&#x3D; null) &#123;
		return getInternalBindingResult().getPropertyAccessor();
	&#125;
	else &#123;
		return getSimpleTypeConverter();
	&#125;
&#125;</code></pre>

<p>因为<code>target</code>为<code>null</code>，使用简单转换器</p>
<pre><code class="highlight plain">protected SimpleTypeConverter getSimpleTypeConverter() &#123;
	if (this.typeConverter &#x3D;&#x3D; null) &#123;
		&#x2F;&#x2F;创建typeConverter
		this.typeConverter &#x3D; new SimpleTypeConverter();
		if (this.conversionService !&#x3D; null) &#123;
			&#x2F;&#x2F;注入conversionservice
			this.typeConverter.setConversionService(this.conversionService);
		&#125;
	&#125;
	return this.typeConverter;
&#125;

&#x2F;&#x2F;构造函数
public SimpleTypeConverter() &#123;
	this.typeConverterDelegate &#x3D; new TypeConverterDelegate(this);
	&#x2F;&#x2F;注册默认PropertyEditor
	registerDefaultEditors();
&#125;</code></pre>

<p>使用简单转换器进行类型转化</p>
<pre><code class="highlight plain">@Override
public &lt;T&gt; T convertIfNecessary(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)
		throws TypeMismatchException &#123;

	return doConvert(value, requiredType, methodParam, null);
&#125;



private &lt;T&gt; T doConvert(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam, Field field)
		throws TypeMismatchException &#123;
	try &#123;
		if (field !&#x3D; null) &#123;
			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, field);
		&#125;
		else &#123;
			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, methodParam);
		&#125;
	&#125;
	catch (ConverterNotFoundException ex) &#123;
		throw new ConversionNotSupportedException(value, requiredType, ex);
	&#125;
	catch (ConversionException ex) &#123;
		throw new TypeMismatchException(value, requiredType, ex);
	&#125;
	catch (IllegalStateException ex) &#123;
		throw new ConversionNotSupportedException(value, requiredType, ex);
	&#125;
	catch (IllegalArgumentException ex) &#123;
		throw new TypeMismatchException(value, requiredType, ex);
	&#125;
&#125;</code></pre>

<p>调用<code>simpleTypeConverter</code>的成员变量<code>typeConverterDelegate</code>转换</p>
<pre><code class="highlight plain">public &lt;T&gt; T convertIfNecessary(Object newValue, Class&lt;T&gt; requiredType, MethodParameter methodParam)
		throws IllegalArgumentException &#123;

	return convertIfNecessary(null, null, newValue, requiredType,
			(methodParam !&#x3D; null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)));
&#125;</code></pre>

<p>然后到关键代码，这里的<code>propertyEditorRegistry</code>指向的就是之前的<code>simpleTypeConverter</code></p>
<pre><code class="highlight plain">public &lt;T&gt; T convertIfNecessary(String propertyName, Object oldValue, Object newValue,
		Class&lt;T&gt; requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException &#123;

	Object convertedValue &#x3D; newValue;

	&#x2F;&#x2F; Custom editor for this type?
	&#x2F;&#x2F;查找我们通过@InitBinder注入的PropertyEditor适用吗
	PropertyEditor editor &#x3D; this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);

	ConversionFailedException firstAttemptEx &#x3D; null;
	
	&#x2F;&#x2F; No custom editor but custom ConversionService specified?
	&#x2F;&#x2F;找不到则从conversionService中查找适用的&#96;Converter&#96;
	ConversionService conversionService &#x3D; this.propertyEditorRegistry.getConversionService();
	&#x2F;&#x2F;没有找到自定义的PropertyEditor时且conversionservice中有适用的converter
	&#x2F;&#x2F;使用它来进行类型转换
	if (editor &#x3D;&#x3D; null &amp;&amp; conversionService !&#x3D; null &amp;&amp; convertedValue !&#x3D; null &amp;&amp; typeDescriptor !&#x3D; null) &#123;
		TypeDescriptor sourceTypeDesc &#x3D; TypeDescriptor.forObject(newValue);
		TypeDescriptor targetTypeDesc &#x3D; typeDescriptor;
		if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) &#123;
			try &#123;
				return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);
			&#125;
			catch (ConversionFailedException ex) &#123;
				&#x2F;&#x2F; fallback to default conversion logic below
				firstAttemptEx &#x3D; ex;
			&#125;
		&#125;
	&#125;

	&#x2F;&#x2F; Value not of required type?
	&#x2F;&#x2F;自定义的PropertyEditor适用时或者值的类型不属于要转换的那个类型
	if (editor !&#x3D; null || (requiredType !&#x3D; null &amp;&amp; !ClassUtils.isAssignableValue(requiredType, convertedValue))) &#123;
		&#x2F;&#x2F;String转集合
		if (requiredType !&#x3D; null &amp;&amp; Collection.class.isAssignableFrom(requiredType) &amp;&amp; convertedValue instanceof String) &#123;
			TypeDescriptor elementType &#x3D; typeDescriptor.getElementTypeDescriptor();
			if (elementType !&#x3D; null &amp;&amp; Enum.class.isAssignableFrom(elementType.getType())) &#123;
				convertedValue &#x3D; StringUtils.commaDelimitedListToStringArray((String) convertedValue);
			&#125;
		&#125;
		&#x2F;&#x2F;自定义PropertyEditor和conversionservice中都没有适用的
		&#x2F;&#x2F;从默认注册的PropertyEditor中查找
		if (editor &#x3D;&#x3D; null) &#123;
			editor &#x3D; findDefaultEditor(requiredType);
		&#125;
		&#x2F;&#x2F;进行转换，如果要转换的值convertedValue不属于String，转换用的是setValue方法
		convertedValue &#x3D; doConvertValue(oldValue, convertedValue, requiredType, editor);
	&#125;
	
	&#x2F;&#x2F;以上对值的转换完成，由Object类型的convertedValue接收转换好的值
	boolean standardConversion &#x3D; false;
	
	&#x2F;&#x2F;以下应该是根据requiredType对转换好的值convertedValue进行再处理
	if (requiredType !&#x3D; null) &#123;
		&#x2F;&#x2F; Try to apply some standard type conversion rules if appropriate.

		if (convertedValue !&#x3D; null) &#123;
			if (Object.class.equals(requiredType)) &#123;
				return (T) convertedValue;
			&#125;
			else if (requiredType.isArray()) &#123;
				&#x2F;&#x2F; Array required -&gt; apply appropriate conversion of elements.
				if (convertedValue instanceof String &amp;&amp; Enum.class.isAssignableFrom(requiredType.getComponentType())) &#123;
					convertedValue &#x3D; StringUtils.commaDelimitedListToStringArray((String) convertedValue);
				&#125;
				return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());
			&#125;
			else if (convertedValue instanceof Collection) &#123;
				&#x2F;&#x2F; Convert elements to target type, if determined.
				convertedValue &#x3D; convertToTypedCollection(
						(Collection&lt;?&gt;) convertedValue, propertyName, requiredType, typeDescriptor);
				standardConversion &#x3D; true;
			&#125;
			else if (convertedValue instanceof Map) &#123;
				&#x2F;&#x2F; Convert keys and values to respective target type, if determined.
				convertedValue &#x3D; convertToTypedMap(
						(Map&lt;?, ?&gt;) convertedValue, propertyName, requiredType, typeDescriptor);
				standardConversion &#x3D; true;
			&#125;
			if (convertedValue.getClass().isArray() &amp;&amp; Array.getLength(convertedValue) &#x3D;&#x3D; 1) &#123;
				convertedValue &#x3D; Array.get(convertedValue, 0);
				standardConversion &#x3D; true;
			&#125;
			if (String.class.equals(requiredType) &amp;&amp; ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) &#123;
				&#x2F;&#x2F; We can stringify any primitive value...
				return (T) convertedValue.toString();
			&#125;
			else if (convertedValue instanceof String &amp;&amp; !requiredType.isInstance(convertedValue)) &#123;
				if (firstAttemptEx &#x3D;&#x3D; null &amp;&amp; !requiredType.isInterface() &amp;&amp; !requiredType.isEnum()) &#123;
					try &#123;
						Constructor&lt;T&gt; strCtor &#x3D; requiredType.getConstructor(String.class);
						return BeanUtils.instantiateClass(strCtor, convertedValue);
					&#125;
					catch (NoSuchMethodException ex) &#123;
						&#x2F;&#x2F; proceed with field lookup
						if (logger.isTraceEnabled()) &#123;
							logger.trace(&quot;No String constructor found on type [&quot; + requiredType.getName() + &quot;]&quot;, ex);
						&#125;
					&#125;
					catch (Exception ex) &#123;
						if (logger.isDebugEnabled()) &#123;
							logger.debug(&quot;Construction via String failed for type [&quot; + requiredType.getName() + &quot;]&quot;, ex);
						&#125;
					&#125;
				&#125;
				String trimmedValue &#x3D; ((String) convertedValue).trim();
				if (requiredType.isEnum() &amp;&amp; &quot;&quot;.equals(trimmedValue)) &#123;
					&#x2F;&#x2F; It&#39;s an empty enum identifier: reset the enum value to null.
					return null;
				&#125;
				convertedValue &#x3D; attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);
				standardConversion &#x3D; true;
			&#125;
		&#125;
		else &#123;
			&#x2F;&#x2F; convertedValue &#x3D;&#x3D; null
			if (javaUtilOptionalEmpty !&#x3D; null &amp;&amp; requiredType.equals(javaUtilOptionalEmpty.getClass())) &#123;
				convertedValue &#x3D; javaUtilOptionalEmpty;
			&#125;
		&#125;

		if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) &#123;
			if (firstAttemptEx !&#x3D; null) &#123;
				throw firstAttemptEx;
			&#125;
			&#x2F;&#x2F; Definitely doesn&#39;t match: throw IllegalArgumentException&#x2F;IllegalStateException
			StringBuilder msg &#x3D; new StringBuilder();
			msg.append(&quot;Cannot convert value of type [&quot;).append(ClassUtils.getDescriptiveType(newValue));
			msg.append(&quot;] to required type [&quot;).append(ClassUtils.getQualifiedName(requiredType)).append(&quot;]&quot;);
			if (propertyName !&#x3D; null) &#123;
				msg.append(&quot; for property &#39;&quot;).append(propertyName).append(&quot;&#39;&quot;);
			&#125;
			if (editor !&#x3D; null) &#123;
				msg.append(&quot;: PropertyEditor [&quot;).append(editor.getClass().getName()).append(
						&quot;] returned inappropriate value of type [&quot;).append(
						ClassUtils.getDescriptiveType(convertedValue)).append(&quot;]&quot;);
				throw new IllegalArgumentException(msg.toString());
			&#125;
			else &#123;
				msg.append(&quot;: no matching editors or conversion strategy found&quot;);
				throw new IllegalStateException(msg.toString());
			&#125;
		&#125;
	&#125;

	if (firstAttemptEx !&#x3D; null) &#123;
		if (editor &#x3D;&#x3D; null &amp;&amp; !standardConversion &amp;&amp; requiredType !&#x3D; null &amp;&amp; !Object.class.equals(requiredType)) &#123;
			throw firstAttemptEx;
		&#125;
		logger.debug(&quot;Original ConversionService attempt failed - ignored since &quot; +
				&quot;PropertyEditor based conversion eventually succeeded&quot;, firstAttemptEx);
	&#125;

	return (T) convertedValue;
&#125;</code></pre>

<p>至此，参数解析器中对参数进行类型转化完成，接着后面会用反射调用方法，将这个作为转化后的值作为入参</p>
<p>当然这个属于单个属性的转换，我们经常会用到使用一个类来接收我们需要的多个属性参数，这种情况就使用到了<code>BeanWrapperImpl</code>这个类了，它继承了<code>AbstractPropertyAccessor</code>，可以对类中属性进行操作，同时它也有个形参<code>conversionservice</code>，和实现了接口<code>PropertyEditorRegistry</code>接口，有了给我们注入自定义<code>PropertyEditor</code>的功能</p>
<p>转换过程差不多，解析到参数为复杂类时，在创建<code>DataBinder</code>时，创建了内部变量<code>BindingResult</code>和它的内部变量<code>BeanWrapperImpl</code>，然后初始化注入自定义<code>PropertyEditor</code>和<code>conversionservice</code>，哦还有将这个参数类反射实例化通过构造方法传入<code>BeanWrapperImpl</code>，然后调用<code>BeanWrapperImpl</code>的<code>setProperty</code>将请求中参数名字和参数值设置到类中对应的属性，所以请求中参数名一定要和属性名相等</p>
<p>在这个过程中，通过<code>BeanWrapperImpl</code>中的<code>cachedIntrospectionResults</code>获取所有属性的<code>PropertyDescriptor</code>对象，通过这个对象中的属性的<code>get</code>,<code>set</code>方法确认属性的具体类型，然后开始和我们上面一样的转换过程</p>
<p>转换完之后调用<code>PropertyDescriptor</code>中属性的<code>set</code>方法将值注入类中</p>
<p>循环完成之后就完成了对将请求中属性绑定到入参的类中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/ReentrantLock%E8%8E%B7%E5%8F%96%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/ReentrantLock%E8%8E%B7%E5%8F%96%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81%E6%BA%90%E7%A0%81/" itemprop="url">ReentrantLock获取锁释放锁源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p><code>ReentrantLock</code>中主要用到的核心类就是<code>AbstractQueuedSynchronizer</code>，例如最基本的获取锁和释放锁</p>
<p><code>private volatile int state</code>: The synchronization state，标记当前加锁状态的变量，初始为0，当有线程调用<code>lock</code>方法获取到锁时，它会变为1(重入时继续增1)</p>
<p><code>private transient volatile Node head</code>: 线程队列头</p>
<p><code>private transient volatile Node tail</code>: 线程队列尾</p>
<p>它有个内部类<code>Node</code>，每个线程为一个节点，以链表的结构实现多个线程排队</p>
<p><code>volatile Node prev;</code>: 上一个节点</p>
<p><code>volatile Node next</code>: 下一个节点</p>
<p><code>volatile int waitStatus</code>: 线程等待状态</p>
<p><code>volatile Thread thread</code>： 节点中的线程</p>
<p><code>volatile Node nextWaiter</code>: 节点锁的属性(shared和exclusive)</p>
<p>等待线程队列wait queue结构如下</p>
<p><img src="https://img-blog.csdnimg.cn/20190829203640524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODM1NjI0,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p><img src="https://raw.githubusercontent.com/sinaill/pic/master/Sync.png" alt=""> </p>
<p>ReentrantLock中有两种锁，公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>，公平锁遵循FIFO原则</p>
<pre><code class="highlight plain">&#x2F;**
 * Creates an instance of &#123;@code ReentrantLock&#125;.
 * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.
 *&#x2F;
public ReentrantLock() &#123;
    sync &#x3D; new NonfairSync();
&#125;

&#x2F;**
 * Creates an instance of &#123;@code ReentrantLock&#125; with the
 * given fairness policy.
 *
 * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy
 *&#x2F;
public ReentrantLock(boolean fair) &#123;
    sync &#x3D; fair ? new FairSync() : new NonfairSync();
&#125;</code></pre>

<p>分别创建方法如上，默认创建非公平锁，如果想要创建公平锁，则需要构造函数传入<code>True</code></p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><pre><code class="highlight plain">public void lock() &#123;
    sync.lock();
&#125;</code></pre>

<p>这里可以看两种锁的实现方式</p>
<pre><code class="highlight plain">&#x2F;**
 * 非公平锁
 *&#x2F;
final void lock() &#123;
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
&#125;

&#x2F;**
 * 公平锁
 *&#x2F;
final void lock() &#123;
    acquire(1);
&#125;</code></pre>

<p>可以看到非公平锁在线程获取锁时，是采用<code>compareAndSetState(0, 1)</code>马上尝试获取锁</p>
<p>接着来到<code>acquire(1)</code></p>
<pre><code class="highlight plain">public final void acquire(int arg) &#123;
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
&#125;</code></pre>

<p><code>tryAcquire</code>方法两种锁还是分别有自己的实现逻辑</p>
<pre><code class="highlight plain">&#x2F;**
 * 公平锁的tryAcquire方法
 *&#x2F;
protected final boolean tryAcquire(int acquires) &#123;
    final Thread current &#x3D; Thread.currentThread();
    int c &#x3D; getState();
    if (c &#x3D;&#x3D; 0) &#123;
		&#x2F;&#x2F;当前锁空闲时，查看是否有线程队列排队中
        if (!hasQueuedPredecessors() &amp;&amp;
            compareAndSetState(0, acquires)) &#123;
            setExclusiveOwnerThread(current);
            return true;
        &#125;
    &#125;
	&#x2F;&#x2F;锁被占用时，如果是用一个线程重入，state继续加1
    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;
        int nextc &#x3D; c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    &#125;
    return false;
&#125;</code></pre>

<p>公平锁即使在锁空闲时，仍会<code>hasQueuedPredecessors()</code>查看时候后面还有线程在队列派对中</p>
<pre><code class="highlight plain">public final boolean hasQueuedPredecessors() &#123;
    &#x2F;&#x2F; The correctness of this depends on head being initialized
    &#x2F;&#x2F; before tail and on head.next being accurate if the current
    &#x2F;&#x2F; thread is first in queue.
    Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order
    Node h &#x3D; head;
    Node s;
    return h !&#x3D; t &amp;&amp;
        ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());
&#125;</code></pre>

<p>非公平锁的<code>tryAcquire</code>继续调用<code>nonfairTryAcquire(int acquires)</code></p>
<pre><code class="highlight plain">final boolean nonfairTryAcquire(int acquires) &#123;
    final Thread current &#x3D; Thread.currentThread();
    int c &#x3D; getState();
    if (c &#x3D;&#x3D; 0) &#123;
		&#x2F;&#x2F;锁空闲时，继续抢锁
        if (compareAndSetState(0, acquires)) &#123;
            setExclusiveOwnerThread(current);
            return true;
        &#125;
    &#125;
    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;
        int nextc &#x3D; c + acquires;
        if (nextc &lt; 0) &#x2F;&#x2F; overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    &#125;
    return false;
&#125;</code></pre>
<p>还是一样，<code>state==0</code>时继续抢锁</p>
<p>以上就是两种锁在抢锁时不同的地方，非公平锁相当于抢两次锁，没抢到就去排队，而公平锁会先看有没有线程在排队，没有时才抢锁</p>
<p>然后我们回到<code>acquire(int arg)</code>方法，这里可以看到线程是怎么排队的</p>
<pre><code class="highlight plain">public final void acquire(int arg) &#123;
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
&#125;</code></pre>

<p><code>addWaiter(Node.EXCLUSIVE)</code>方法创建新节点存放排队的线程</p>
<pre><code class="highlight plain">private Node addWaiter(Node mode) &#123;
    Node node &#x3D; new Node(Thread.currentThread(), mode);
    Node pred &#x3D; tail;
    if (pred !&#x3D; null) &#123;
        node.prev &#x3D; pred;
        if (compareAndSetTail(pred, node)) &#123;
            pred.next &#x3D; node;
            return node;
        &#125;
    &#125;
    enq(node);&#x2F;&#x2F;将创建的节点入队
    return node;
&#125;</code></pre>

<p>每个线程创建一个节点，此时节点中<code>waitStatus</code>为0，然后将这个节点设置为<code>tail</code>，并且和上一个<code>tail</code>串联起来(将节点中<code>prev</code>指向上一个<code>tail</code>)，就这样，线程呈链表的形式排成队，接着进入<code>acquireQueued</code>方法</p>
<pre><code class="highlight plain">final boolean acquireQueued(final Node node, int arg) &#123;
    boolean failed &#x3D; true;
    try &#123;
        boolean interrupted &#x3D; false;
        for (;;) &#123;
            final Node p &#x3D; node.predecessor();
			&#x2F;&#x2F;查看上一个节点是不是头节点，是的话抢锁
            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;
                setHead(node);&#x2F;&#x2F;抢到锁将自己变为头节点
                p.next &#x3D; null; &#x2F;&#x2F; help GC
                failed &#x3D; false;
                return interrupted;
            &#125;
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted &#x3D; true;
        &#125;
    &#125; finally &#123;
        if (failed)
            cancelAcquire(node);
    &#125;
&#125;</code></pre>

<p>这里接受的<code>node</code>是线程创建好的节点，然后线程开始以这样的形式，Head-&gt;线程节点1-&gt;线程节点2···，在for无条件循环中，每一个节点的线程检测上一个节点是否为头节点，是的话，尝试抢锁，成功之后把自己节点设置为头节点，Head-&gt;线程节点2···</p>
<p>非头节点时，进入<code>shouldParkAfterFailedAcquire(p, node)</code></p>
<pre><code class="highlight plain">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;
    int ws &#x3D; pred.waitStatus;
    if (ws &#x3D;&#x3D; Node.SIGNAL)
        &#x2F;*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         *&#x2F;
        return true;
    if (ws &gt; 0) &#123;
        &#x2F;*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         *&#x2F;
        do &#123;
            node.prev &#x3D; pred &#x3D; pred.prev;
        &#125; while (pred.waitStatus &gt; 0);
        pred.next &#x3D; node;
    &#125; else &#123;
        &#x2F;*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don&#39;t park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         *&#x2F;
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    &#125;
    return false;
    &#125;</code></pre>
<p>初始<code>waitStatus</code>为0，所以这里把前节点的<code>waitStatus</code>都设置为<code>Node.SIGNAL(-1)</code>，返回<code>false</code>，然后短路，第二次循环这里返回<code>true</code>，然后进入<code>parkAndCheckInterrupt()</code>，挂起线程</p>
<pre><code class="highlight plain">private final boolean parkAndCheckInterrupt() &#123;
    LockSupport.park(this);
    return Thread.interrupted();
&#125;</code></pre>

<p>这里把两次循环都没抢到锁的线程挂起</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><pre><code class="highlight plain">public void unlock() &#123;
    sync.release(1);
&#125;


public final boolean release(int arg) &#123;
    if (tryRelease(arg)) &#123;
        Node h &#x3D; head;
        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)
            unparkSuccessor(h);
        return true;
    &#125;
    return false;
&#125;</code></pre>

<p><code>tryRelease(arg)</code>开始释放锁</p>
<pre><code class="highlight plain">protected final boolean tryRelease(int releases) &#123;
    int c &#x3D; getState() - releases;
	&#x2F;&#x2F;被锁的线程才能释放锁，否则抛出异常
    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free &#x3D; false;
    if (c &#x3D;&#x3D; 0) &#123;
        free &#x3D; true;
        setExclusiveOwnerThread(null);
    &#125;
    setState(c);
    return free;
&#125;</code></pre>

<p>这里将<code>state</code>减1，等于0的时候释放锁，将<code>state</code>置0，返回<code>true</code>，此时如果有线程在排队(挂起状态)，<code>unparkSuccessor(h)</code>将线程回到运行状态</p>
<pre><code class="highlight plain">private void unparkSuccessor(Node node) &#123;
    &#x2F;*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     *&#x2F;
    int ws &#x3D; node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    &#x2F;*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     *&#x2F;
    Node s &#x3D; node.next;
    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;
        s &#x3D; null;
        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)
            if (t.waitStatus &lt;&#x3D; 0)
                s &#x3D; t;
    &#125;
    if (s !&#x3D; null)
		&#x2F;&#x2F;唤醒Head后一个节点中的线程
        LockSupport.unpark(s.thread);
&#125;</code></pre>

<p>这里传入<code>Head</code>节点，从前面可以知道，<code>Head</code>节点后面有线程节点排队时，<code>head</code>节点的<code>waitStatus</code>被置为<code>Node.SIGNAL</code>，即-1，这里重新置0，然后获取<code>Head</code>节点的下一个节点，如果不为空，则将节点中存放的创建该节点的线程唤醒</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/Mysql%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/Mysql%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" itemprop="url">Mysql语法练习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="表名和字段"><a href="#表名和字段" class="headerlink" title="表名和字段"></a>表名和字段</h3><p>学生表<br>Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别<br>课程表<br>Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号<br>教师表<br>Teacher(t_id,t_name) –教师编号,教师姓名<br>成绩表<br>Score(s_id,c_id,s_score) –学生编号,课程编号,分数</p>
<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><pre><code class="highlight plain">--建表
--学生表
CREATE TABLE &#96;Student&#96;(
    &#96;s_id&#96; VARCHAR(20),
    &#96;s_name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,
    &#96;s_birth&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,
    &#96;s_sex&#96; VARCHAR(10) NOT NULL DEFAULT &#39;&#39;,
    PRIMARY KEY(&#96;s_id&#96;)
);
--课程表
CREATE TABLE &#96;Course&#96;(
    &#96;c_id&#96;  VARCHAR(20),
    &#96;c_name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,
    &#96;t_id&#96; VARCHAR(20) NOT NULL,
    PRIMARY KEY(&#96;c_id&#96;)
);
--教师表
CREATE TABLE &#96;Teacher&#96;(
    &#96;t_id&#96; VARCHAR(20),
    &#96;t_name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,
    PRIMARY KEY(&#96;t_id&#96;)
);
--成绩表
CREATE TABLE &#96;Score&#96;(
    &#96;s_id&#96; VARCHAR(20),
    &#96;c_id&#96;  VARCHAR(20),
    &#96;s_score&#96; INT(3),
    PRIMARY KEY(&#96;s_id&#96;,&#96;c_id&#96;)
);

--插入学生表测试数据
insert into Student values(&#39;01&#39; , &#39;赵雷&#39; , &#39;1990-01-01&#39; , &#39;男&#39;);
insert into Student values(&#39;02&#39; , &#39;钱电&#39; , &#39;1990-12-21&#39; , &#39;男&#39;);
insert into Student values(&#39;03&#39; , &#39;孙风&#39; , &#39;1990-05-20&#39; , &#39;男&#39;);
insert into Student values(&#39;04&#39; , &#39;李云&#39; , &#39;1990-08-06&#39; , &#39;男&#39;);
insert into Student values(&#39;05&#39; , &#39;周梅&#39; , &#39;1991-12-01&#39; , &#39;女&#39;);
insert into Student values(&#39;06&#39; , &#39;吴兰&#39; , &#39;1992-03-01&#39; , &#39;女&#39;);
insert into Student values(&#39;07&#39; , &#39;郑竹&#39; , &#39;1989-07-01&#39; , &#39;女&#39;);
insert into Student values(&#39;08&#39; , &#39;王菊&#39; , &#39;1990-01-20&#39; , &#39;女&#39;);
--课程表测试数据
insert into Course values(&#39;01&#39; , &#39;语文&#39; , &#39;02&#39;);
insert into Course values(&#39;02&#39; , &#39;数学&#39; , &#39;01&#39;);
insert into Course values(&#39;03&#39; , &#39;英语&#39; , &#39;03&#39;);
 
--教师表测试数据
insert into Teacher values(&#39;01&#39; , &#39;张三&#39;);
insert into Teacher values(&#39;02&#39; , &#39;李四&#39;);
insert into Teacher values(&#39;03&#39; , &#39;王五&#39;);
 
--成绩表测试数据
insert into Score values(&#39;01&#39; , &#39;01&#39; , 80);
insert into Score values(&#39;01&#39; , &#39;02&#39; , 90);
insert into Score values(&#39;01&#39; , &#39;03&#39; , 99);
insert into Score values(&#39;02&#39; , &#39;01&#39; , 70);
insert into Score values(&#39;02&#39; , &#39;02&#39; , 60);
insert into Score values(&#39;02&#39; , &#39;03&#39; , 80);
insert into Score values(&#39;03&#39; , &#39;01&#39; , 80);
insert into Score values(&#39;03&#39; , &#39;02&#39; , 80);
insert into Score values(&#39;03&#39; , &#39;03&#39; , 80);
insert into Score values(&#39;04&#39; , &#39;01&#39; , 50);
insert into Score values(&#39;04&#39; , &#39;02&#39; , 30);
insert into Score values(&#39;04&#39; , &#39;03&#39; , 20);
insert into Score values(&#39;05&#39; , &#39;01&#39; , 76);
insert into Score values(&#39;05&#39; , &#39;02&#39; , 87);
insert into Score values(&#39;06&#39; , &#39;01&#39; , 31);
insert into Score values(&#39;06&#39; , &#39;03&#39; , 34);
insert into Score values(&#39;07&#39; , &#39;02&#39; , 89);
insert into Score values(&#39;07&#39; , &#39;03&#39; , 98);</code></pre>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>查询”01”课程比”02”课程成绩高的学生的信息及课程分数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.*,b.c_id,b.s_score,c.c_id <span class="keyword">AS</span> c_id2,c.s_score <span class="keyword">AS</span> s_score2 <span class="keyword">FROM</span> student a 
<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score c <span class="keyword">on</span> a.s_id=c.s_id 
<span class="keyword">AND</span> c.c_id=<span class="string">'02'</span> <span class="keyword">where</span> b.s_score&gt;c.s_score <span class="keyword">and</span> b.c_id=<span class="string">'01'</span></code></pre>

<p><strong>同表内比较使用同表内联</strong></p>
<p>查询”01”课程比”02”课程成绩低的学生的信息及课程分数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.*,b.c_id,b.s_score,c.c_id <span class="keyword">AS</span> c_id2,c.s_score <span class="keyword">AS</span> s_score2 <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score c <span class="keyword">on</span> a.s_id=c.s_id <span class="keyword">AND</span> c.c_id=<span class="string">'02'</span> <span class="keyword">where</span> b.s_score&lt;c.s_score <span class="keyword">and</span> b.c_id=<span class="string">'01'</span></code></pre>

<p>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score),<span class="number">2</span>) <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> avg_score&gt;=<span class="number">60</span></code></pre>

<p>查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩(包括有成绩的和无成绩的)</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score),<span class="number">2</span>) <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student a <span class="keyword">left</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> avg_score&lt;<span class="number">60</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> c.s_id,c.s_name,<span class="number">0</span> <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student c <span class="keyword">WHERE</span> c.s_id <span class="keyword">not</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s_id <span class="keyword">FROM</span> score)</code></pre>

<p><strong>UNION 用于合并两个或多个 SELECT 语句的结果集，并消去表中任何重复行</strong></p>
<p>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">COUNT</span>(b.c_id),<span class="keyword">SUM</span>(b.s_score) <span class="keyword">as</span> score <span class="keyword">FROM</span> student a <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id</code></pre>

<p>查询”李”姓老师的数量</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(a.t_id) <span class="keyword">FROM</span> teacher a <span class="keyword">WHERE</span> a.t_name REGEXP <span class="string">'^李'</span>(<span class="keyword">like</span> <span class="string">'李%'</span>)</code></pre>

<p>查询学过”张三”老师授课的同学的信息</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id <span class="keyword">in</span>(<span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> t_id =(<span class="keyword">select</span> t_id <span class="keyword">from</span> teacher <span class="keyword">where</span> t_name = <span class="string">'张三'</span>);</code></pre>

<p>查询没学过”张三”老师授课的同学的信息</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> a.s_id <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> t_id <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> t_name=<span class="string">'张三'</span>)))	
<span class="string">``</span><span class="string">`sql</span>
<span class="string"></span>
<span class="string">查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息</span>
<span class="string"></span>
<span class="string">`</span><span class="string">``</span><span class="keyword">sql</span>
<span class="keyword">select</span> a.* <span class="keyword">from</span> student a,score b,score c <span class="keyword">where</span> a.s_id = b.s_id <span class="keyword">and</span> a.s_id = c.s_id <span class="keyword">and</span> b.c_id=<span class="string">'01'</span> <span class="keyword">and</span> c.c_id=<span class="string">'02'</span>;</code></pre>

<p><strong>交叉连接：因为没有连接条件，所进行的表与表间的所有行的连接</strong></p>
<p>查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">where</span> a.s_id <span class="keyword">in</span> (<span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'01'</span> ) <span class="keyword">and</span> a.s_id <span class="keyword">NOT</span> <span class="keyword">in</span>(<span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'02'</span>)</code></pre>

<p>查询没有学全所有课程的同学的信息</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">select</span> a.s_id <span class="keyword">from</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.s_id)&gt;<span class="number">2</span>)</code></pre>

<p>查询至少有一门课与学号为”01”的同学所学相同的同学的信息</p>
<pre><code class="highlight sql"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> a.s_id <span class="keyword">from</span> score a <span class="keyword">where</span> a.c_id <span class="keyword">in</span>(<span class="keyword">select</span> a.c_id <span class="keyword">from</span> score a <span class="keyword">where</span> a.s_id=<span class="string">'01'</span>));</code></pre>

<p>查询和”01”号的同学学习的课程完全相同的其他同学的信息</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">where</span> a.s_id <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id!=’<span class="number">01</span>’ <span class="keyword">and</span> c_id <span class="keyword">in</span>(<span class="keyword">select</span> c_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id=’<span class="number">01</span>’)<span class="keyword">group</span> <span class="keyword">by</span> s_id <span class="keyword">having</span> <span class="keyword">count</span>(<span class="number">1</span>)=(<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> score <span class="keyword">where</span> s_id=<span class="string">'01'</span>));</code></pre>

<p>查询没学过”张三”老师讲授的任一门课程的学生姓名</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> a.s_id <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">WHERE</span> b.c_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t_id <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> t_name=<span class="string">'张三'</span>)))</code></pre>

<p>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score),<span class="number">2</span>) <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">AND</span> b.s_score&lt;<span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> a.s_id <span class="keyword">having</span> <span class="keyword">count</span>(a.s_id)&gt;<span class="number">1</span></code></pre>

<p>检索”01”课程分数小于60，按分数降序排列的学生信息</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">AND</span> b.c_id=’<span class="number">01</span>’ <span class="keyword">WHERE</span> b.s_score&lt;<span class="number">60</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b.s_score <span class="keyword">DESC</span></code></pre>

<p>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,(<span class="keyword">SELECT</span> s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id = a.s_id <span class="keyword">AND</span> c_id=<span class="string">'01'</span>) <span class="keyword">AS</span> 语文,(<span class="keyword">SELECT</span> s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id = a.s_id <span class="keyword">AND</span> c_id=<span class="string">'02'</span>) <span class="keyword">AS</span> 数学,(<span class="keyword">SELECT</span> s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id = a.s_id <span class="keyword">AND</span> c_id = <span class="string">'03'</span>) <span class="keyword">AS</span> 英语,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(a.s_score),<span class="number">2</span>) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> score a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均分 <span class="keyword">DESC</span></code></pre>

<p>查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率，及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.c_id,b.c_name,<span class="keyword">MAX</span>(s_score) <span class="keyword">AS</span> 最高分,<span class="keyword">MIN</span>(s_score) <span class="keyword">AS</span> 最低分,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">AS</span> 平均分,<span class="keyword">ROUND</span>(<span class="number">100</span><span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> a.s_score&gt;=<span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">WHEN</span> a.s_score <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>),<span class="number">2</span>) <span class="keyword">AS</span> 及格率,<span class="keyword">ROUND</span>(<span class="number">100</span>(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">70</span> <span class="keyword">and</span> a.s_score&lt;=<span class="number">80</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 中等率, <span class="keyword">ROUND</span>(<span class="number">100</span>(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">80</span> <span class="keyword">and</span> a.s_score&lt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 优良率,<span class="keyword">ROUND</span>(<span class="number">100</span>(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 优秀率 <span class="keyword">FROM</span> score a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course b <span class="keyword">ON</span> a.c_id = b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id<span class="string">`</span></code></pre>

<p>按各科成绩进行排序，并显示排名</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> ,(@i:=@i+<span class="number">1</span>) 排名 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = ‘<span class="number">01</span>’ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">LIMIT</span> <span class="number">10000</span>) a,(<span class="keyword">SELECT</span> @i:=<span class="number">0</span>) <span class="keyword">AS</span> 排名 <span class="keyword">UNION</span>
<span class="keyword">SELECT</span> ,(@j:=@j+<span class="number">1</span>) 排名 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = ‘<span class="number">02</span>’ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">LIMIT</span> <span class="number">10000</span>) a,(<span class="keyword">SELECT</span> @j:=<span class="number">0</span>) <span class="keyword">AS</span> 排名 <span class="keyword">UNION</span>
<span class="keyword">SELECT</span> ,(@k:=@k+<span class="number">1</span>) 排名 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = ‘<span class="number">03</span>’ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">LIMIT</span> <span class="number">10000</span>) a,(<span class="keyword">SELECT</span> @k:=<span class="number">0</span>) <span class="keyword">AS</span> 排名</code></pre>

<p>查询学生的总成绩并进行排名</p>
<p>查询学生平均成绩及其名次</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.s_id,@i:=@i+<span class="number">1</span> <span class="keyword">as</span> ‘不保留空缺排名’,@k:=(<span class="keyword">case</span> <span class="keyword">when</span> @avg_score=a.avg_s <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> ‘保留空缺排名’,@avg_score:=avg_s <span class="keyword">as</span> ‘平均分’<span class="keyword">from</span> (<span class="keyword">select</span> s_id,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_s <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id)a,(<span class="keyword">select</span> @avg_score:=<span class="number">0</span>,@i:=<span class="number">0</span>,@k:=<span class="number">0</span>)b;</code></pre>

<p>查询各科成绩前三名的记录</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.s_id,a.c_id,a.s_score,b.* <span class="keyword">from</span> score a <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.c_id = b.c_id <span class="keyword">and</span> a.s_score&lt;b.s_score <span class="keyword">group</span> <span class="keyword">by</span> a.s_id,a.c_id,a.s_score <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(b.s_id)&lt;<span class="number">3</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.c_id,a.s_score <span class="keyword">DESC</span></code></pre>

<p>查询每门课程被选修的学生数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.c_id,a.c_name,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量 <span class="keyword">FROM</span> course a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.c_id = b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.c_id,a.c_name</code></pre>

<p>查询出只有两门课程的全部学生的学号和姓名</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)=<span class="number">2</span></code></pre>

<p>查询男生、女生人数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> s_sex,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_sex</code></pre>

<p>查询名字中含有”风”字的学生信息</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_name <span class="keyword">RLIKE</span> “风”</code></pre>

<p>查询同名同性学生名单，并统计同名人数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> s_name,s_sex <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name,s_sex <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span></code></pre>

<p>查询1990年出生的学生名单</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> s_id,s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(s_birth)=’<span class="number">1990</span>’</code></pre>

<p>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> b.c_id,b.c_name,<span class="keyword">AVG</span>(a.s_score) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> score a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course b <span class="keyword">ON</span> a.c_id=b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均分 <span class="keyword">DESC</span>,b.c_id</code></pre>

<p>查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">AVG</span>(b.s_score) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name <span class="keyword">HAVING</span> 平均分&gt;=<span class="number">85</span></code></pre>

<p>查询课程名称为”数学”，且分数低于60的学生姓名和分数</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.s_name,b.s_score <span class="keyword">from</span> score b <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student a <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id=(<span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> c_name =’数学’) <span class="keyword">and</span> b.s_score&lt;<span class="number">60</span></code></pre>

<p>查询所有学生的课程及分数情况</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.s_id,a.s_name,<span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> ‘语文’ <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> ‘语文’,<span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> ‘数学’ <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> ‘数学’,<span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> ‘英语’ <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> ‘英语’,<span class="keyword">SUM</span>(b.s_score) <span class="keyword">as</span> ‘总分’ <span class="keyword">from</span> student a <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> b.c_id = c.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name</code></pre>

<p>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_name,b.s_score,c.c_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id <span class="keyword">WHERE</span> b.s_score&gt;<span class="number">70</span></code></pre>

<p>查询不及格的课程</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name,b.s_score,c.c_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id <span class="keyword">WHERE</span> b.s_score&lt;<span class="number">60</span></code></pre>

<p>查询课程编号为01且课程成绩在80分以上的学生的学号和姓名</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.s_id,a.s_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">WHERE</span> b.s_score&gt;<span class="number">80</span> <span class="keyword">AND</span> b.c_id=’<span class="number">01</span>’</code></pre>

<p>求每门课程的学生人数</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</code></pre>

<p>查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.*,b.s_score,b.c_id,c.c_name <span class="keyword">from</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id <span class="keyword">where</span> b.c_id =(<span class="keyword">select</span> c_id <span class="keyword">from</span> course c,teacher d <span class="keyword">where</span> c.t_id=d.t_id <span class="keyword">and</span> d.t_name=’张三’) <span class="keyword">and</span> b.s_score <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">MAX</span>(s_score) <span class="keyword">from</span> score <span class="keyword">where</span> c_id=’<span class="number">02</span>’)</code></pre>

<p>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</p>
<pre><code class="highlight sql"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> b.s_id,b.c_id,b.s_score <span class="keyword">from</span> score a,score b <span class="keyword">where</span> a.c_id != b.c_id <span class="keyword">and</span> a.s_score = b.s_score</code></pre>

<p>查询每门功成绩最好的前两名</p>
<pre><code class="highlight sql"><span class="keyword">select</span> a.s_id,a.c_id,a.s_score <span class="keyword">from</span> score a <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> score b <span class="keyword">where</span> b.c_id=a.c_id <span class="keyword">and</span> b.s_score&gt;=a.s_score)&lt;=<span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.c_id</code></pre>

<p>统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排 列，若人数相同，按课程号升序排列</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.c_id,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">as</span> n <span class="keyword">FROM</span> score a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.c_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.c_id)&gt;<span class="number">5</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> n <span class="keyword">DESC</span>,c_id</code></pre>

<p>检索至少选修两门课程的学生学号</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.s_id)&gt;<span class="number">1</span></code></pre>

<p>查询选修了全部课程的学生信息</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.s_id)&gt;<span class="number">2</span></code></pre>

<p>查询各学生的年龄(当前月日 &lt; 出生年月的月日则，年龄减一)</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> *,<span class="keyword">YEAR</span>(<span class="keyword">NOW</span>())-<span class="keyword">YEAR</span>(s_birth)-(<span class="keyword">case</span> <span class="keyword">WHEN</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>())-<span class="keyword">MONTH</span>(s_birth)&gt;<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">AS</span> 年龄 <span class="keyword">FROM</span> student</code></pre>

<p>查询本周过生日的学生</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">WEEK</span>(<span class="keyword">NOW</span>())=<span class="keyword">WEEK</span>(s_birth)</code></pre>

<p>查询下周过生日的学生</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> (<span class="keyword">WEEK</span>(<span class="keyword">NOW</span>())+<span class="number">1</span>)=<span class="keyword">WEEK</span>(s_birth)</code></pre>

<p>查询本月过生日的学生</p>
<pre><code class="highlight sql"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(s_birth) = <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>())</code></pre>

<p>查询下月过生日的学生</p>
<pre><code class="highlight plain">SELECT * FROM student WHERE MONTH(s_birth) &#x3D; (MONTH(NOW())+1)</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinaill</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinaill</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <link rel="stylesheet" href="/lib/prettify/skins/desert.css" type="text/css">
<script src="/lib/prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
      prettyPrint();
  });
</script>
</body>
</html>
