<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="article:author" content="sinaill">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E8%8E%B7%E5%8F%96HandlerExecutionChain%E5%92%8CHandlerAdapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E8%8E%B7%E5%8F%96HandlerExecutionChain%E5%92%8CHandlerAdapter/" itemprop="url">SpringMVC获取HandlerExecutionChain和HandlerAdapter</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="重要类"><a href="#重要类" class="headerlink" title="重要类"></a>重要类</h3><h4 id="HandlerExecutionChain和HandlerAdapter"><a href="#HandlerExecutionChain和HandlerAdapter" class="headerlink" title="HandlerExecutionChain和HandlerAdapter"></a>HandlerExecutionChain和HandlerAdapter</h4><p><code>HandlerExecutionChain</code>中有如下成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HandlerExecutionChain&#123;</span><br><span class="line">	private static final Log logger &#x3D; LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line"></span><br><span class="line">	private final Object handler;</span><br><span class="line"></span><br><span class="line">	private HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">	private List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">	private int interceptorIndex &#x3D; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>handler</code>：执行一个<code>HandlerMethod</code>类型的对象</li>
<li><code>interceptors</code>：存放了所有拦截器的数组</li>
<li><code>interceptorList</code>：存放了所有拦截器的链表</li>
</ul>
<h4 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h4><p><code>HandlerMethod</code>是一个接口，它的成员变量如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HandlerMethod &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;** Logger that is available to subclasses *&#x2F;</span><br><span class="line">	protected final Log logger &#x3D; LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	private final Object bean;</span><br><span class="line"></span><br><span class="line">	private final BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">	private final Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line">	private final Method method;</span><br><span class="line"></span><br><span class="line">	private final Method bridgedMethod;</span><br><span class="line"></span><br><span class="line">	private final MethodParameter[] parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object</code>：存放了与<code>Handler</code>有关的信息，如Demo中指向了一个方法所在的类的名称</li>
<li><code>method</code>：指向本次请求的目标<code>Handler</code>对象的目标方法</li>
<li><code>parameters</code>：存放了本次请求的入参</li>
<li><code>beanType</code>：指向了对应方法所在的<code>Handler</code>对象的类对象<code>Class</code></li>
</ul>
<h4 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h4><p>Demo中用了<code>@RequestMapping</code>注解的方式来匹配url，所以只看它</p>
<p>在Debug中，查看<code>RequestMappingHandlerMapping</code>中的成员变量，发现</p>
<ul>
<li><code>applicationContext</code>：Spring容器，可以用来获取容器中创建了的对象</li>
<li><code>servletContext</code></li>
<li><code>urlMap</code>：属于<code>LinkedMultiValueMap</code>类，key值为请求中的<code>url(lookupPath)</code>，<code>value</code>值又是一个<code>linkedList</code>，可以存放多个<code>@RequestMappingInfo</code>类型的对象，该对象主要存放了<code>@RequestMapping</code>注解中的属性值，例如<code>value</code>和<code>method</code>属性，键值间的映射方式为<code>url(lookupPath)</code>与<code>@RequestMapping</code>注解的value值相同</li>
<li><code>handlerMethods</code>：是一个<code>LinkedHashMap</code>，键key为<code>RequestMappingInfo</code>对象，存放了<code>@RequestMapping</code>注解的属性，值value为对应方法的<code>HandlerMethod</code>对象的映射</li>
<li><code>mappedInterceptor</code>:是一个<code>ArrayList</code>，指向了配置中的所有拦截器</li>
</ul>
<h4 id="RequestMappingInfo"><a href="#RequestMappingInfo" class="headerlink" title="RequestMappingInfo"></a>RequestMappingInfo</h4><p><a href="https://my.oschina.net/u/157224/blog/974072" target="_blank" rel="noopener">MVC请求映射信息RequestMappingInfo详解</a></p>
<h3 id="获取HandlerExecutionChain"><a href="#获取HandlerExecutionChain" class="headerlink" title="获取HandlerExecutionChain"></a>获取HandlerExecutionChain</h3><p>获取HandlerExecutionChain的关键代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Determine handler for the current request.</span><br><span class="line">mappedHandler &#x3D; getHandler(processedRequest);</span><br></pre></td></tr></table></figure>

<p>跟进<code>getHandler</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	for (HandlerMapping hm : this.handlerMappings) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(</span><br><span class="line">					&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		HandlerExecutionChain handler &#x3D; hm.getHandler(request);</span><br><span class="line">		if (handler !&#x3D; null) &#123;</span><br><span class="line">			return handler;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中在<code>DispatchServelt</code>中，<code>this.HandlerMappings</code>为<code>SpringMvc</code>中系统已经注入了三种<code>HandlerMappings</code>，如图</p>
<p><img src="http://wx3.sinaimg.cn/large/96b7c0f4ly1g2blsrig3yj20bv04174a.jpg" alt="HandlerMapping"></p>
<p>源码中依次让三种<code>HandlerMapping</code>来执行本次代码<code>HandlerExecutionChain handler = hm.getHandler(request);</code>，然后判断返回的<code>handler</code>对象是否为空，来决定是否返回该<code>handler</code>对象，所以接着查看<code>getHandler</code>方法，三种<code>HandlerMapping</code>的<code>getHandler</code>方法都继承自<code>AbstractHandlerMapping</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	Object handler &#x3D; getHandlerInternal(request);</span><br><span class="line">	if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">		handler &#x3D; getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Bean name or resolved handler?</span><br><span class="line">	if (handler instanceof String) &#123;</span><br><span class="line">		String handlerName &#x3D; (String) handler;</span><br><span class="line">		handler &#x3D; getApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line">	return getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟入<code>getHandlerInternal</code>方法发现，<code>RequestHandlerMapping</code>对象的<code>getHandlerInternal</code>来自<code>AbstractHandlerMapping</code>的继承类<code>AbstractHandlerMethodMapping</code>，另外两种<code>BeanNameUrlHandlerMapping</code>、<code>SimpleUrlHandlerMapping</code>则来自<code>AbstractHandlerMapping</code>的另一个继承类<code>AbstractUrlMethodMapping</code></p>
<p>先看<code>AbstractHandlerMethodMapping</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	String lookupPath &#x3D; getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);</span><br><span class="line">	&#125;</span><br><span class="line">	HandlerMethod handlerMethod &#x3D; lookupHandlerMethod(lookupPath, request);</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		if (handlerMethod !&#x3D; null) &#123;</span><br><span class="line">			logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return (handlerMethod !&#x3D; null ? handlerMethod.createWithResolvedBean() : null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中变量<code>lookupPath</code>为除掉服务器根目录后剩余的url，例如在Demo中本次请求url为”<a href="http://localhost:8080/Person?name=zhang&amp;age=13&quot;(pom文件中配置了服务器path为&quot;/&quot;)，则此处`lookupPath`为&quot;/person&quot;" target="_blank" rel="noopener">http://localhost:8080/Person?name=zhang&amp;age=13&quot;(pom文件中配置了服务器path为&quot;/&quot;)，则此处`lookupPath`为&quot;/person&quot;</a></p>
<p>接着<code>HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request)</code>返回了一个<code>HandlerMethod</code>类型的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	List&lt;Match&gt; matches &#x3D; new ArrayList&lt;Match&gt;();</span><br><span class="line">	List&lt;T&gt; directPathMatches &#x3D; this.urlMap.get(lookupPath);</span><br><span class="line">	if (directPathMatches !&#x3D; null) &#123;</span><br><span class="line">		addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">	&#125;</span><br><span class="line">	if (matches.isEmpty()) &#123;</span><br><span class="line">		&#x2F;&#x2F; No choice but to go through all mappings...</span><br><span class="line">		addMatchingMappings(this.handlerMethods.keySet(), matches, request);</span><br><span class="line">		&#x2F;&#x2F;这条分支在Demo中测试得，由于urlMap映射中不包括模糊匹配&#x2F;*，所以directPathMatches</span><br><span class="line">		&#x2F;&#x2F;将为空，不能精确匹配到RequestMappingInfo</span><br><span class="line">		&#x2F;&#x2F;当有匹配了模糊匹配的request传进来，是直接用RequestMappingHandlerMapping</span><br><span class="line">		&#x2F;&#x2F;中的HandlerMethods集合中的keySet，也就是使用RequestMappingInfo集合进行遍历寻找</span><br><span class="line">		&#x2F;&#x2F;匹配的RquestMappingInfo</span><br><span class="line">		&#x2F;&#x2F;由这个特性得，当既有精确匹配又有模糊匹配时，优先匹配精确，然后才是模糊匹配</span><br><span class="line">		&#x2F;&#x2F;补充：当使用@PathVariable的时候，匹配不到也会走这条路径</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!matches.isEmpty()) &#123;</span><br><span class="line">		Comparator&lt;Match&gt; comparator &#x3D; new MatchComparator(getMappingComparator(request));</span><br><span class="line">		Collections.sort(matches, comparator);</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Found &quot; + matches.size() + &quot; matching mapping(s) for [&quot; + lookupPath + &quot;] : &quot; + matches);</span><br><span class="line">		&#125;</span><br><span class="line">		Match bestMatch &#x3D; matches.get(0);</span><br><span class="line">		if (matches.size() &gt; 1) &#123;</span><br><span class="line">			Match secondBestMatch &#x3D; matches.get(1);</span><br><span class="line">			if (comparator.compare(bestMatch, secondBestMatch) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				Method m1 &#x3D; bestMatch.handlerMethod.getMethod();</span><br><span class="line">				Method m2 &#x3D; secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">				throw new IllegalStateException(</span><br><span class="line">						&quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; + request.getRequestURL() + &quot;&#39;: &#123;&quot; +</span><br><span class="line">						m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">		return bestMatch.handlerMethod;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return handleNoMatch(handlerMethods.keySet(), lookupPath, request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据传入的<code>lookupPath</code>为key值从<code>urlMap</code>中获取对应的映射<code>linkedList</code>类型的对象<code>directPahtMatches</code>，链表中存放的是<code>RequestMappingInfo</code>类型的对象，存放<code>@RequestMapping</code>注解中的属性值。然后以该链表为入参进入<code>addMatchingMappings</code>方法。</p>
<p>这一步查找到与项目<code>ServletPath</code>匹配的<code>RequestMappingInfo</code>，由于一个<code>ServletPath</code>可以匹配多个属性不同的<code>RequestMappingInfo</code>，所以还要进一步筛选最终<code>RequestMappingInfo</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addMatchingMappings(Collection&lt;T&gt; mappings, List&lt;Match&gt; matches, HttpServletRequest request) &#123;</span><br><span class="line">	for (T mapping : mappings) &#123;</span><br><span class="line">		T match &#x3D; getMatchingMapping(mapping, request);</span><br><span class="line">		if (match !&#x3D; null) &#123;</span><br><span class="line">			matches.add(new Match(match, this.handlerMethods.get(mapping)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的<code>mappings</code>是与当前<code>url</code>映射的<code>RequestMappingInfo</code>链表，遍历该链表，进入<code>getMatchingMapping(mapping, request)</code>方法</p>
<p>这一步就是开始遍历上一步筛选的<code>RequestMappingInfo</code>，接下来是筛选方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) &#123;</span><br><span class="line">	return info.getMatchingCondition(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了传进来的<code>RequestMappingInfo</code>对象的<code>getMatchingCondition</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public RequestMappingInfo getMatchingCondition(HttpServletRequest request) &#123;</span><br><span class="line">	RequestMethodsRequestCondition methods &#x3D; this.methodsCondition.getMatchingCondition(request);</span><br><span class="line">	&#x2F;&#x2F;存放注解中指定请求的method类型， GET、POST、PUT、DELETE等</span><br><span class="line">	ParamsRequestCondition params &#x3D; this.paramsCondition.getMatchingCondition(request);</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 限定参数，用法例如</span><br><span class="line">	 * 1.params&#x3D;&quot;myParam&#x3D;myValue&quot;,	必须存在参数myParam,并且值为myValue.</span><br><span class="line">	 * 2.params&#x3D;&quot;myParam&quot;		必须存在参数myParam.</span><br><span class="line">	 * &#x2F;</span><br><span class="line">	&#x2F;&#x2F;存放注解中指定的header值</span><br><span class="line">	HeadersRequestCondition headers &#x3D; this.headersCondition.getMatchingCondition(request);</span><br><span class="line">	ConsumesRequestCondition consumes &#x3D; this.consumesCondition.getMatchingCondition(request);</span><br><span class="line">	&#x2F;&#x2F;存放注解中指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</span><br><span class="line">	ProducesRequestCondition produces &#x3D; this.producesCondition.getMatchingCondition(request);</span><br><span class="line">	&#x2F;&#x2F;存放注解中指定的返回的内容类型，例如Accept: *&#x2F;*</span><br><span class="line">	if (methods &#x3D;&#x3D; null || params &#x3D;&#x3D; null || headers &#x3D;&#x3D; null || consumes &#x3D;&#x3D; null || produces &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PatternsRequestCondition patterns &#x3D; this.patternsCondition.getMatchingCondition(request);</span><br><span class="line">	if (patterns &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RequestConditionHolder custom &#x3D; this.customConditionHolder.getMatchingCondition(request);</span><br><span class="line">	if (custom &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return new RequestMappingInfo(this.name, patterns,</span><br><span class="line">			methods, params, headers, consumes, produces, custom.getCondition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上代码主要查看<code>RequestMappingInfo</code>和<code>request</code>是否匹配，是的话创建一个新的<code>RequestMappingInfo</code>然后返回，否则返回空</p>
<p>这一步确定最终的<code>RequestMappingInfo</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addMatchingMappings(Collection&lt;T&gt; mappings, List&lt;Match&gt; matches, HttpServletRequest request) &#123;</span><br><span class="line">	for (T mapping : mappings) &#123;</span><br><span class="line">		T match &#x3D; getMatchingMapping(mapping, request);</span><br><span class="line">		if (match !&#x3D; null) &#123;</span><br><span class="line">			matches.add(new Match(match, this.handlerMethods.get(mapping)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量<code>match</code>接收返回的<code>RequestMappingInfo</code>，然后给传入的<code>ArrayList</code>类型的对象matches添加元素<code>new Match(match, this.handlerMethods.get(mapping))</code></p>
<p>这一步将最终确定的<code>RequestMappingInfo</code>和它相对应的<code>HandlerMethods</code>对象封装到<code>Match</code>类中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private class Match &#123;</span><br><span class="line"></span><br><span class="line">	private final T mapping;</span><br><span class="line"></span><br><span class="line">	private final HandlerMethod handlerMethod;</span><br><span class="line"></span><br><span class="line">	public Match(T mapping, HandlerMethod handlerMethod) &#123;</span><br><span class="line">		this.mapping &#x3D; mapping;</span><br><span class="line">		this.handlerMethod &#x3D; handlerMethod;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return this.mapping.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Match</code>类为定义在<code>AbstractHandlerMethodMapping</code>的内部类，</p>
<p><code>this.handlerMethods.get(mapping)</code>，<code>handlerMethods</code>为<code>AbstractHandlerMethodMapping</code>类的成员变量，定义为<code>private final Map&lt;T, HandlerMethod&gt; handlerMethods = new LinkedHashMap&lt;T, HandlerMethod&gt;();</code>，键值key为<code>RequestMappingInfo</code>类型的对象，值value为<code>HandlerMethod</code>类型的对象，从Demo中看，映射关系为<code>Controller</code>中<code>RequestMappingInfo</code>和它对应的方法，在这里根据<code>RequestMappingInfo</code>类的变量<code>mapping</code>获取对应的<code>HandlerMethod</code>对象，创建<code>Match</code>对象后添加到<code>matches</code>中</p>
<p>至此，<code>addMappingMatchings</code>结束，回到<code>lookupHandlerMethod</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	List&lt;Match&gt; matches &#x3D; new ArrayList&lt;Match&gt;();</span><br><span class="line">	List&lt;T&gt; directPathMatches &#x3D; this.urlMap.get(lookupPath);</span><br><span class="line">	if (directPathMatches !&#x3D; null) &#123;</span><br><span class="line">		addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">	&#125;</span><br><span class="line">	if (matches.isEmpty()) &#123;</span><br><span class="line">		&#x2F;&#x2F; No choice but to go through all mappings...</span><br><span class="line">		addMatchingMappings(this.handlerMethods.keySet(), matches, request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!matches.isEmpty()) &#123;</span><br><span class="line">		Comparator&lt;Match&gt; comparator &#x3D; new MatchComparator(getMappingComparator(request));</span><br><span class="line">		Collections.sort(matches, comparator);</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Found &quot; + matches.size() + &quot; matching mapping(s) for [&quot; + lookupPath + &quot;] : &quot; + matches);</span><br><span class="line">		&#125;</span><br><span class="line">		Match bestMatch &#x3D; matches.get(0);</span><br><span class="line">		if (matches.size() &gt; 1) &#123;</span><br><span class="line">			Match secondBestMatch &#x3D; matches.get(1);</span><br><span class="line">			if (comparator.compare(bestMatch, secondBestMatch) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				Method m1 &#x3D; bestMatch.handlerMethod.getMethod();</span><br><span class="line">				Method m2 &#x3D; secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">				throw new IllegalStateException(</span><br><span class="line">						&quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; + request.getRequestURL() + &quot;&#39;: &#123;&quot; +</span><br><span class="line">						m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">		return bestMatch.handlerMethod;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return handleNoMatch(handlerMethods.keySet(), lookupPath, request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步又一次对经过上一步筛选的<code>RequestMappingInfo</code>进行筛选(这一步不知道为什么还会有剩多个<code>RequestMappingInfo</code>，单纯的复制<code>Handler</code>中方法，编译期就报错)</p>
<p>接着查看<code>handleMatch(bestMatch.mapping, lookupPath, request)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) &#123;</span><br><span class="line">	super.handleMatch(info, lookupPath, request);</span><br><span class="line"></span><br><span class="line">	String bestPattern;</span><br><span class="line">	Map&lt;String, String&gt; uriVariables;</span><br><span class="line">	Map&lt;String, String&gt; decodedUriVariables;</span><br><span class="line"></span><br><span class="line">	Set&lt;String&gt; patterns &#x3D; info.getPatternsCondition().getPatterns();</span><br><span class="line">	if (patterns.isEmpty()) &#123;</span><br><span class="line">		bestPattern &#x3D; lookupPath;</span><br><span class="line">		uriVariables &#x3D; Collections.emptyMap();</span><br><span class="line">		decodedUriVariables &#x3D; Collections.emptyMap();</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		bestPattern &#x3D; patterns.iterator().next();</span><br><span class="line">		uriVariables &#x3D; getPathMatcher().extractUriTemplateVariables(bestPattern, lookupPath);</span><br><span class="line">		decodedUriVariables &#x3D; getUrlPathHelper().decodePathVariables(request, uriVariables);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	request.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern);</span><br><span class="line">	request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, decodedUriVariables);</span><br><span class="line"></span><br><span class="line">	if (isMatrixVariableContentAvailable()) &#123;</span><br><span class="line">		Map&lt;String, MultiValueMap&lt;String, String&gt;&gt; matrixVars &#x3D; extractMatrixVariables(request, uriVariables);</span><br><span class="line">		request.setAttribute(HandlerMapping.MATRIX_VARIABLES_ATTRIBUTE, matrixVars);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!info.getProducesCondition().getProducibleMediaTypes().isEmpty()) &#123;</span><br><span class="line">		Set&lt;MediaType&gt; mediaTypes &#x3D; info.getProducesCondition().getProducibleMediaTypes();</span><br><span class="line">		request.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将<code>uriVariable</code>变量以<code>HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>为key绑定到<code>Request</code>中，并且这个<code>uriVariable</code>是<code>Map&lt;String, String&gt;</code>类型的</p>
<p>上面一大段代码主要通过<code>ServetPath</code>-&gt;<code>RequestMappingInfo</code>-&gt;<code>HandlerMethod</code>-&gt;<code>March</code><br>此时变量<code>mathces</code>中就存放了这个<code>Match</code>，选取最优<code>Match</code>，返回<code>HandlerMethod</code>对象</p>
<p>执行完后回到<code>AbstractHandlerMethodMapping</code>的<code>getHandlerInternal</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	String lookupPath &#x3D; getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Looking up handler method for path &quot; + lookupPath);</span><br><span class="line">	&#125;</span><br><span class="line">	HandlerMethod handlerMethod &#x3D; lookupHandlerMethod(lookupPath, request);</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		if (handlerMethod !&#x3D; null) &#123;</span><br><span class="line">			logger.debug(&quot;Returning handler method [&quot; + handlerMethod + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			logger.debug(&quot;Did not find handler method for [&quot; + lookupPath + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return (handlerMethod !&#x3D; null ? handlerMethod.createWithResolvedBean() : null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到和当前<code>Request</code>对应的<code>HandlerMethod</code>之后，还要执行<code>handlerMethod.createWithResolvedBean()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HandlerMethod createWithResolvedBean() &#123;</span><br><span class="line">	Object handler &#x3D; this.bean;</span><br><span class="line">	if (this.bean instanceof String) &#123;</span><br><span class="line">		String beanName &#x3D; (String) this.bean;</span><br><span class="line">		handler &#x3D; this.beanFactory.getBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	return new HandlerMethod(this, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里获取了<code>HandlerMethod</code>中的<code>bean</code>变量，在Demo中Debug得，<code>Object</code>类型的<code>bean</code>变量此时指向了一个字符串<code>String</code>对象，该对象存放的是<code>HandlerMethod</code>代表的方法所在的<code>Handler</code>控制器的类的名称</p>
<p>而<code>beanFactory</code>实际指向了<code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code>，经查询，是一个与Spring IOC相关的类，这里应该就是根据取得的<code>Handler</code>类的名称，从IOC容器中取出注解<code>@controller</code>的<code>Handler</code>，从而将<code>HandlerMethod</code>中的<code>Bean</code>变量从指向字符串转化为指向对应的<code>Handler</code>对象</p>
<p>返回后，执行回到<code>AbstractHandlerMapping</code>的<code>getHandler</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	Object handler &#x3D; getHandlerInternal(request);</span><br><span class="line">	if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">		handler &#x3D; getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Bean name or resolved handler?</span><br><span class="line">	if (handler instanceof String) &#123;</span><br><span class="line">		String handlerName &#x3D; (String) handler;</span><br><span class="line">		handler &#x3D; getApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line">	return getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handler</code>变量接收了返回的<code>HandlerMethod</code>，如果为空，获取默认<code>Handler</code>，如果还为空，就返回null。<br>接着又对<code>handler</code>变量作了处理，最终调用<code>getHandlerExecutionChain(handler, request)</code>来获取我们最终需要的<code>HandlerExecutionChain</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</span><br><span class="line">	HandlerExecutionChain chain &#x3D; (handler instanceof HandlerExecutionChain ?</span><br><span class="line">			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));</span><br><span class="line">	chain.addInterceptors(getAdaptedInterceptors());</span><br><span class="line"></span><br><span class="line">	String lookupPath &#x3D; this.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">	for (MappedInterceptor mappedInterceptor : this.mappedInterceptors) &#123;</span><br><span class="line">		if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</span><br><span class="line">			chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步对传进来的<code>handler</code>变量进行判断，是否属于类<code>HandlerExecutionChain</code>，如果是的话直接返回，否则用它作为形参调用构造方法创建一个<code>HandlerExecution</code>对象。</p>
<p>然后给它添加拦截器，根据当前查找到的<code>lookupPath</code>，也就是<code>ServletPath</code>，将配置了与<code>lookupPath</code>相关的拦截器添加到<code>HandlerMethod</code>中，然后返回</p>
<h3 id="获取HandlerAdapter"><a href="#获取HandlerAdapter" class="headerlink" title="获取HandlerAdapter"></a>获取HandlerAdapter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Determine handler adapter for the current request.</span><br><span class="line">HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<p>为当前请求获取一个handler adapter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;</span><br><span class="line">	for (HandlerAdapter ha : this.handlerAdapters) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (ha.supports(handler)) &#123;</span><br><span class="line">			return ha;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	throw new ServletException(&quot;No adapter for handler [&quot; + handler +</span><br><span class="line">			&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，Spring Mvc也配置了三种HandlerAdapter</p>
<p><img src="https://github.com/sinaill/pic/blob/master/handlerAdapter.PNG?raw=true" alt=""></p>
<p>遍历，依次检测<code>handler</code>，也就是<code>HandlerMethod</code>对象，三种<code>HandlerAdapter</code>对应了三种不同的配置方式，Demo中配置方式为@Controller和@ReqeustMapping注解实现</p>
<p>所以接下来查看<code>AbstractHandlerMethodAdapter</code>的<code>supports</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final boolean supports(Object handler) &#123;</span><br><span class="line">	return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断传入的<code>handler</code>是否属于<code>HandlerMethod</code>，由于<code>handler</code>是来自<code>mappedHandler.getHandler()</code>，<br>所以直接返回<code>handler</code></p>
<p>而<code>supportsInternal((HandlerMethod) handler)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected boolean supportsInternal(HandlerMethod handlerMethod) &#123;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以直接返回<code>RequestMappingHandlerAdapter</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E7%9A%84@ModelAttribute%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E7%9A%84@ModelAttribute%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/" itemprop="url">SpringMVC的@ModelAttribute注解原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ModelAttribute注解的方法给模型中添加数据"><a href="#ModelAttribute注解的方法给模型中添加数据" class="headerlink" title="@ModelAttribute注解的方法给模型中添加数据"></a>@ModelAttribute注解的方法给模型中添加数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ModelAndView invokeHandleMethod(HttpServletRequest request,</span><br><span class="line">		HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest &#x3D; new ServletWebRequest(request, response);</span><br><span class="line"></span><br><span class="line">	WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);</span><br><span class="line">	ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">	ServletInvocableHandlerMethod requestMappingMethod &#x3D; createRequestMappingMethod(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">	ModelAndViewContainer mavContainer &#x3D; new ModelAndViewContainer();</span><br><span class="line">	mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">	modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</span><br><span class="line">	mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">	AsyncWebRequest asyncWebRequest &#x3D; WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">	asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">	final WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">	asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">	asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">	asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">	asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">	if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">		Object result &#x3D; asyncManager.getConcurrentResult();</span><br><span class="line">		mavContainer &#x3D; (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">		asyncManager.clearConcurrentResult();</span><br><span class="line"></span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		requestMappingMethod &#x3D; requestMappingMethod.wrapConcurrentResult(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"></span><br><span class="line">	if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在<code>RequestMappingHandlerAdapter</code>执行目标<code>Controller</code>的方法的主要流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ModelFactory modelFactory &#x3D; getModelFactory(handlerMethod, binderFactory);</span><br></pre></td></tr></table></figure>

<p>这里创建了<code>ModelFactory</code>，里面有注入<code>@ModelAttribute</code>注解了的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</span><br></pre></td></tr></table></figure>

<p>后面用这个来初始化<code>Model</code></p>
<p>可以看源码，是怎么初始化的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, ?&gt; sessionAttributes &#x3D; this.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">	mavContainer.mergeAttributes(sessionAttributes);</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	invokeModelAttributeMethods(request, mavContainer);</span><br><span class="line"></span><br><span class="line">	for (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line">		if (!mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">			Object value &#x3D; this.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line">			if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">				throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			mavContainer.addAttribute(name, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>invokeModelAttributeMethods</code>，这里是调用<code>@ModelAttribute</code>注解的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	while (!this.modelMethods.isEmpty()) &#123;</span><br><span class="line">		InvocableHandlerMethod attrMethod &#x3D; getNextModelMethod(mavContainer).getHandlerMethod();</span><br><span class="line">		String modelName &#x3D; attrMethod.getMethodAnnotation(ModelAttribute.class).value();</span><br><span class="line">		if (mavContainer.containsAttribute(modelName)) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object returnValue &#x3D; attrMethod.invokeForRequest(request, mavContainer);</span><br><span class="line"></span><br><span class="line">		if (!attrMethod.isVoid())&#123;</span><br><span class="line">			String returnValueName &#x3D; getNameForReturnValue(returnValue, attrMethod.getReturnType());</span><br><span class="line">			if (!mavContainer.containsAttribute(returnValueName)) &#123;</span><br><span class="line">				mavContainer.addAttribute(returnValueName, returnValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有返回值时"><a href="#有返回值时" class="headerlink" title="有返回值时"></a>有返回值时</h4><p>当<code>@ModelAttribute</code>注解的方法的返回值类型不为<code>void</code>时，也就是有返回值时，这里的<code>returnValueName</code>的命名规则可以看<code>getNameForReturnValue</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Derive the model attribute name for the given return value using one of:</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> * 	&lt;li&gt;The method &#123;@code ModelAttribute&#125; annotation value</span><br><span class="line"> * 	&lt;li&gt;The declared return type if it is more specific than &#123;@code Object&#125;</span><br><span class="line"> * 	&lt;li&gt;The actual return value type</span><br><span class="line"> * &lt;&#x2F;ol&gt;</span><br><span class="line"> * @param returnValue the value returned from a method invocation</span><br><span class="line"> * @param returnType the return type of the method</span><br><span class="line"> * @return the model name, never &#123;@code null&#125; nor empty</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String getNameForReturnValue(Object returnValue, MethodParameter returnType) &#123;</span><br><span class="line">	ModelAttribute annotation &#x3D; returnType.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line">	if (annotation !&#x3D; null &amp;&amp; StringUtils.hasText(annotation.value())) &#123;</span><br><span class="line">		return annotation.value();</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		Method method &#x3D; returnType.getMethod();</span><br><span class="line">		Class&lt;?&gt; resolvedType &#x3D; GenericTypeResolver.resolveReturnType(method, returnType.getContainingClass());</span><br><span class="line">		return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static String getVariableNameForReturnType(Method method, Class&lt;?&gt; resolvedType, Object value) &#123;</span><br><span class="line">	Assert.notNull(method, &quot;Method must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	if (Object.class.equals(resolvedType)) &#123;</span><br><span class="line">		if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Cannot generate variable name for an Object return type with null value&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return getVariableName(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt; valueClass;</span><br><span class="line">	boolean pluralize &#x3D; false;</span><br><span class="line"></span><br><span class="line">	if (resolvedType.isArray()) &#123;</span><br><span class="line">		valueClass &#x3D; resolvedType.getComponentType();</span><br><span class="line">		pluralize &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Collection.class.isAssignableFrom(resolvedType)) &#123;</span><br><span class="line">		valueClass &#x3D; GenericCollectionTypeResolver.getCollectionReturnType(method);</span><br><span class="line">		if (valueClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">			if (!(value instanceof Collection)) &#123;</span><br><span class="line">				throw new IllegalArgumentException(</span><br><span class="line">						&quot;Cannot generate variable name for non-typed Collection return type and a non-Collection value&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			Collection&lt;?&gt; collection &#x3D; (Collection&lt;?&gt;) value;</span><br><span class="line">			if (collection.isEmpty()) &#123;</span><br><span class="line">				throw new IllegalArgumentException(</span><br><span class="line">						&quot;Cannot generate variable name for non-typed Collection return type and an empty Collection value&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			Object valueToCheck &#x3D; peekAhead(collection);</span><br><span class="line">			valueClass &#x3D; getClassForValue(valueToCheck);</span><br><span class="line">		&#125;</span><br><span class="line">		pluralize &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		valueClass &#x3D; resolvedType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String name &#x3D; ClassUtils.getShortNameAsProperty(valueClass);</span><br><span class="line">	return (pluralize ? pluralize(name) : name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到命名规则为</p>
<ul>
<li>取方法上<code>@ModelAttribute</code>注解的<code>value</code>值</li>
<li>直接取返回的值的类型<code>Class</code>的全限定名最后一个<code>.</code>之后的字符，但是当返回值的类型为<code>Object</code>时，要取其实际类型</li>
<li>返回值的类型为<code>Array</code>或者<code>Collection</code>，获取其中的值的类型的全限定名<code>.</code>后面的字符，然后在后面继续拼接<code>List</code></li>
</ul>
<p>然后看<code>mavContainer</code>中是否已经含有该属性名称的属性，如果没有的话，将该属性添加进去，否则则什么都不做</p>
<h4 id="没有返回值"><a href="#没有返回值" class="headerlink" title="没有返回值"></a>没有返回值</h4><p><code>@ModelAttribute</code>注解的方法不用返回值往模型<code>mavContainer</code>中添加数据的方法是在入参中定义一个<code>java.util.Map</code>类型的入参</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public void test(Map map)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在目标方法也定义一个入参<code>java.util.Map</code>，就能在方法中在这个入参里获取到我们之前在<code>@ModelAttribute</code>方法中添加的属性</p>
<p>从什么地方入手，我们看反射调用<code>@ModelAttribute</code>注解的方法的入参是什么</p>
<p>首先查看对入参类型为<code>java.util.Map</code>时选择的参数解析器<code>ArgumentResolver</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (this.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		args[i] &#x3D; this.argumentResolvers.resolveArgument(</span><br><span class="line">				parameter, mavContainer, request, this.dataBinderFactory);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择的参数解析器<code>ArgumentResolver</code>为<code>MapMethodProcessor</code></p>
<p>我们查看它的<code>supportsParameter</code>方法和<code>resolveArgument</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">	return Map.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,</span><br><span class="line">		NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	return mavContainer.getModel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到适用于入参为<code>Java.util.Map</code>的时候，所以<code>ModelMap</code>和<code>Model</code>也行</p>
<p>我们看它是怎么解析的，直接返回了<code>mavContainer</code>中的<code>BindingAwareModelMap</code>对象，也就是说我们在执行<code>Controller</code>中的方法的时候，入参为<code>java.util.Map</code>的时候，都回被解析成<code>mavContainer</code>中的<code>BindingAwareModelMap</code>，所以我们能在不同方法中使用同一个<code>java.util.Map</code>入参来共享变量，估计<code>@InitBinder</code>方法也可以这样</p>
<h3 id="与-SessionAttributes合用"><a href="#与-SessionAttributes合用" class="headerlink" title="与@SessionAttributes合用"></a>与@SessionAttributes合用</h3><p>在执行<code>@ModelAttribute</code>的方法之前，还有对<code>@SessionAttributes</code>注解属性的行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, ?&gt; sessionAttributes &#x3D; this.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">	mavContainer.mergeAttributes(sessionAttributes);</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	invokeModelAttributeMethods(request, mavContainer);</span><br><span class="line"></span><br><span class="line">	for (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line">		if (!mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">			Object value &#x3D; this.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line">			if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">				throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			mavContainer.addAttribute(name, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>Controller</code>类上的注解<code>@SessionAttributes</code>的<code>value</code>值，当往<code>Model</code>中添加属性时，属性名与这个<code>value</code>值相同时，会被放入<code>Session</code>中，然后这里会以<code>@SessionAttributes</code>注解的值为<code>key</code>，从<code>Session</code>中取出，合并到<code>mavContainer</code>的<code>BindingAwareModelMap</code>中</p>
<p>然后看调用<code>@ModelAttribute</code>方法之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	while (!this.modelMethods.isEmpty()) &#123;</span><br><span class="line">		InvocableHandlerMethod attrMethod &#x3D; getNextModelMethod(mavContainer).getHandlerMethod();</span><br><span class="line">		String modelName &#x3D; attrMethod.getMethodAnnotation(ModelAttribute.class).value();</span><br><span class="line">		if (mavContainer.containsAttribute(modelName)) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object returnValue &#x3D; attrMethod.invokeForRequest(request, mavContainer);</span><br><span class="line"></span><br><span class="line">		if (!attrMethod.isVoid())&#123;</span><br><span class="line">			String returnValueName &#x3D; getNameForReturnValue(returnValue, attrMethod.getReturnType());</span><br><span class="line">			if (!mavContainer.containsAttribute(returnValueName)) &#123;</span><br><span class="line">				mavContainer.addAttribute(returnValueName, returnValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先获取了<code>@ModelAttribute</code>的<code>value</code>，如果<code>BindingAwareModelMap</code>中已经有与<code>value</code>相同的<code>key</code>，则跳过这个<code>@ModelAttribute</code>方法的调用</p>
<p>还有一个特殊的用法，可以在<code>Controller</code>方法中使用<code>@ModelAttribute</code>注解入参，它的<code>value</code>与<code>SessionAttribute</code>的<code>value</code>相同时，这个入参也可以接收到<code>Session</code>中的属性</p>
<p>它的原理在于，我们看处理<code>@ModelAttribute</code>注解参数的处理解析器<code>ModelAttributeMethodProcessor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,</span><br><span class="line">		NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	String name &#x3D; ModelFactory.getNameForParameter(parameter);</span><br><span class="line">	Object attribute &#x3D; (mavContainer.containsAttribute(name) ?</span><br><span class="line">			mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));</span><br><span class="line"></span><br><span class="line">	WebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, attribute, name);</span><br><span class="line">	if (binder.getTarget() !&#x3D; null) &#123;</span><br><span class="line">		bindRequestParameters(binder, webRequest);</span><br><span class="line">		validateIfApplicable(binder, parameter);</span><br><span class="line">		if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">			throw new BindException(binder.getBindingResult());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Add resolved attribute and BindingResult at the end of the model</span><br><span class="line">	Map&lt;String, Object&gt; bindingResultModel &#x3D; binder.getBindingResult().getModel();</span><br><span class="line">	mavContainer.removeAttributes(bindingResultModel);</span><br><span class="line">	mavContainer.addAllAttributes(bindingResultModel);</span><br><span class="line"></span><br><span class="line">	return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它先获取了入参<code>@ModelAttribute</code>的<code>value</code>，然后如果<code>BindingAwareModelMap</code>有与该值相同的<code>key</code>，取出该属性<code>attribute</code>，后面就是将<code>request</code>请求中的属性绑定到这个<code>attribute</code>了，然后这个<code>attribute</code>就作为调用该<code>Controller</code>方法的参数来反射调用</p>
<p>此时在整个流程中，在完成以上动作前，<code>@ModelAttribute</code>方法已经执行完了，所以已经完成了将<code>Session</code>中属性合并到<code>BindingAwareModelMap</code>中</p>
<p>其实一般入参分两种情况，属于简单类的，例如<code>CharSequence</code>、<code>Number</code>、<code>Date</code>、<code>Class</code>，是由<code>RequestParamMethodArgumentResolver</code>这个类负责解析，其他复杂类，例如我们自定义的类，和用<code>@ModelAttribute</code>注解的入参都是由<code>ServletModelAttributeMethodProcessor</code>负责处理</p>
<p>所以复杂类入参没有<code>@ModelAttribute</code>注解也可以接收到<code>Session</code>中属性</p>
<p>但是如果我们要这样使用<code>@SessionAttributes</code>和<code>@ModelAttribute</code>的话，注意以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, ?&gt; sessionAttributes &#x3D; this.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">	mavContainer.mergeAttributes(sessionAttributes);</span><br><span class="line"></span><br><span class="line">	invokeModelAttributeMethods(request, mavContainer);</span><br><span class="line"></span><br><span class="line">	for (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line">		if (!mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">			Object value &#x3D; this.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line">			if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">				throw new HttpSessionRequiredException(&quot;Expected session attribute &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			mavContainer.addAttribute(name, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private List&lt;String&gt; findSessionAttributeArguments(HandlerMethod handlerMethod) &#123;</span><br><span class="line">	List&lt;String&gt; result &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">	for (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">		if (parameter.hasParameterAnnotation(ModelAttribute.class)) &#123;</span><br><span class="line">			String name &#x3D; getNameForParameter(parameter);</span><br><span class="line">			if (this.sessionAttributesHandler.isHandlerSessionAttribute(name, parameter.getParameterType())) &#123;</span><br><span class="line">				result.add(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static String getNameForParameter(MethodParameter parameter) &#123;</span><br><span class="line">	ModelAttribute annot &#x3D; parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">	String attrName &#x3D; (annot !&#x3D; null) ? annot.value() : null;</span><br><span class="line">	return StringUtils.hasText(attrName) ? attrName :  Conventions.getVariableNameForParameter(parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到执行完<code>@ModelAttribute</code>方法之后，在执行<code>Controller</code>目标方法之前，它要判断<code>BindingAwareModelMap</code>中对应的那个属性是否为空，空的话会抛出异常</p>
<p>也就是说要这样用的话，要保证在<code>@ModelAttribute</code>方法中就将要传递的属性和与<code>@SessionAttributes</code>和入参<code>@ModelAttribute</code>对应的属性名放入<code>BindingAwareModelMap</code>中，或者已经在<code>Session</code>中含有该属性和对应属性名，然后会在调用<code>@ModelAttribute</code>方法前被合并到<code>BindingAwareModelMap</code>中，否则会抛出异常</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81/" itemprop="url">SpringMVC拦截器运行流程源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HandlerInterceptorAdapter"><a href="#HandlerInterceptorAdapter" class="headerlink" title="HandlerInterceptorAdapter"></a>HandlerInterceptorAdapter</h3><p><code>HandlerInterceptorAdapter</code>是SpringMvc给我们用来实现拦截器的抽象类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * This implementation always returns &#123;@code true&#125;.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * This implementation is empty.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void postHandle(</span><br><span class="line">			HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * This implementation is empty.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void afterCompletion(</span><br><span class="line">			HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * This implementation is empty.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void afterConcurrentHandlingStarted(</span><br><span class="line">			HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preHandle"><a href="#preHandle" class="headerlink" title="preHandle"></a>preHandle</h3><p>SpringMvc执行拦截器<code>preHandle</code>方法</p>
<p>在<code>DispatcherServlet</code>中执行拦截器的<code>preHandle</code>方法，刚好在<code>Handler</code>方法被执行前执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟入<code>HandlerExecutionChain</code>的<code>applyPreHandle</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">	HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">	if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">			HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">			if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">				triggerAfterCompletion(request, response, null);</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			this.interceptorIndex &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getInterceptors</code>方法获取<code>HandlerExecutionChain</code>中的拦截器数组<code>interceptors</code>，按照配置顺序从前到后执行拦截器的<code>preHandle</code>方法，如果有拦截器返回的结果为<code>false</code>，则进入<code>triggerAfterCompletion</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Trigger afterCompletion callbacks on the mapped HandlerInterceptors.</span><br><span class="line"> * Will just invoke afterCompletion for all interceptors whose preHandle invocation</span><br><span class="line"> * has successfully completed and returned true.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">	if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">			try &#123;</span><br><span class="line">				interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex2) &#123;</span><br><span class="line">				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从英文注释中看出这个方法会在所有拦截器被成功执行并且返回<code>true</code>时触发，从<code>applyPreHandle</code>方法可以看到，当有拦截器返回了<code>false</code>时，这个方法也会被触发，然后执行所有拦截器的<code>afterCompletion</code>方法</p>
<h3 id="applyPostHandle"><a href="#applyPostHandle" class="headerlink" title="applyPostHandle"></a>applyPostHandle</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure>

<p><code>applyPostHandle</code>方法在执行完<code>Handler</code>的目标方法后被执行，所以形参中有类型为<code>ModelAndView</code>变量<code>mv</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">	HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">	if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">			interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到获取到拦截器数组<code>interceptors</code>后，是从高位往地位顺序执行拦截器的<code>postHandle</code>方法，在其中，我们可以对<code>Handler</code>返回的视图<code>ModelAndView</code>进行修改</p>
<h3 id="triggerAfterCompletion"><a href="#triggerAfterCompletion" class="headerlink" title="triggerAfterCompletion"></a>triggerAfterCompletion</h3><p><code>triggerAfterCompletion</code>的调用是在<code>processDispatchResult</code>方法里，在渲染完视图之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	HandlerInterceptor[] interceptors &#x3D; getInterceptors();</span><br><span class="line">	if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">		for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			HandlerInterceptor interceptor &#x3D; interceptors[i];</span><br><span class="line">			try &#123;</span><br><span class="line">				interceptor.afterCompletion(request, response, this.handler, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex2) &#123;</span><br><span class="line">				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完拦截器的<code>applyHandle</code>，处理器<code>Controller Handler</code>的方法，然后执行<code>postHandle</code>方法，再渲染视图，最后调用这个方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E5%AF%B9Controller%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Emav%E7%9A%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E5%AF%B9Controller%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Emav%E7%9A%84%E5%A4%84%E7%90%86/" itemprop="url">SpringMVC对Controller目标方法返回mav的处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>在<code>DispatchServlet</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>

<p>执行完<code>Controller</code>的目标方法后，然后一个带有<code>Model</code>和<code>view</code>的<code>ModelAndView</code>对象</p>
<p>接下来就是对视图的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">applyDefaultViewName(request, mv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void applyDefaultViewName(HttpServletRequest request, ModelAndView mv) throws Exception &#123;</span><br><span class="line">	if (mv !&#x3D; null &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">		mv.setViewName(getDefaultViewName(request));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断当<code>ModelAndView</code>对象中的<code>view</code>为空时，设置默认视图名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String getViewName(HttpServletRequest request) &#123;</span><br><span class="line">	String lookupPath &#x3D; this.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">	return (this.prefix + transformPath(lookupPath) + this.suffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是设置默认视图名的代码段，这里获取的<code>lookupPath</code>为<code>getServletPath()</code>的返回结果，也就是除了项目名名以外的后面部分，<code>transformPath</code>方法的作用是将<code>lookupPath</code>的前后的<code>/</code>去掉，然后将最后一个<code>.</code>和后面的字符去掉，取剩余的部分</p>
<p>然后开始处理视图结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">		HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	boolean errorView &#x3D; false;</span><br><span class="line"></span><br><span class="line">	if (exception !&#x3D; null) &#123;</span><br><span class="line">		if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">			logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">			mv &#x3D; ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			Object handler &#x3D; (mappedHandler !&#x3D; null ? mappedHandler.getHandler() : null);</span><br><span class="line">			mv &#x3D; processHandlerException(request, response, handler, exception);</span><br><span class="line">			errorView &#x3D; (mv !&#x3D; null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Did the handler return a view to render?</span><br><span class="line">	if (mv !&#x3D; null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">		render(mv, request, response);</span><br><span class="line">		if (errorView) &#123;</span><br><span class="line">			WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &#39;&quot; + getServletName() +</span><br><span class="line">					&quot;&#39;: assuming HandlerAdapter completed request handling&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">		&#x2F;&#x2F; Concurrent handling started during a forward</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (mappedHandler !&#x3D; null) &#123;</span><br><span class="line">		mappedHandler.triggerAfterCompletion(request, response, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传进来的<code>excetpion</code>为<code>null</code></p>
<p>判断<code>ModelAndView</code>引用不为空，并且<code>ModelAndView</code>内部的<code>Model</code>和<code>View</code>也不为空时，开始渲染视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F; Determine locale for request and apply it to the response.</span><br><span class="line">	&#x2F;&#x2F;locale表示使用者当地语言</span><br><span class="line">	Locale locale &#x3D; this.localeResolver.resolveLocale(request);</span><br><span class="line">	response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">	View view;</span><br><span class="line">	if (mv.isReference()) &#123;</span><br><span class="line">		&#x2F;&#x2F; We need to resolve the view name.</span><br><span class="line">		view &#x3D; resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</span><br><span class="line">		if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">			throw new ServletException(&quot;Could not resolve view with name &#39;&quot; + mv.getViewName() +</span><br><span class="line">					&quot;&#39; in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; No need to lookup: the ModelAndView object contains the actual View object.</span><br><span class="line">		view &#x3D; mv.getView();</span><br><span class="line">		if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">			throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +</span><br><span class="line">					&quot;View object in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Delegate to the View object for rendering.</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		view.render(mv.getModelInternal(), request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#39;&quot; +</span><br><span class="line">					getServletName() + &quot;&#39;&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mv.isReference()</code>判断<code>ModelAndView</code>中的<code>view</code>属于<code>String</code>类型的时候，对视图进行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected View resolveViewName(String viewName, Map&lt;String, Object&gt; model, Locale locale,</span><br><span class="line">		HttpServletRequest request) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	for (ViewResolver viewResolver : this.viewResolvers) &#123;</span><br><span class="line">		View view &#x3D; viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">		if (view !&#x3D; null) &#123;</span><br><span class="line">			return view;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的视图解析器<code>viewResolver</code>来自于我们在配置文件中注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 3.配置jsp 显示ViewResolver --&gt;</span><br><span class="line">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>这里调用的<code>InternalResourceViewResolver</code>对视图名进行解析处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View resolveViewName(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">	if (!isCache()) &#123;</span><br><span class="line">		return createView(viewName, locale);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		Object cacheKey &#x3D; getCacheKey(viewName, locale);</span><br><span class="line">		View view &#x3D; this.viewAccessCache.get(cacheKey);</span><br><span class="line">		if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">			synchronized (this.viewCreationCache) &#123;</span><br><span class="line">				view &#x3D; this.viewCreationCache.get(cacheKey);</span><br><span class="line">				if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">					&#x2F;&#x2F; Ask the subclass to create the View object.</span><br><span class="line">					view &#x3D; createView(viewName, locale);</span><br><span class="line">					if (view &#x3D;&#x3D; null &amp;&amp; this.cacheUnresolved) &#123;</span><br><span class="line">						view &#x3D; UNRESOLVED_VIEW;</span><br><span class="line">					&#125;</span><br><span class="line">					if (view !&#x3D; null) &#123;</span><br><span class="line">						this.viewAccessCache.put(cacheKey, view);</span><br><span class="line">						this.viewCreationCache.put(cacheKey, view);</span><br><span class="line">						if (logger.isTraceEnabled()) &#123;</span><br><span class="line">							logger.trace(&quot;Cached view [&quot; + cacheKey + &quot;]&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return (view !&#x3D; UNRESOLVED_VIEW ? view : null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面是对于缓存的处理，然后是<code>createView(viewName, locale)</code>创建视图对象<code>View</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected View createView(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F; If this resolver is not supposed to handle the given view,</span><br><span class="line">	&#x2F;&#x2F; return null to pass on to the next resolver in the chain.</span><br><span class="line">	if (!canHandle(viewName, locale)) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Check for special &quot;redirect:&quot; prefix.</span><br><span class="line">	if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">		String redirectUrl &#x3D; viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">		RedirectView view &#x3D; new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());</span><br><span class="line">		return applyLifecycleMethods(viewName, view);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Check for special &quot;forward:&quot; prefix.</span><br><span class="line">	if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">		String forwardUrl &#x3D; viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">		return new InternalResourceView(forwardUrl);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; Else fall back to superclass implementation: calling loadView.</span><br><span class="line">	return super.createView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看<code>canHandle(viewName, locale)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected boolean canHandle(String viewName, Locale locale) &#123;</span><br><span class="line">	String[] viewNames &#x3D; getViewNames();</span><br><span class="line">	return (viewNames &#x3D;&#x3D; null || PatternMatchUtils.simpleMatch(viewNames, viewName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串数组<code>viewNames</code>也是在配置<code>InternalResourceViewResolver</code>的时候配置好的，根据这个决定是否处理这个视图</p>
<p>然后可以看到这里根据视图前缀创建不同类型的视图对象<code>View</code>，分别是以<code>redirect:</code>开头的重定向<code>RedirectView</code>，以<code>forward:</code>开头的内部转发<code>InternalResourceView</code>，和第三种没有前缀的如下，调用了父类的<code>createView</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected View createView(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">	return loadView(viewName, locale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected View loadView(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">	AbstractUrlBasedView view &#x3D; buildView(viewName);</span><br><span class="line">	View result &#x3D; applyLifecycleMethods(viewName, view);</span><br><span class="line">	return (view.checkResource(locale) ? result : null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123;</span><br><span class="line">	InternalResourceView view &#x3D; (InternalResourceView) super.buildView(viewName);</span><br><span class="line">	if (this.alwaysInclude !&#x3D; null) &#123;</span><br><span class="line">		view.setAlwaysInclude(this.alwaysInclude);</span><br><span class="line">	&#125;</span><br><span class="line">	view.setPreventDispatchLoop(true);</span><br><span class="line">	return view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123;</span><br><span class="line">	AbstractUrlBasedView view &#x3D; (AbstractUrlBasedView) BeanUtils.instantiateClass(getViewClass());</span><br><span class="line">	view.setUrl(getPrefix() + viewName + getSuffix());</span><br><span class="line"></span><br><span class="line">	String contentType &#x3D; getContentType();</span><br><span class="line">	if (contentType !&#x3D; null) &#123;</span><br><span class="line">		view.setContentType(contentType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	view.setRequestContextAttribute(getRequestContextAttribute());</span><br><span class="line">	view.setAttributesMap(getAttributesMap());</span><br><span class="line">	&#x2F;&#x2F;决定是否将PathVariable合并到Model中</span><br><span class="line">	Boolean exposePathVariables &#x3D; getExposePathVariables();</span><br><span class="line">	if (exposePathVariables !&#x3D; null) &#123;</span><br><span class="line">		view.setExposePathVariables(exposePathVariables);</span><br><span class="line">	&#125;</span><br><span class="line">	Boolean exposeContextBeansAsAttributes &#x3D; getExposeContextBeansAsAttributes();</span><br><span class="line">	if (exposeContextBeansAsAttributes !&#x3D; null) &#123;</span><br><span class="line">		view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] exposedContextBeanNames &#x3D; getExposedContextBeanNames();</span><br><span class="line">	if (exposedContextBeanNames !&#x3D; null) &#123;</span><br><span class="line">		view.setExposedContextBeanNames(exposedContextBeanNames);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getViewClass()</code>获取配置文件中<code>InternalResourceViewResolver</code>中的<code>viewClass</code>，这里我们配置的是<code>JstlView</code>，这里用反射的方式实例化，<code>getPrefix()</code>和<code>getSuffix()</code>对应我们配置的前后缀，来拼凑成有效的<code>url</code>，后面的都是读取<code>InternalResourceViewResolver</code>中配置的属性来初始化<code>JstlView</code></p>
<p>此外我们看到创建好视图后，还对视图进行了一些处理<code>applyLifecycleMethods(viewName, view)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private View applyLifecycleMethods(String viewName, AbstractView view) &#123;</span><br><span class="line">	return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>JstlView</code>实现了<code>BeanNameAware</code>接口，所以这里将<code>viewName</code>设置到<code>view</code>的<code>BeanName</code>属性中，然后还将<code>applicationContext</code>注入到<code>View</code>中，还没看<code>Spring</code>，这里跳过</p>
<p>回到<code>DispatchServlet</code>的<code>render</code>方法中，创建好视图对象之后，调用视图对象的<code>render</code>方法渲染视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">	if (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(&quot;Rendering view with name &#39;&quot; + this.beanName + &quot;&#39; with model &quot; + model +</span><br><span class="line">			&quot; and static attributes &quot; + this.staticAttributes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; mergedModel &#x3D; createMergedOutputModel(model, request, response);</span><br><span class="line">	prepareResponse(request, response);</span><br><span class="line">	renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个<code>Map</code>类型的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Map&lt;String, Object&gt; createMergedOutputModel(Map&lt;String, ?&gt; model, HttpServletRequest request,</span><br><span class="line">		HttpServletResponse response) &#123;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	Map&lt;String, Object&gt; pathVars &#x3D; (this.exposePathVariables ?</span><br><span class="line">			(Map&lt;String, Object&gt;) request.getAttribute(View.PATH_VARIABLES) : null);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Consolidate static and dynamic model attributes.</span><br><span class="line">	int size &#x3D; this.staticAttributes.size();</span><br><span class="line">	size +&#x3D; (model !&#x3D; null ? model.size() : 0);</span><br><span class="line">	size +&#x3D; (pathVars !&#x3D; null ? pathVars.size() : 0);</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; mergedModel &#x3D; new LinkedHashMap&lt;String, Object&gt;(size);</span><br><span class="line">	mergedModel.putAll(this.staticAttributes);</span><br><span class="line">	if (pathVars !&#x3D; null) &#123;</span><br><span class="line">		mergedModel.putAll(pathVars);</span><br><span class="line">	&#125;</span><br><span class="line">	if (model !&#x3D; null) &#123;</span><br><span class="line">		mergedModel.putAll(model);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Expose RequestContext?</span><br><span class="line">	if (this.requestContextAttribute !&#x3D; null) &#123;</span><br><span class="line">		mergedModel.put(this.requestContextAttribute, createRequestContext(request, response, mergedModel));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return mergedModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exposePathVariables</code>变量是我们在初始化<code>JstlView</code>的注入的，来源于<code>InternalResourceViewResolver</code>，默认为<code>true</code>，用来获取<code>url</code>中{}属性和值</p>
<p>这里合并<code>ModelAndView</code>中的<code>ModelMap</code>和<code>pathVars</code>，然后返回</p>
<p>然后使用合并之后的<code>ModelMap</code>继续渲染视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void renderMergedOutputModel(</span><br><span class="line">		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Expose the model object as request attributes.</span><br><span class="line">	exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Expose helpers as request attributes, if any.</span><br><span class="line">	exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Determine the path for the request dispatcher.</span><br><span class="line">	String dispatcherPath &#x3D; prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).</span><br><span class="line">	RequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">	if (rd &#x3D;&#x3D; null) &#123;</span><br><span class="line">		throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +</span><br><span class="line">				&quot;]: Check that the corresponding file exists within your web application archive!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; If already included or response already committed, perform include, else forward.</span><br><span class="line">	if (useInclude(request, response)) &#123;</span><br><span class="line">		response.setContentType(getContentType());</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.include(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Note: The forwarded resource is supposed to determine the content type itself.</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看<code>exposeModelAsRequestAttributes(model, request);</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	for (Map.Entry&lt;String, Object&gt; entry : model.entrySet()) &#123;</span><br><span class="line">		String modelName &#x3D; entry.getKey();</span><br><span class="line">		Object modelValue &#x3D; entry.getValue();</span><br><span class="line">		if (modelValue !&#x3D; null) &#123;</span><br><span class="line">			request.setAttribute(modelName, modelValue);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Added model object &#39;&quot; + modelName + &quot;&#39; of type [&quot; + modelValue.getClass().getName() +</span><br><span class="line">						&quot;] to request in view with name &#39;&quot; + getBeanName() + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			request.removeAttribute(modelName);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Removed model object &#39;&quot; + modelName +</span><br><span class="line">						&quot;&#39; from request in view with name &#39;&quot; + getBeanName() + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将合并之后的<code>ModelMap</code>中不为空的属性全部放入<code>request</code>中，所以我们能在<code>jsp</code>中获取到我们在<code>Controller</code>给<code>Map</code>入参中添加的属性</p>
<p><code>preventDispatchLoop</code>属性在创建<code>JstlView</code>的时候设置为了<code>true</code></p>
<p>然后看<code>prepareForRendering(request, response)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected String prepareForRendering(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	String path &#x3D; getUrl();</span><br><span class="line">	if (this.preventDispatchLoop) &#123;</span><br><span class="line">		String uri &#x3D; request.getRequestURI();</span><br><span class="line">		if (path.startsWith(&quot;&#x2F;&quot;) ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) &#123;</span><br><span class="line">			throw new ServletException(&quot;Circular view path [&quot; + path + &quot;]: would dispatch back &quot; +</span><br><span class="line">					&quot;to the current handler URL [&quot; + uri + &quot;] again. Check your ViewResolver setup! &quot; +</span><br><span class="line">					&quot;(Hint: This may be the result of an unspecified view, due to default view name generation.)&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getUrl</code>返回我们创建视图传入的目的资源的<code>url</code></p>
<p><code>request.getRequestURI</code>返回的结果是<code>/</code>+项目名称+剩余<code>uri</code></p>
<p>这里要防止当前<code>url</code>和跳转后的<code>url</code>相同变成死循环，检测到相同时抛出异常</p>
<p>注意到<code>StringUtils.applyRelativePath(uri, path))</code>，应该是和拼接最终<code>url</code>相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String applyRelativePath(String path, String relativePath) &#123;</span><br><span class="line">	int separatorIndex &#x3D; path.lastIndexOf(FOLDER_SEPARATOR);</span><br><span class="line">	if (separatorIndex !&#x3D; -1) &#123;</span><br><span class="line">		String newPath &#x3D; path.substring(0, separatorIndex);</span><br><span class="line">		if (!relativePath.startsWith(FOLDER_SEPARATOR)) &#123;</span><br><span class="line">			newPath +&#x3D; FOLDER_SEPARATOR;</span><br><span class="line">		&#125;</span><br><span class="line">		return newPath + relativePath;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return relativePath;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接路径的方式为原本请求路径中去掉最后一个<code>/</code>和后面的字符，当第二个值不存在<code>/</code>，也就是<code>url</code>中项目名和后面的字符全为空，这里则直接返回创建好的视图的<code>url</code>，否则去掉最后一个<code>/</code>和后面的字符，然后拼接上我们视图的<code>url</code></p>
<p>回到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void renderMergedOutputModel(</span><br><span class="line">		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Expose the model object as request attributes.</span><br><span class="line">	exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Expose helpers as request attributes, if any.</span><br><span class="line">	exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Determine the path for the request dispatcher.</span><br><span class="line">	String dispatcherPath &#x3D; prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Obtain a RequestDispatcher for the target resource (typically a JSP).</span><br><span class="line">	RequestDispatcher rd &#x3D; getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">	if (rd &#x3D;&#x3D; null) &#123;</span><br><span class="line">		throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +</span><br><span class="line">				&quot;]: Check that the corresponding file exists within your web application archive!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; If already included or response already committed, perform include, else forward.</span><br><span class="line">	if (useInclude(request, response)) &#123;</span><br><span class="line">		response.setContentType(getContentType());</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.include(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Note: The forwarded resource is supposed to determine the content type itself.</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.forward(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下最后一个判断<code>useInclude(request, response)</code>，查了下，<code>include</code>的作用应该是属于内嵌的一种，就是将另一个servlet/jsp处理过后的内容拿过来与本身的servlet的内容一同输出</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>当<code>ModelAndView</code>的<code>View</code>为<code>null</code>时，取默认视图名，该视图名与当前<code>url</code>有关</p>
</li>
<li><p>获取配置好的<code>InternalResourceViewResolver</code>，用来解析处理<code>ModelAndView</code>中的<code>View</code>(Object类型)</p>
</li>
<li><p>根据<code>View</code>前缀决定创建的<code>View</code>视图对象的类型</p>
</li>
<li><p>将<code>@PathVariable</code>的属性和<code>ModelAndView</code>的<code>Model</code>合并</p>
</li>
<li><p>不是重定向时，将合并后的<code>Model</code>的值放入<code>request</code>中，然后跳转</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMvc%E4%B8%ADHandler%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMvc%E4%B8%ADHandler%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C/" itemprop="url">SpringMVC中Handler方法的执行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="需要注意的类"><a href="#需要注意的类" class="headerlink" title="需要注意的类"></a>需要注意的类</h3><h4 id="invocableHandlerMethod"><a href="#invocableHandlerMethod" class="headerlink" title="invocableHandlerMethod"></a>invocableHandlerMethod</h4><h4 id="HandlerMethodParameter"><a href="#HandlerMethodParameter" class="headerlink" title="HandlerMethodParameter"></a>HandlerMethodParameter</h4><p><code>HandlerMethodParameter</code>为<code>HandlerMethod</code>的内部类和<code>MethodParameter</code>的子类</p>
<p>先看<code>MethodParameter</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final Method method</span><br><span class="line">&#x2F;&#x2F;指向方法</span><br><span class="line">private final int parameterIndex;</span><br><span class="line">&#x2F;&#x2F;本方法参数在方法中的形参位置index，从0开始</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="argumentResolver"><a href="#argumentResolver" class="headerlink" title="argumentResolver"></a>argumentResolver</h4><p>创建<code>InvocableHandlerMethod</code>的时候，将<code>Spring</code>给<code>RequestMappingHandlerAdapter</code>注入的<code>argumentResovlers</code>参数传递给<code>InvocableHandlerMethod</code>，用来对通过<code>GenericTypeResolver</code>确定方法参数类型之后的<code>MethodParameter</code>进行处理</p>
<p>例如<code>RequestParamMethodArgumentResolver</code>，它的<code>supportParameter</code>方法，即验证是否适用于当前参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">	Class&lt;?&gt; paramType &#x3D; parameter.getParameterType();</span><br><span class="line">	if (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line">		&#x2F;&#x2F;与instanceof作用相同，只不过这个是判断类之间的管理</span><br><span class="line">		&#x2F;&#x2F;判断传入的类与这个类是否相同或者是不是传入的这个类的超类或者超接口</span><br><span class="line">		if (Map.class.isAssignableFrom(paramType)) &#123;</span><br><span class="line">			String paramName &#x3D; parameter.getParameterAnnotation(RequestParam.class).value();</span><br><span class="line">			return StringUtils.hasText(paramName);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (MultipartFile.class.equals(paramType) || &quot;javax.servlet.http.Part&quot;.equals(paramType.getName())) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (this.useDefaultResolution) &#123;</span><br><span class="line">			return BeanUtils.isSimpleProperty(paramType);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><code>Handler</code>方法的执行由<code>handlerAdapter</code>接口的实现类的<code>handle</code>方法为入口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Actually invoke the handler.</span><br><span class="line">mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">本Demo中配置方式决定了&#96;ha&#96;变量为&#96;RequestMappingHandlerAdapter&#96;实例对象，调用该对象的&#96;handle&#96;方法</span><br><span class="line">，&#96;handle&#96;方法为它父类&#96;AbstractHandlerMethodAdapter&#96;中的方法</span><br></pre></td></tr></table></figure>
<p>@Override<br>public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)<br>        throws Exception {</p>
<pre><code>return handleInternal(request, response, (HandlerMethod) handler);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接着又调用该对象的&#96;handleInternal&#96;方法</span><br></pre></td></tr></table></figure>
<p>@Override<br>protected ModelAndView handleInternal(HttpServletRequest request,<br>        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {</p>
<pre><code>//判断是否有@SessionAttributes注解
if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
    // Always prevent caching in case of session attribute management.
    checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
}
else {
    // Uses configured default cacheSeconds setting.
    checkAndPrepare(request, response, true);
}

// Execute invokeHandlerMethod in synchronized block if required.
if (this.synchronizeOnSession) {
    HttpSession session = request.getSession(false);
    if (session != null) {
        Object mutex = WebUtils.getSessionMutex(session);
        synchronized (mutex) {
            return invokeHandleMethod(request, response, handlerMethod);
        }
    }
}

return invokeHandleMethod(request, response, handlerMethod);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;getSessionAttributesHandler&#96;方法</span><br></pre></td></tr></table></figure>
<p>private SessionAttributesHandler getSessionAttributesHandler(HandlerMethod handlerMethod) {<br>    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>    SessionAttributesHandler sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);<br>    if (sessionAttrHandler == null) {<br>        synchronized (this.sessionAttributesHandlerCache) {<br>            sessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);<br>            if (sessionAttrHandler == null) {<br>                sessionAttrHandler = new SessionAttributesHandler(handlerType, sessionAttributeStore);<br>                this.sessionAttributesHandlerCache.put(handlerType, sessionAttrHandler);<br>            }<br>        }<br>    }<br>    return sessionAttrHandler;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">单例模式创建&#96;SessionAttributesHandler&#96;，看构造方法</span><br></pre></td></tr></table></figure>
<p>public SessionAttributesHandler(Class&lt;?&gt; handlerType, SessionAttributeStore sessionAttributeStore) {<br>    Assert.notNull(sessionAttributeStore, “SessionAttributeStore may not be null.”);<br>    this.sessionAttributeStore = sessionAttributeStore;</p>
<pre><code>SessionAttributes annotation = AnnotationUtils.findAnnotation(handlerType, SessionAttributes.class);
if (annotation != null) {
    this.attributeNames.addAll(Arrays.asList(annotation.value()));
    this.attributeTypes.addAll(Arrays.&lt;Class&lt;?&gt;&gt;asList(annotation.types()));
}

for (String attributeName : this.attributeNames) {
    this.knownAttributeNames.add(attributeName);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查看&#96;Controller&#96;有没有&#96;@SessionAttributes&#96;注解</span><br><span class="line"></span><br><span class="line">把注解中的&#96;value&#96;值放入成员变量&#96;knownAttributeNames&#96;集合中</span><br><span class="line"></span><br><span class="line">跟入&#96;invokeHandleMethod&#96;</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li><p>Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}</p>
</li>
<li><p>if view resolution is required.</p>
</li>
<li><p>/<br>private ModelAndView invokeHandleMethod(HttpServletRequest request,</p>
<pre><code>HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {</code></pre><p>  ServletWebRequest webRequest = new ServletWebRequest(request, response);</p>
<p>  WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);<br>  ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);<br>  ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</p>
<p>  ModelAndViewContainer mavContainer = new ModelAndViewContainer();<br>  mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));<br>  modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);<br>  mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</p>
<p>  AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);<br>  asyncWebRequest.setTimeout(this.asyncRequestTimeout);</p>
<p>  final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<br>  asyncManager.setTaskExecutor(this.taskExecutor);<br>  asyncManager.setAsyncWebRequest(asyncWebRequest);<br>  asyncManager.registerCallableInterceptors(this.callableInterceptors);<br>  asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</p>
<p>  if (asyncManager.hasConcurrentResult()) {</p>
<pre><code>Object result = asyncManager.getConcurrentResult();
mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
asyncManager.clearConcurrentResult();

if (logger.isDebugEnabled()) {
    logger.debug(&quot;Found concurrent result value [&quot; + result + &quot;]&quot;);
}
requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</code></pre><p>  }</p>
<p>  requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</p>
<p>  if (asyncManager.isConcurrentHandlingStarted()) {</p>
<pre><code>return null;</code></pre><p>  }</p>
<p>  return getModelAndView(mavContainer, modelFactory, webRequest);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">先看&#96;WebDataBinderFactory binderFactory &#x3D; getDataBinderFactory(handlerMethod);&#96;，进入&#96;getDataBinderFactory&#96;</span><br></pre></td></tr></table></figure>
<p>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {<br>  Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>  Set<Method> methods = this.initBinderCache.get(handlerType);<br>  if (methods == null) {</p>
<pre><code>methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);
this.initBinderCache.put(handlerType, methods);</code></pre><p>  }<br>  List<InvocableHandlerMethod> initBinderMethods = new ArrayList<InvocableHandlerMethod>();<br>  // Global methods first<br>  for (Entry&lt;ControllerAdviceBean, Set<Method>&gt; entry : this.initBinderAdviceCache .entrySet()) {</p>
<pre><code>if (entry.getKey().isApplicableToBeanType(handlerType)) {
    Object bean = entry.getKey().resolveBean();
    for (Method method : entry.getValue()) {
        initBinderMethods.add(createInitBinderMethod(bean, method));
    }
}</code></pre><p>  }<br>  for (Method method : methods) {</p>
<pre><code>Object bean = handlerMethod.getBean();
initBinderMethods.add(createInitBinderMethod(bean, method));</code></pre><p>  }<br>  return createDataBinderFactory(initBinderMethods);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;initBinderCache&#96;字面看是&#96;@initBinder&#96;方法的缓存，看&#96;selectMethod&#96;方法</span><br></pre></td></tr></table></figure>
<p>public static Set<Method> selectMethods(final Class<?> handlerType, final MethodFilter handlerMethodFilter) {
  final Set<Method> handlerMethods = new LinkedHashSet<Method>();
  Set<Class<?>&gt; handlerTypes = new LinkedHashSet&lt;Class<?>>();
  Class<?> specificHandlerType = null;<br>  if (!Proxy.isProxyClass(handlerType)) {</p>
<pre><code>handlerTypes.add(handlerType);
specificHandlerType = handlerType;</code></pre><p>  }<br>  handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));<br>  for (Class&lt;?&gt; currentHandlerType : handlerTypes) {</p>
<pre><code>final Class&lt;?&gt; targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);
ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
    @Override
    public void doWith(Method method) {
        Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
        Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
        if (handlerMethodFilter.matches(specificMethod) &amp;&amp;
                (bridgedMethod == specificMethod || !handlerMethodFilter.matches(bridgedMethod))) {
            handlerMethods.add(specificMethod);
        }
    }
}, ReflectionUtils.USER_DECLARED_METHODS);</code></pre><p>  }<br>  return handlerMethods;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">判断传入的&#96;handlerType&#96;是不是代理类，不是的话添加到集合&#96;handlerTypes&#96;中，再让&#96;specificHandlerYtpe&#96;指向它，如果事代理类的话，将代理类实现的接口添加到集合&#96;handlerTypes&#96;中。</span><br><span class="line">下一步对&#96;handlerTypes&#96;进行处理，当&#96;handlerType&#96;不是代理类时，这一步处理的就是&#96;handlerType&#96;本身，</span><br><span class="line">调用了类&#96;ReflectionUtils&#96;的&#96;doWithMethods&#96;方法对&#96;handlerType&#96;进行处理</span><br></pre></td></tr></table></figure>
<p>public static void doWithMethods(Class&lt;?&gt; clazz, MethodCallback mc, MethodFilter mf) {<br>  // Keep backing up the inheritance hierarchy.<br>  Method[] methods = getDeclaredMethods(clazz);<br>  for (Method method : methods) {</p>
<pre><code>if (mf != null &amp;&amp; !mf.matches(method)) {
    continue;
}
try {
    mc.doWith(method);
}
catch (IllegalAccessException ex) {
    throw new IllegalStateException(&quot;Not allowed to access method &apos;&quot; + method.getName() + &quot;&apos;: &quot; + ex);
}</code></pre><p>  }<br>  if (clazz.getSuperclass() != null) {</p>
<pre><code>doWithMethods(clazz.getSuperclass(), mc, mf);</code></pre><p>  }<br>  else if (clazz.isInterface()) {</p>
<pre><code>for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) {
    doWithMethods(superIfc, mc, mf);
}</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;mf&#96;为&#96;MethodFilter&#96;接口的实现类，作用为判断如果传入的&#96;method&#96;为非桥接方法和非&#96;Object&#96;中的方法就返回&#96;true&#96;，否则返回&#96;false&#96;。</span><br></pre></td></tr></table></figure>
<p>public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {</p>
<p>  @Override<br>  public boolean matches(Method method) {</p>
<pre><code>return (!method.isBridge() &amp;&amp; method.getDeclaringClass() != Object.class);</code></pre><p>  }<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">接着获取上一步的&#96;handlerType&#96;的方法，&#96;getDeclaredMethod&#96;获取的是类中定义的所有类型的方法，不包括从父类继承的。然后通过&#96;mf&#96;过滤掉桥接方法，然后使用&#96;mc&#96;的&#96;dowith&#96;方法遍历所有它们，&#96;mc&#96;为&#96;selectMehtod&#96;中的用匿名内部类的方法构造。</span><br></pre></td></tr></table></figure>
<p>new ReflectionUtils.MethodCallback() {<br>            @Override<br>            public void doWith(Method method) {<br>                Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);<br>                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);<br>                if (handlerMethodFilter.matches(specificMethod) &amp;&amp;<br>                        (bridgedMethod == specificMethod || !handlerMethodFilter.matches(bridgedMethod))) {<br>                    handlerMethods.add(specificMethod);<br>                }<br>            }<br>        }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中&#96;ClassUtils&#96;的&#96;getMostSpecificmethod&#96;方法，通过&#96;method&#96;查找方法名和变量名在&#96;targetClass&#96;中相同的&#96;method&#96;，&#96;BridgeMethodResolver.findBridgedMethod&#96;api的英文解释，Find the original method for the supplied bridge Method.从源码看是通过传入的桥接方法获取到Class，然后获取所有方法，匹配名字和参数个数相同的方法。接下来是&#96;handlerMethodFilter&#96;过滤器的匹配，这个过滤器定义在&#96;RequestMappingHandlerAdapter&#96;中</span><br></pre></td></tr></table></figure>
<p>public static final MethodFilter INIT_BINDER_METHODS = new MethodFilter() {</p>
<pre><code>@Override
public boolean matches(Method method) {
    return AnnotationUtils.findAnnotation(method, InitBinder.class) != null;
}</code></pre><p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">作用是查看方法是否有&#96;@initBinder&#96;注解，如果有返回&#96;true&#96;，没有就返回&#96;false&#96;，当&#96;specificMethod&#96;不是&#96;@initBinder&#96;注解的方法，切不是桥接方法或桥接方法为&#96;@initBinder&#96;方法时，将&#96;specificMethod&#96;添加到&#96;handlerMethods&#96;中，然后返回</span><br></pre></td></tr></table></figure>

<p>private WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {<br>    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>    Set<Method> methods = this.initBinderCache.get(handlerType);<br>    if (methods == null) {<br>        methods = HandlerMethodSelector.selectMethods(handlerType, INIT_BINDER_METHODS);<br>        this.initBinderCache.put(handlerType, methods);<br>    }<br>    List<InvocableHandlerMethod> initBinderMethods = new ArrayList<InvocableHandlerMethod>();<br>    // Global methods first<br>    for (Entry&lt;ControllerAdviceBean, Set<Method>&gt; entry : this.initBinderAdviceCache .entrySet()) {<br>        if (entry.getKey().isApplicableToBeanType(handlerType)) {<br>            Object bean = entry.getKey().resolveBean();<br>            for (Method method : entry.getValue()) {<br>                initBinderMethods.add(createInitBinderMethod(bean, method));<br>            }<br>        }<br>    }<br>    for (Method method : methods) {<br>        Object bean = handlerMethod.getBean();<br>        initBinderMethods.add(createInitBinderMethod(bean, method));<br>    }<br>    return createDataBinderFactory(initBinderMethods);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样返回的&#96;methods&#96;集合中就有了和当前&#96;handlerType&#96;(当前&#96;request&#96;对应的&#96;controller&#96;)对应的&#96;@initBinder&#96;方法，并且存放在了缓存&#96;initBinderCache&#96;中，&#96;initBinderAdviceCache&#96;存放的是在&#96;@controllerAdvice&#96;中的全局&#96;@initBinder&#96;方法。</span><br><span class="line"></span><br><span class="line">然后调用&#96;createInitBinderMethod&#96;方法创建一个&#96;invocableHandlerMethod&#96;</span><br></pre></td></tr></table></figure>
<p>private InvocableHandlerMethod createInitBinderMethod(Object bean, Method method) {<br>    InvocableHandlerMethod binderMethod = new InvocableHandlerMethod(bean, method);<br>    binderMethod.setHandlerMethodArgumentResolvers(this.initBinderArgumentResolvers);<br>    binderMethod.setDataBinderFactory(new DefaultDataBinderFactory(this.webBindingInitializer));<br>    binderMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);<br>    return binderMethod;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后将全局&#96;@initBinder&#96;方法和控制器中的&#96;@initBinder&#96;方法放入集合&#96;initBinderMethods&#96;中，并且用它来创建数据绑定工厂</span><br></pre></td></tr></table></figure>
<p>protected InitBinderDataBinderFactory createDataBinderFactory(List<InvocableHandlerMethod> binderMethods)<br>        throws Exception {</p>
<pre><code>return new ServletRequestDataBinderFactory(binderMethods, getWebBindingInitializer());</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">以上主要查找了控制器中和全局&#96;@initBinder&#96;方法，然后和&#96;webBindingInitializer&#96;一同创建&#96;servletRequestDataBinderFactory&#96;</span><br><span class="line"></span><br><span class="line">接下来看</span><br></pre></td></tr></table></figure>
<p>ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {<br>    SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);<br>    Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br>    Set<Method> methods = this.modelAttributeCache.get(handlerType);<br>    if (methods == null) {<br>        methods = HandlerMethodSelector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);<br>        this.modelAttributeCache.put(handlerType, methods);<br>    }<br>    List<InvocableHandlerMethod> attrMethods = new ArrayList<InvocableHandlerMethod>();<br>    // Global methods first<br>    for (Entry&lt;ControllerAdviceBean, Set<Method>&gt; entry : this.modelAttributeAdviceCache.entrySet()) {<br>        if (entry.getKey().isApplicableToBeanType(handlerType)) {<br>            Object bean = entry.getKey().resolveBean();<br>            for (Method method : entry.getValue()) {<br>                attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));<br>            }<br>        }<br>    }<br>    for (Method method : methods) {<br>        Object bean = handlerMethod.getBean();<br>        attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));<br>    }<br>    return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">主要是处理&#96;@modelAttribute&#96;注解方法</span><br><span class="line"></span><br><span class="line">&#96;getSessionAttributesHandler&#96;方法获取创建好的&#96;SessionAttributesHandler&#96;</span><br><span class="line"></span><br><span class="line">接着从当前&#96;modelAttributeCache&#96;根据当前&#96;handlerType&#96;查找集合&#96;methods&#96;</span><br></pre></td></tr></table></figure>
<p>methods = HandlerMethodSelector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">熟悉的方法，不过过滤器换成了&#96;MODEL_ATTRIBUTE_METHODS&#96;</span><br></pre></td></tr></table></figure>
<p>public static final MethodFilter MODEL_ATTRIBUTE_METHODS = new MethodFilter() {</p>
<pre><code>@Override
public boolean matches(Method method) {
    return ((AnnotationUtils.findAnnotation(method, RequestMapping.class) == null) &amp;&amp;
            (AnnotationUtils.findAnnotation(method, ModelAttribute.class) != null));
}</code></pre><p>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查找当前&#96;handlerType&#96;中没有被&#96;@requestMapping&#96;注解并且有&#96;@modelAttribute&#96;注解的方法，然后再从&#96;@controllerAdvice&#96;注解的类中也找相同的全局&#96;@modelAttribute&#96;方法，然后创建&#96;modelFactory&#96;</span><br></pre></td></tr></table></figure>
<p>ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">创建&#96;ServletInvocableHandlerMethod&#96;对象</span><br></pre></td></tr></table></figure>
<p>private ServletInvocableHandlerMethod createRequestMappingMethod(<br>        HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {</p>
<pre><code>ServletInvocableHandlerMethod requestMethod;
requestMethod = new ServletInvocableHandlerMethod(handlerMethod);
requestMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
requestMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
requestMethod.setDataBinderFactory(binderFactory);
requestMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
return requestMethod;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;argumentResolver&#96;是&#96;HandlerMethodArgumentResolver&#96;类的实例，用来做参数解析，&#96;returnValueHandlers&#96;是&#96;HandlerMethodReturnValueHandlerComposite&#96;类的实例，用来对返回结果做处理，&#96;parameterNameDiscoverer&#96;用来记录参数名解析器</span><br></pre></td></tr></table></figure>
<p>ModelAndViewContainer mavContainer = new ModelAndViewContainer();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ModelAndViewContainer主要是用来返回&#96;Model&#96;对象的，当然里面还有变量&#96;view&#96;存放视图</span><br><span class="line"></span><br><span class="line">此时&#96;Model&#96;为默认&#96;Model&#96;，是新建的&#96;BindingAwareModelMap&#96;类的实例</span><br></pre></td></tr></table></figure>
<p>modelFactory.initModel(webRequest, mavContainer, requestMappingMethod);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">文档是这样写的</span><br></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li><p>Populate the model in the following order:</p>
</li>
<li><ol></li>
<li><li>Retrieve "known" session attributes listed as {@code @SessionAttributes}.</li>
<li><li>Invoke {@code @ModelAttribute} methods</li>
<li><li>Find {@code @ModelAttribute} method arguments also listed as</li>
<li><p>{@code @SessionAttributes} and ensure they’re present in the model raising</p>
</li>
<li><p>an exception if necessary.</p>
</li>
<li></ol></li>
<li><p>@param request the current request</p>
</li>
<li><p>@param mavContainer a container with the model to be initialized</p>
</li>
<li><p>@param handlerMethod the method for which the model is initialized</p>
</li>
<li><p>@throws Exception may arise from {@code @ModelAttribute} methods</p>
</li>
<li><p>/<br>public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)</p>
<pre><code>throws Exception {</code></pre><p>  Map&lt;String, ?&gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);<br>  mavContainer.mergeAttributes(sessionAttributes);</p>
<p>  invokeModelAttributeMethods(request, mavContainer);</p>
<p>  for (String name : findSessionAttributeArguments(handlerMethod)) {</p>
<pre><code>if (!mavContainer.containsAttribute(name)) {
    Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
    if (value == null) {
        throw new HttpSessionRequiredException(&quot;Expected session attribute &apos;&quot; + name + &quot;&apos;&quot;);
    }
    mavContainer.addAttribute(name, value);
}</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当与&#96;@SessionAttribute&#96;注解的&#96;value&#96;值相同的变量名在控制器某个方法被实例化放入&#96;model&#96;中，也就是被放入&#96;Session&#96;中后，在此处会获得这个注解的变量名的属性，源码也就是变量&#96;sessionAttributesHandler&#96;中有个变量&#96;knownAttributeNames&#96;集合，存放了&#96;@SessionAttribute&#96;注解的&#96;value&#96;值，这里通过&#96;request&#96;获取&#96;Session&#96;，然后取出&#96;value&#96;对应属性</span><br><span class="line"></span><br><span class="line">然后&#96;mergeAttributes&#96;将获取到的属性复制一份放到&#96;mavContainer&#96;的&#96;model&#96;中</span><br><span class="line"></span><br><span class="line">查看&#96;invokeModelAttributeMethods&#96;方法</span><br></pre></td></tr></table></figure>
<p>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)</p>
<pre><code>throws Exception {</code></pre><p>  while (!this.modelMethods.isEmpty()) {</p>
<pre><code>InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
if (mavContainer.containsAttribute(modelName)) {
    continue;
}

Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

if (!attrMethod.isVoid()){
    String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
    if (!mavContainer.containsAttribute(returnValueName)) {
        mavContainer.addAttribute(returnValueName, returnValue);
    }
}</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">此处的&#96;modelMethods&#96;在前几步的&#96;getModelFactory&#96;中，是获取的控制器和全局&#96;@ModelAttribute&#96;方法的集合。</span><br><span class="line"></span><br><span class="line">我们看&#96;getNextModelMethod(mavContainer).getHandlerMethod()&#96;</span><br></pre></td></tr></table></figure>
<p>private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {<br>  for (ModelMethod modelMethod : this.modelMethods) {</p>
<pre><code>if (modelMethod.checkDependencies(mavContainer)) {
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Selected @ModelAttribute method &quot; + modelMethod);
    }
    this.modelMethods.remove(modelMethod);
    return modelMethod;
}</code></pre><p>  }<br>  ModelMethod modelMethod = this.modelMethods.get(0);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>logger.trace(&quot;Selected @ModelAttribute method (not present: &quot; +
        modelMethod.getUnresolvedDependencies(mavContainer)+ &quot;) &quot; + modelMethod);</code></pre><p>  }<br>  this.modelMethods.remove(modelMethod);<br>  return modelMethod;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对集合&#96;modelMethods&#96;进行遍历，查找合适条件的&#96;modelMethod&#96;，这里用的&#96;modelMethod&#96;的&#96;checkDependencies&#96;方法</span><br></pre></td></tr></table></figure>
<p>public boolean checkDependencies(ModelAndViewContainer mavContainer) {<br>  for (String name : this.dependencies) {</p>
<pre><code>if (!mavContainer.containsAttribute(name)) {
    return false;
}</code></pre><p>  }<br>  return true;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">关于&#96;ModelMethod&#96;的&#96;denpendencies&#96;变量，需要往前追溯一下变量&#96;modelMethod&#96;是怎么创建的</span><br><span class="line"></span><br><span class="line">回到&#96;getModelFactory&#96;方法</span><br></pre></td></tr></table></figure>
<p>attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">将获取到的带&#96;@ModelAttribute&#96;注解的方法&#96;method&#96;包装为&#96;InvocableHandlerMethod&#96;类型然后添加到&#96;List&lt;InvocableHandlerMethod&gt;&#96;的集合中&#96;attrMethods&#96;中，在创建&#96;ModelFactory&#96;类的实例的时候利用构造函数将其集合类型转化为&#96;List&lt;ModelMethod&gt;&#96;的集合&#96;modelMethods&#96;</span><br></pre></td></tr></table></figure>
<p>public ModelFactory(List<InvocableHandlerMethod> invocableMethods, WebDataBinderFactory dataBinderFactory,</p>
<pre><code>SessionAttributesHandler sessionAttributesHandler) {</code></pre><p>  if (invocableMethods != null) {</p>
<pre><code>for (InvocableHandlerMethod method : invocableMethods) {
    this.modelMethods.add(new ModelMethod(method));
}</code></pre><p>  }<br>  this.dataBinderFactory = dataBinderFactory;<br>  this.sessionAttributesHandler = sessionAttributesHandler;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在构造函数里，集合&#96;attrMethods&#96;中的&#96;invocableHandlerMethod&#96;类的实例被包装为&#96;ModelMethod&#96;类的实例</span><br><span class="line">&#96;new ModelMethod(method)&#96;</span><br><span class="line"></span><br><span class="line">我们看&#96;ModelMethod&#96;的构造函数是怎么处理&#96;dependencies&#96;变量的</span><br></pre></td></tr></table></figure>
<p>private ModelMethod(InvocableHandlerMethod handlerMethod) {<br>  this.handlerMethod = handlerMethod;<br>  for (MethodParameter parameter : handlerMethod.getMethodParameters()) {</p>
<pre><code>if (parameter.hasParameterAnnotation(ModelAttribute.class)) {
    this.dependencies.add(getNameForParameter(parameter));
}</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;getMethodParameters&#96;获取方法的所有参数，返回一个&#96;MethodParameter&#96;集合，接下来遍历这些参数，如果有带&#96;@ModelAttribute&#96;注解的，获取参数的名字放入类型为&#96;Set&lt;String&gt;&#96;集合的&#96;dependencies&#96;中</span><br><span class="line"></span><br><span class="line">接下来就知道&#96;checkDependencies&#96;方法是做什么的了</span><br></pre></td></tr></table></figure>
<p>public boolean checkDependencies(ModelAndViewContainer mavContainer) {<br>  for (String name : this.dependencies) {</p>
<pre><code>if (!mavContainer.containsAttribute(name)) {
    return false;
}</code></pre><p>  }<br>  return true;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;!mavContainer.containsAttribute(name)&#96;，对方法的所有参数名字遍历</span><br></pre></td></tr></table></figure>
<p>public boolean containsAttribute(String name) {<br>  return getModel().containsAttribute(name);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">以上将&#96;@ModelAttribute&#96;方法的集合做了包装，&#96;invocableHandlerMethod -&gt; ModelMethod&#96;，多了个&#96;dependencies&#96;属性，类型为&#96;Set&lt;String&gt;&#96;，用来存放当前方法中带了&#96;@ModelAttribute&#96;注解的**形参**的参数名</span><br><span class="line"></span><br><span class="line">接着遍历包装后的集合，&#96;mavContainer&#96;中的&#96;model&#96;必须拥有&#96;dependencies&#96;中所有的属性名，此时&#96;checkDependencies&#96;方法返回&#96;true&#96;，当&#96;ModelMethod&#96;的&#96;dependencies&#96;为空时，也返回&#96;true&#96;，其他返回&#96;false&#96;</span><br><span class="line"></span><br><span class="line">回到变量&#96;ModelFactory&#96;的&#96;getNextModelMethod(mavContainer).getHandlerMethod()&#96;</span><br></pre></td></tr></table></figure>
<p>private ModelMethod getNextModelMethod(ModelAndViewContainer mavContainer) {<br>  for (ModelMethod modelMethod : this.modelMethods) {</p>
<pre><code>if (modelMethod.checkDependencies(mavContainer)) {
    if (logger.isTraceEnabled()) {
        logger.trace(&quot;Selected @ModelAttribute method &quot; + modelMethod);
    }
    this.modelMethods.remove(modelMethod);
    return modelMethod;
}</code></pre><p>  }<br>  ModelMethod modelMethod = this.modelMethods.get(0);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>logger.trace(&quot;Selected @ModelAttribute method (not present: &quot; +
        modelMethod.getUnresolvedDependencies(mavContainer)+ &quot;) &quot; + modelMethod);</code></pre><p>  }<br>  this.modelMethods.remove(modelMethod);<br>  return modelMethod;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">由于当前Demo中&#96;@ModelAttribute&#96;方法的形参没有带&#96;@ModelAttribute&#96;注解，所以这里&#96;dependencies&#96;为空，返回&#96;true&#96;</span><br><span class="line"></span><br><span class="line">将符合条件的&#96;ModelMethod&#96;返回，然后移除，下面再依次返回不符合条件的&#96;ModelMethod&#96;</span><br><span class="line"></span><br><span class="line">往回&#96;invokeModelAttributeMethods&#96;方法</span><br></pre></td></tr></table></figure>
<p>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)</p>
<pre><code>throws Exception {</code></pre><p>  while (!this.modelMethods.isEmpty()) {</p>
<pre><code>InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
if (mavContainer.containsAttribute(modelName)) {
    continue;
}

Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

if (!attrMethod.isVoid()){
    String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
    if (!mavContainer.containsAttribute(returnValueName)) {
        mavContainer.addAttribute(returnValueName, returnValue);
    }
}</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;getNextModelMethod&#96;获取到&#96;ModelMetod&#96;后，将它解包装回&#96;InvocableHandlerMethod&#96;，获取当前方法注解&#96;@ModelAttribute&#96;的&#96;value&#96;值，如果当前&#96;mavContainer&#96;中的&#96;Model&#96;已经有与&#96;value&#96;同名的属性名，则跳过，**在之前的代码，我们知道此时**&#96;Model&#96;**中的属性来自于**&#96;@SessionAttributes&#96;</span><br><span class="line"></span><br><span class="line">然后调用&#96;InvocableHandlerMethod&#96;的&#96;invokeForRequest&#96;方法来完成执行&#96;ModelAttribute&#96;方法，取得返回值</span><br></pre></td></tr></table></figure>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,</p>
<pre><code>Object... providedArgs) throws Exception {</code></pre><p>  Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
sb.append(Arrays.asList(args));
logger.trace(sb.toString());</code></pre><p>  }<br>  Object returnValue = doInvoke(args);<br>  if (logger.isTraceEnabled()) {</p>
<pre><code>logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);</code></pre><p>  }<br>  return returnValue;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">获取方法参数数组</span><br></pre></td></tr></table></figure>
<p>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,</p>
<pre><code>Object... providedArgs) throws Exception {</code></pre><p>  MethodParameter[] parameters = getMethodParameters();<br>  Object[] args = new Object[parameters.length];<br>  for (int i = 0; i &lt; parameters.length; i++) {</p>
<pre><code>MethodParameter parameter = parameters[i];
parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
args[i] = resolveProvidedArgument(parameter, providedArgs);
if (args[i] != null) {
    continue;
}
if (this.argumentResolvers.supportsParameter(parameter)) {
    try {
        args[i] = this.argumentResolvers.resolveArgument(
                parameter, mavContainer, request, this.dataBinderFactory);
        continue;
    }
    catch (Exception ex) {
        if (logger.isDebugEnabled()) {
            logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
        }
        throw ex;
    }
}
if (args[i] == null) {
    String msg = getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);
    throw new IllegalStateException(msg);
}</code></pre><p>  }<br>  return args;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">获取了方法参数类型数组&#96;MethodParameter[]&#96;</span><br><span class="line"></span><br><span class="line">遍历该数组，&#96;resolveParameterType&#96;确定每个方法参数的类型，&#96;getBean().getClass()&#96;传入方法所在的类的&#96;Class&#96;</span><br></pre></td></tr></table></figure>
<p>public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {<br>  Assert.notNull(methodParam, “MethodParameter must not be null”);<br>  Assert.notNull(clazz, “Class must not be null”);<br>  methodParam.setContainingClass(clazz);<br>  methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve());<br>  return methodParam.getParameterType();<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">设置成员变量&#96;containClass&#96;和&#96;parameterType&#96;，先看&#96;forMethodParameter&#96;方法</span><br></pre></td></tr></table></figure>
<p>public static ResolvableType forMethodParameter(MethodParameter methodParameter) {<br>  return forMethodParameter(methodParameter, (Type) null);<br>}</p>
</li>
</ul>
<p>public static ResolvableType forMethodParameter(MethodParameter methodParameter, Type targetType) {<br>    Assert.notNull(methodParameter, “MethodParameter must not be null”);<br>    //获取方法参数所在的类的ResolvableType,其它参数TypeProvider和variableResolve为空<br>    ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());<br>    //typeProvider由methodParameter为参数，提供参数的真正类型<br>    //以owner创建它的内部类new DefaultVariableResolver<br>    return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).<br>            getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;forType&#96;是用来创建&#96;ResolveType&#96;类型的变量</span><br></pre></td></tr></table></figure>
<p>public static ResolvableType forType(Type type) {<br>    return forType(type, null, null);<br>}</p>
<p>static ResolvableType forType(Type type, TypeProvider typeProvider, VariableResolver variableResolver) {<br>    if (type == null &amp;&amp; typeProvider != null) {<br>        type = SerializableTypeWrapper.forTypeProvider(typeProvider);<br>    }<br>    if (type == null) {<br>        return NONE;<br>    }</p>
<pre><code>// Purge empty entries on access since we don&apos;t have a clean-up thread or the like.
cache.purgeUnreferencedEntries();

// For simple Class references, build the wrapper right away -
// no expensive resolution necessary, so not worth caching...
if (type instanceof Class) {
    return new ResolvableType(type, typeProvider, variableResolver, null);
}

// Check the cache - we may have a ResolvableType which has been resolved before...
ResolvableType key = new ResolvableType(type, typeProvider, variableResolver);
ResolvableType resolvableType = cache.get(key);
if (resolvableType == null) {
    resolvableType = new ResolvableType(type, typeProvider, variableResolver, null);
    cache.put(resolvableType, resolvableType);
}
return resolvableType;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里先用单独一个&#96;type&#96;，这里是&#96;containClass&#96;即方法参数所在的类，创建一个&#96;ResolveType&#96;</span><br></pre></td></tr></table></figure>
<p>private ResolvableType(<br>        Type type, TypeProvider typeProvider, VariableResolver variableResolver, ResolvableType componentType) {</p>
<pre><code>this.type = type;
this.typeProvider = typeProvider;
this.variableResolver = variableResolver;
this.componentType = componentType;
this.resolved = resolveClass();</code></pre><p>}</p>
<p>private Class<?> resolveClass() {
    if (this.type instanceof Class || this.type == null) {
        return (Class<?>) this.type;<br>    }<br>    if (this.type instanceof GenericArrayType) {<br>        Class&lt;?&gt; resolvedComponent = getComponentType().resolve();<br>        return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);<br>    }<br>    return resolveType().resolve();<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为传来的&#96;type&#96;是&#96;invocableHandlerMethod&#96;中的&#96;bean&#96;，所以&#96;type&#96;&#x3D;&#x3D;&#96;resolved&#96;</span><br><span class="line"></span><br><span class="line">第二次使用了为&#96;null&#96;的&#96;targetType&#96;，&#96;new MethodParameterTypeProvider(methodParameter)&#96;和&#96;owner.asVariableResolver()&#96;</span><br></pre></td></tr></table></figure>
<p>public MethodParameterTypeProvider(MethodParameter methodParameter) {<br>    if (methodParameter.getMethod() != null) {<br>        this.methodName = methodParameter.getMethod().getName();<br>        this.parameterTypes = methodParameter.getMethod().getParameterTypes();<br>    }<br>    else {<br>        this.methodName = null;<br>        this.parameterTypes = methodParameter.getConstructor().getParameterTypes();<br>    }<br>    this.declaringClass = methodParameter.getDeclaringClass();<br>    this.parameterIndex = methodParameter.getParameterIndex();<br>    this.methodParameter = methodParameter;<br>}</p>
<p>VariableResolver asVariableResolver() {<br>    if (this == NONE) {<br>        return null;<br>    }<br>    return new DefaultVariableResolver();<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">创建这个&#96;TypeProvider&#96;通过构造函数传入了&#96;methodParameter&#96;，并且将它的一些属性注入到自己中</span><br><span class="line"></span><br><span class="line">因为传入的&#96;targetType&#96;为&#96;null&#96;</span><br></pre></td></tr></table></figure>
<p>if (type == null &amp;&amp; typeProvider != null) {<br>    type = SerializableTypeWrapper.forTypeProvider(typeProvider);<br>}</p>
<p>static Type forTypeProvider(final TypeProvider provider) {<br>    Assert.notNull(provider, “Provider must not be null”);<br>    if (provider.getType() instanceof Serializable || provider.getType() == null) {<br>        return provider.getType();<br>    }<br>    Type cached = cache.get(provider.getType());<br>    if (cached != null) {<br>        return cached;<br>    }<br>    for (Class<?> type : SUPPORTED_SERIALIZABLE_TYPES) {
        if (type.isAssignableFrom(provider.getType().getClass())) {
            ClassLoader classLoader = provider.getClass().getClassLoader();
            Class<?>[] interfaces = new Class&lt;?&gt;[] { type,<br>                SerializableTypeProxy.class, Serializable.class };<br>            InvocationHandler handler = new TypeProxyInvocationHandler(provider);<br>            cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);<br>            cache.put(provider.getType(), cached);<br>            return cached;<br>        }<br>    }<br>    throw new IllegalArgumentException(“Unsupported Type class “ + provider.getType().getClass().getName());<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;provider.getType()&#96;，变量&#96;provider&#96;为前面传来&#96;MethodParameterTypeProvider&#96;类型的变量，决定了参数的具体类型，它的父类&#96;TypeProvoider&#96;实现了&#96;serializable&#96;接口</span><br></pre></td></tr></table></figure>
<p>@Override<br>public Type getType() {<br>    return this.methodParameter.getGenericParameterType();<br>}</p>
<p>public Type getGenericParameterType() {<br>    if (this.genericParameterType == null) {<br>        if (this.parameterIndex &lt; 0) {<br>            this.genericParameterType = (this.method != null ? this.method.getGenericReturnType() : null);<br>        }<br>        else {<br>            this.genericParameterType = (this.method != null ?<br>                this.method.getGenericParameterTypes()[this.parameterIndex] :<br>                this.constructor.getGenericParameterTypes()[this.parameterIndex]);<br>        }<br>    }<br>    return this.genericParameterType;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">调用了类&#96;TypeProvider&#96;的&#96;getType&#96;，通过之前注入的变量&#96;MethodParameter&#96;</span><br><span class="line"></span><br><span class="line">因为创建类&#96;HandlerMethodParameter&#96;的时候注入了&#96;Method&#96;</span><br></pre></td></tr></table></figure>
<p>public HandlerMethodParameter(int index) {<br>    super(HandlerMethod.this.bridgedMethod, index);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">所以这里能获取到参数所在的方法的所有方法参数类型&#96;this.method.getGenericParameterTypes()[this.parameterIndex]&#96;</span><br><span class="line"></span><br><span class="line">然后利用这返回的方法参数的类型用来创建&#96;ResolveType&#96;</span><br></pre></td></tr></table></figure>
<p>if (type instanceof Class) {<br>    return new ResolvableType(type, typeProvider, variableResolver, null);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">返回的参数类型的&#96;type&#96;，又用来和之前的&#96;TypeProvider&#96;和&#96;VariableResolve&#96;创建新&#96;ResolveType&#96;</span><br><span class="line"></span><br><span class="line">再回到之前的方法</span><br></pre></td></tr></table></figure>
<p>public static Class<?> resolveParameterType(MethodParameter methodParam, Class<?> clazz) {<br>    Assert.notNull(methodParam, “MethodParameter must not be null”);<br>    Assert.notNull(clazz, “Class must not be null”);<br>    methodParam.setContainingClass(clazz);<br>    methodParam.setParameterType(ResolvableType.forMethodParameter(methodParam).resolve());<br>    return methodParam.getParameterType();<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里再次调用创建好的&#96;ResolveType&#96;的&#96;resolve&#96;方法</span><br></pre></td></tr></table></figure>
<p>public Class&lt;?&gt; resolve() {<br>    return resolve(null);<br>}</p>
<p>public Class<?> resolve(Class<?> fallback) {<br>    return (this.resolved != null ? this.resolved : fallback);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里&#96;ResolveType&#96;的成员变量&#96;resolve&#96;和&#96;type&#96;指向的都是方法的参数类型</span><br><span class="line"></span><br><span class="line">所以这里通过&#96;ResolvableType.forMethodParameter(methodParam).resolve()&#96;来找到方法参数的具体类型，然后设置到&#96;methodParam&#96;的&#96;ParameterType&#96;中</span><br><span class="line"></span><br><span class="line">通过这样确定了方法参数的具体类型</span><br><span class="line"></span><br><span class="line">回到&#96;InvocalbleHandlerMethod&#96;</span><br></pre></td></tr></table></figure>
<p>private Object[] getMethodArgumentValues(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>MethodParameter[] parameters = getMethodParameters();
Object[] args = new Object[parameters.length];
for (int i = 0; i &lt; parameters.length; i++) {
    MethodParameter parameter = parameters[i];
    parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
    GenericTypeResolver.resolveParameterType(parameter, getBean().getClass());
    args[i] = resolveProvidedArgument(parameter, providedArgs);
    if (args[i] != null) {
        continue;
    }
    if (this.argumentResolvers.supportsParameter(parameter)) {
        try {
            args[i] = this.argumentResolvers.resolveArgument(
                    parameter, mavContainer, request, this.dataBinderFactory);
            continue;
        }
        catch (Exception ex) {
            if (logger.isDebugEnabled()) {
                logger.debug(getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), ex);
            }
            throw ex;
        }
    }
    if (args[i] == null) {
        String msg = getArgumentResolutionErrorMessage(&quot;No suitable resolver for argument&quot;, i);
        throw new IllegalStateException(msg);
    }
}
return args;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">确定方法参数的具体类型之后，接着调用&#96;InvocableHandlerMethod&#96;自身的&#96;resolveProvidedArgument&#96;方法处理对方法参数进行处理</span><br></pre></td></tr></table></figure>
<p>private Object resolveProvidedArgument(MethodParameter parameter, Object… providedArgs) {<br>    if (providedArgs == null) {<br>        return null;<br>    }<br>    for (Object providedArg : providedArgs) {<br>        if (parameter.getParameterType().isInstance(providedArg)) {<br>            return providedArg;<br>        }<br>    }<br>    return null;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Demo中源码传入得入参&#96;providedArgs&#96;为&#96;[]&#96;，所以这里返回空</span><br><span class="line"></span><br><span class="line">接着判断&#96;this.argumentResolvers.supportsParameter(parameter)&#96;</span><br></pre></td></tr></table></figure>
<p>@Override<br>public boolean supportsParameter(MethodParameter parameter) {<br>    return getArgumentResolver(parameter) != null;<br>}</p>
<p>private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {<br>    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);<br>    if (result == null) {<br>        for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {<br>            if (logger.isTraceEnabled()) {<br>                logger.trace(“Testing if argument resolver [“ + methodArgumentResolver + “] supports [“ +<br>                        parameter.getGenericParameterType() + “]”);<br>            }<br>            if (methodArgumentResolver.supportsParameter(parameter)) {<br>                result = methodArgumentResolver;<br>                this.argumentResolverCache.put(parameter, result);<br>                break;<br>            }<br>        }<br>    }<br>    return result;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;argumentResolvers&#96;属于类&#96;HandlerMethodArgumentResolverComposite&#96;，实现了&#96;HandlerMethodArgumentResolver&#96;接口，用来解析方法参数</span><br><span class="line"></span><br><span class="line">遍历成员变量&#96;argumentResolvers&#96;，查找一个支持当前参数类型得参数解析器，放入缓存</span><br><span class="line"></span><br><span class="line">当前Demo正在执行&#96;@ModelAttribute&#96;方法</span><br></pre></td></tr></table></figure>
<p>@ModelAttribute(“attr”)<br>public void mda(Map map) {<br>    Person person = new Person(“li”, 12);<br>    map.put(“person”, new Person(“zh”, 14));<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里适用于这个的解析器为&#96;MapMethodProcessor&#96;</span><br><span class="line"></span><br><span class="line">有支持当前参数的参数解析器，所以返回&#96;true&#96;</span><br><span class="line"></span><br><span class="line">之后对方法参数变量&#96;MethodParameter&#96;进行处理</span><br></pre></td></tr></table></figure>
<p>args[i] = this.argumentResolvers.resolveArgument(<br>        parameter, mavContainer, request, this.dataBinderFactory);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接下来</span><br></pre></td></tr></table></figure>
<p>@Override<br>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
Assert.notNull(resolver, &quot;Unknown parameter type [&quot; + parameter.getParameterType().getName() + &quot;]&quot;);
return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;getArgumentResover(parameter)&#96;返回&#96;MapMethodProcessor&#96;</span><br><span class="line"></span><br><span class="line">查看&#96;MapMethodProcessor&#96;的&#96;resolveArgument&#96;方法</span><br></pre></td></tr></table></figure>
<p>@Override<br>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>return mavContainer.getModel();</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">返回容器中的默认&#96;BindingAwareModelMap&#96;</span><br><span class="line"></span><br><span class="line">也就是说，此时&#96;@ModelAttribute&#96;方法中的&#96;Map&#96;类型的参数指向了&#96;mavContainer&#96;中的&#96;Model&#96;</span><br><span class="line"></span><br><span class="line">方法在最后返回方法参数&#96;args[]&#96;数组</span><br><span class="line"></span><br><span class="line">回到&#96;InvocableHandlerMethod&#96;的&#96;invokeForRequest&#96;方法</span><br></pre></td></tr></table></figure>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) {
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
}
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
}
return returnValue;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里接收返回的参数之后，调用&#96;doInvoke(args)&#96;真正对&#96;@ModelAttribute&#96;方法执行</span><br></pre></td></tr></table></figure>
<p>protected Object doInvoke(Object… args) throws Exception {<br>    ReflectionUtils.makeAccessible(getBridgedMethod());<br>    try {<br>        return getBridgedMethod().invoke(getBean(), args);<br>    }<br>    catch (IllegalArgumentException ex) {<br>        assertTargetBean(getBridgedMethod(), getBean(), args);<br>        throw new IllegalStateException(getInvocationErrorMessage(ex.getMessage(), args), ex);<br>    }<br>    catch (InvocationTargetException ex) {<br>        // Unwrap for HandlerExceptionResolvers …<br>        Throwable targetException = ex.getTargetException();<br>        if (targetException instanceof RuntimeException) {<br>            throw (RuntimeException) targetException;<br>        }<br>        else if (targetException instanceof Error) {<br>            throw (Error) targetException;<br>        }<br>        else if (targetException instanceof Exception) {<br>            throw (Exception) targetException;<br>        }<br>        else {<br>            String msg = getInvocationErrorMessage(“Failed to invoke controller method”, args);<br>            throw new IllegalStateException(msg, targetException);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里使用了反射的方式来执行方法，然后返回返回值，所以我们现在也知道了操作&#96;@ModelAttribute&#96;方法中的&#96;Map&#96;入参，就等于是在操作&#96;mavContainer&#96;的&#96;Model&#96;</span><br><span class="line"></span><br><span class="line">回到&#96;ModelFactory&#96;的&#96;invokeModelAttributeMethods&#96;</span><br></pre></td></tr></table></figure>
<p>private void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer mavContainer)<br>        throws Exception {</p>
<pre><code>while (!this.modelMethods.isEmpty()) {
    InvocableHandlerMethod attrMethod = getNextModelMethod(mavContainer).getHandlerMethod();
    String modelName = attrMethod.getMethodAnnotation(ModelAttribute.class).value();
    if (mavContainer.containsAttribute(modelName)) {
        continue;
    }

    Object returnValue = attrMethod.invokeForRequest(request, mavContainer);

    if (!attrMethod.isVoid()){
        String returnValueName = getNameForReturnValue(returnValue, attrMethod.getReturnType());
        if (!mavContainer.containsAttribute(returnValueName)) {
            mavContainer.addAttribute(returnValueName, returnValue);
        }
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果&#96;@ModelAttribute&#96;方法不是&#96;void&#96;类型</span><br><span class="line"></span><br><span class="line">传入参数为&#96;@ModelAttribute&#96;方法的返回值和&#96;attrMethod.getReturnType()&#96;</span><br></pre></td></tr></table></figure>
<p>public MethodParameter getReturnType() {<br>    return new HandlerMethodParameter(-1);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接下来获取返回值名</span><br></pre></td></tr></table></figure>
<p>public static String getNameForReturnValue(Object returnValue, MethodParameter returnType) {<br>    ModelAttribute annotation = returnType.getMethodAnnotation(ModelAttribute.class);<br>    if (annotation != null &amp;&amp; StringUtils.hasText(annotation.value())) {<br>        return annotation.value();<br>    }<br>    else {<br>        Method method = returnType.getMethod();<br>        Class&lt;?&gt; resolvedType = GenericTypeResolver.resolveReturnType(method, returnType.getContainingClass());<br>        return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一行获取方法参数所在方法是否有&#96;@ModelAttribute&#96;注解</span><br></pre></td></tr></table></figure>
<p>public <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {<br>    return getAnnotatedElement().getAnnotation(annotationType);<br>}</p>
<p>public AnnotatedElement getAnnotatedElement() {<br>    // NOTE: no ternary expression to retain JDK &lt;8 compatibility even when using<br>    // the JDK 8 compiler (potentially selecting java.lang.reflect.Executable<br>    // as common type, with that new base class not available on older JDKs)<br>    if (this.method != null) {<br>        return this.method;<br>    }<br>    else {<br>        return this.constructor;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果存在注解，返回注解的&#96;value&#96;属性</span><br><span class="line"></span><br><span class="line">然后检测&#96;mavContainer&#96;中的&#96;Model&#96;是否已经包含该&#96;value&#96;属性的值为&#96;key&#96;的键值对，如果不包含，则将&#96;value&#96;和返回值添加到&#96;Model&#96;中</span><br><span class="line"></span><br><span class="line">回到&#96;ModelFactory&#96;的&#96;initModel&#96;方法</span><br></pre></td></tr></table></figure>
<p>public void initModel(NativeWebRequest request, ModelAndViewContainer mavContainer, HandlerMethod handlerMethod)<br>        throws Exception {</p>
<pre><code>Map&lt;String, ?&gt; sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);
mavContainer.mergeAttributes(sessionAttributes);

invokeModelAttributeMethods(request, mavContainer);

for (String name : findSessionAttributeArguments(handlerMethod)) {
    if (!mavContainer.containsAttribute(name)) {
        Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);
        if (value == null) {
            throw new HttpSessionRequiredException(&quot;Expected session attribute &apos;&quot; + name + &quot;&apos;&quot;);
        }
        mavContainer.addAttribute(name, value);
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面执行完&#96;invokeModelAttributeMethods(request, mavContainer)&#96;之后</span><br><span class="line"></span><br><span class="line">&#96;findSessionAttributeArguments(handlerMethod)&#96;返回的结果是响应的&#96;Handler&#96;方法中参数带&#96;@ModelAttribute&#96;注解的&#96;value&#96;值和&#96;@SessionAttributes&#96;注解的&#96;value&#96;相同时的&#96;value&#96;，或者带&#96;@ModelAttribute&#96;注解的方法参数属于&#96;@SessionAttributes&#96;注解的&#96;Types&#96;范围内的&#96;value&#96;</span><br><span class="line"></span><br><span class="line">然后将&#96;value&#96;作为&#96;key&#96;取出因为&#96;Session&#96;中相应属性，添加到&#96;mavContainer&#96;的&#96;Model&#96;中</span><br><span class="line"></span><br><span class="line">取出的值为null时，抛出异常，也就是说当&#96;@SessionAttributes&#96;和&#96;Handler&#96;方法中参数的&#96;@ModelAttribute&#96;对应时，例如&#96;value&#96;相同，在执行完ModelAttribute方法之后，&#96;mavContainer&#96;中必须有值能传给这个&#96;@ModelAttribute&#96;方法参数</span><br><span class="line"></span><br><span class="line">以上就是&#96;modelFactory.initModel(webRequest, mavContainer, requestMappingMethod)&#96;完成的事</span><br><span class="line"></span><br><span class="line">接下来是对&#96;Controller&#96;中响应网页请求的方法的执行</span><br><span class="line"></span><br><span class="line">该方法</span><br></pre></td></tr></table></figure>
<p>@RequestMapping(“/Person”)<br>public String testParam(Person person,HttpSession session) {<br>    System.out.println(person.getName()+” “+person.getAge());<br>    session.setAttribute(“person”, person);<br>    return “person”;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">依旧回到&#96;RequestMappingHandlerAdapter&#96;</span><br></pre></td></tr></table></figure>
<p>requestMappingMethod.invokeAndHandle(webRequest, mavContainer)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中&#96;requestMappingMethod&#96;是由&#96;InvocableHandlerMethod&#96;包装成的&#96;ServletInvocableHandlerMethod&#96;，它指向响应了客户端请求的方法</span><br></pre></td></tr></table></figure>
<p>ServletInvocableHandlerMethod requestMappingMethod = createRequestMappingMethod(handlerMethod, binderFactory)</p>
<p>private ServletInvocableHandlerMethod createRequestMappingMethod(<br>        HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {</p>
<pre><code>ServletInvocableHandlerMethod requestMethod;
requestMethod = new ServletInvocableHandlerMethod(handlerMethod);
requestMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
requestMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
requestMethod.setDataBinderFactory(binderFactory);
requestMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
return requestMethod;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">进入&#96;invokeAndHandle(webRequest, mavContainer)&#96;，调用响应方法</span><br></pre></td></tr></table></figure>
<p>public void invokeAndHandle(ServletWebRequest webRequest,<br>        ModelAndViewContainer mavContainer, Object… providedArgs) throws Exception {</p>
<pre><code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
setResponseStatus(webRequest);

if (returnValue == null) {
    if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
        mavContainer.setRequestHandled(true);
        return;
    }
}
else if (StringUtils.hasText(this.responseReason)) {
    mavContainer.setRequestHandled(true);
    return;
}

mavContainer.setRequestHandled(false);
try {
    this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
}
catch (Exception ex) {
    if (logger.isTraceEnabled()) {
        logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
    }
    throw ex;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;invokeForRequest&#96;方法调用响应方法获取返回值</span><br></pre></td></tr></table></figure>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) {
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
}
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
}
return returnValue;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接下来的步骤与执行&#96;@ModelAttribute&#96;方法差不多，通过&#96;GenericTypeResolver&#96;确认了&#96;MethodParameter&#96;中的&#96;ParameterType&#96;</span><br><span class="line"></span><br><span class="line">接着获取适用&#96;HandlerMethodArgumentResolver&#96;时，这里使用的是&#96;ServletModelAttributeMethodProcessor&#96;</span><br></pre></td></tr></table></figure>
<p>public boolean supportsParameter(MethodParameter parameter) {<br>    if (parameter.hasParameterAnnotation(ModelAttribute.class)) {<br>        return true;<br>    }<br>    else if (this.annotationNotRequired) {<br>        return !BeanUtils.isSimpleProperty(parameter.getParameterType());<br>    }<br>    else {<br>        return false;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;BeanUtils.isSimpleProperty(parameter.getParameterType()&#96;方法确认了&#96;MethodParameter&#96;不是简单属性，英文解释如下</span><br><span class="line"></span><br><span class="line">Check if the given type represents a &quot;simple&quot; value type:a primitive, a String or other CharSequence, a Number, a Date,a URI, a URL, a Locale or a Class.</span><br><span class="line"></span><br><span class="line">然后使用&#96;argumentResolver&#96;处理&#96;MethodParameter&#96;</span><br></pre></td></tr></table></figure>
<p>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>String name = ModelFactory.getNameForParameter(parameter);
Object attribute = (mavContainer.containsAttribute(name) ?
        mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
if (binder.getTarget() != null) {
    bindRequestParameters(binder, webRequest);
    validateIfApplicable(binder, parameter);
    if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
        throw new BindException(binder.getBindingResult());
    }
}

// Add resolved attribute and BindingResult at the end of the model
Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
mavContainer.removeAttributes(bindingResultModel);
mavContainer.addAllAttributes(bindingResultModel);

return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;getNameForParameter(parameter)&#96;决定了变量的名字，如果变量被&#96;@ModelAttribute&#96;注解修饰，则&#96;name&#96;取此&#96;value&#96;属性，当变量为&#96;Array&#96;或者&#96;Collection&#96;或者普通&#96;Class&#96;，则取成员变量或者全限定名最后一个.之后的字符作为&#96;name&#96;</span><br><span class="line"></span><br><span class="line">接着如果&#96;mavContainer&#96;中存在&#96;key&#96;为&#96;name&#96;，则取出对应的值，否则&#96;createAttribute&#96;方法获取&#96;MethodParameter&#96;的&#96;Class&#96;来创建新对象</span><br><span class="line"></span><br><span class="line">接着&#96;binderFactory.createBinder&#96;创建一个数据绑定器</span><br></pre></td></tr></table></figure>
<p>@Override<br>public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)<br>        throws Exception {<br>    WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);<br>    if (this.initializer != null) {<br>        this.initializer.initBinder(dataBinder, webRequest);<br>    }<br>    initBinder(dataBinder, webRequest);<br>    return dataBinder;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">创建&#96;binderFactory&#96;的时候，&#96;RequestMappingHandlerAdapter&#96;给它注入了一个&#96;ConfigurableWebBindinginitializer&#96;类的变量，然后用它来初步初始化&#96;dataBinder&#96;，这个&#96;dataBinder&#96;的类型为&#96;ExtendedServletRequestDataBinder&#96;</span><br></pre></td></tr></table></figure>
<p>@Override<br>public void initBinder(WebDataBinder binder, WebRequest request) {<br>    binder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);<br>    if (this.directFieldAccess) {<br>        binder.initDirectFieldAccess();<br>    }<br>    if (this.messageCodesResolver != null) {<br>        binder.setMessageCodesResolver(this.messageCodesResolver);<br>    }<br>    if (this.bindingErrorProcessor != null) {<br>        binder.setBindingErrorProcessor(this.bindingErrorProcessor);<br>    }<br>    if (this.validator != null &amp;&amp; binder.getTarget() != null &amp;&amp;<br>            this.validator.supports(binder.getTarget().getClass())) {<br>        binder.setValidator(this.validator);<br>    }<br>    if (this.conversionService != null) {<br>        binder.setConversionService(this.conversionService);<br>    }<br>    if (this.propertyEditorRegistrars != null) {<br>        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {<br>            propertyEditorRegistrar.registerCustomEditors(binder);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;initializer&#96;中有个重要变量&#96;conversionService&#96;，属于接口&#96;ConversionService&#96;，它指向了一个&#96;DefaultFormattingConversionService&#96;类的实例，该实例也是由&#96;SpringMvc&#96;注入，存放&#96;SpringMvc&#96;自带的类型转换器converters</span><br><span class="line"></span><br><span class="line">接着由&#96;binderFactory&#96;的&#96;init&#96;方法初始化&#96;dataBinder&#96;</span><br></pre></td></tr></table></figure>
<p>@Override<br>public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {<br>    for (InvocableHandlerMethod binderMethod : this.binderMethods) {<br>        if (isBinderMethodApplicable(binderMethod, binder)) {<br>            Object returnValue = binderMethod.invokeForRequest(request, null, binder);<br>            if (returnValue != null) {<br>                throw new IllegalStateException(“@InitBinder methods should return void: “ + binderMethod);<br>            }<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里真正调用我们使用&#96;@InitBinder&#96;注解的方法，同样的&#96;invokeForRequest&#96;方法，这里传入的&#96;binder&#96;，会作为调用该方法的参数</span><br></pre></td></tr></table></figure>
<p>@InitBinder<br>public void initBinder(WebDataBinder binder) {<br>    SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);<br>    sdf.setLenient(false);<br>    binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">所以我们&#96;@InitBinder&#96;的方法，其实就是在初始化&#96;SpringMvc&#96;为每个请求创建的&#96;dataBinder&#96;</span><br><span class="line"></span><br><span class="line">我们这里使用了&#96;registerCustomEditor&#96;注册了它&#96;SpringMvc&#96;中已经定义好的&#96;PropertyEditor&#96;，用来将字符串转化为&#96;java.util.Date&#96;，它继承了&#96;PropertyEditorSupport&#96;，如果要使用我们自定义的&#96;PropertyEditor&#96;，也是如此，覆写&#96;getAsText&#96;和&#96;setAsText&#96;方法，然后注册</span><br></pre></td></tr></table></figure>
<p>@Override<br>public String getAsText() {<br>    Date value = (Date) getValue();<br>    return (value != null ? this.dateFormat.format(value) : “”);<br>}</p>
<p>@Override<br>public void setAsText(String text) throws IllegalArgumentException {<br>    if (this.allowEmpty &amp;&amp; !StringUtils.hasText(text)) {<br>        // Treat empty String as null value.<br>        setValue(null);<br>    }<br>    //exactDateLength可以指定需要转化成Date类型的字符串长度<br>    else if (text != null &amp;&amp; this.exactDateLength &gt;= 0 &amp;&amp; text.length() != this.exactDateLength) {<br>        throw new IllegalArgumentException(<br>                “Could not parse date: it is not exactly” + this.exactDateLength + “characters long”);<br>    }<br>    else {<br>        try {<br>            //使用我们注入的DateFormat将字符串转化成Date<br>            setValue(this.dateFormat.parse(text));<br>        }<br>        catch (ParseException ex) {<br>            throw new IllegalArgumentException(“Could not parse date: “ + ex.getMessage(), ex);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我们看是怎么用&#96;dataBinder&#96;注册的</span><br></pre></td></tr></table></figure>
<p>@Override<br>public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {<br>    getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">获取&#96;PropertyEditorRegistry&#96;</span><br></pre></td></tr></table></figure>
<p>protected PropertyEditorRegistry getPropertyEditorRegistry() {<br>    if (getTarget() != null) {<br>        return getInternalBindingResult().getPropertyAccessor();<br>    }<br>    else {<br>        return getSimpleTypeConverter();<br>    }<br>}</p>
<p>protected AbstractPropertyBindingResult getInternalBindingResult() {<br>    if (this.bindingResult == null) {<br>        initBeanPropertyAccess();<br>    }<br>    return this.bindingResult;<br>}</p>
<p>public void initBeanPropertyAccess() {<br>    Assert.state(this.bindingResult == null,<br>            “DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods”);<br>    this.bindingResult = new BeanPropertyBindingResult(<br>            getTarget(), getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());<br>    if (this.conversionService != null) {<br>        this.bindingResult.initConversion(this.conversionService);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里创建了一个&#96;BeanPropertyBindingResult&#96;类的实例，将&#96;dataBinder&#96;中的&#96;target&#96;和&#96;objectName&#96;传入，让&#96;dataBinder&#96;的&#96;bindingResult&#96;指向它，然后返回这个对象</span><br><span class="line"></span><br><span class="line">然后调用这个实例的&#96;getPropertyAccessor&#96;方法，获取属性存取器</span><br></pre></td></tr></table></figure>
<p>@Override<br>public final ConfigurablePropertyAccessor getPropertyAccessor() {<br>    if (this.beanWrapper == null) {<br>        this.beanWrapper = createBeanWrapper();<br>        this.beanWrapper.setExtractOldValueForEditor(true);<br>        this.beanWrapper.setAutoGrowNestedPaths(this.autoGrowNestedPaths);<br>        this.beanWrapper.setAutoGrowCollectionLimit(this.autoGrowCollectionLimit);<br>    }<br>    return this.beanWrapper;<br>}</p>
<p>protected BeanWrapper createBeanWrapper() {<br>    Assert.state(this.target != null, “Cannot access properties on null bean instance ‘“ + getObjectName() + “‘!”);<br>    return PropertyAccessorFactory.forBeanPropertyAccess(this.target);<br>}</p>
<p>public static BeanWrapper forBeanPropertyAccess(Object target) {<br>    return new BeanWrapperImpl(target);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">最后返回的是一个&#96;BeanWrapperImpl&#96;类的实例，并且让&#96;BeanPropertyBindingResult&#96;的&#96;beanWrapper&#96;指向它，这个类继承了&#96;AbstractPropertyAccessor&#96;和&#96;PropertyEditorRegistrySupport&#96;</span><br><span class="line"></span><br><span class="line">然后开始注册&#96;PropertyEditor&#96;，也就是执行我们自定义的&#96;@InitBinder&#96;注解的方法</span><br></pre></td></tr></table></figure>
<p>@Override<br>public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {<br>    registerCustomEditor(requiredType, null, propertyEditor);<br>}</p>
<p>@Override<br>public void registerCustomEditor(Class<?> requiredType, String propertyPath, PropertyEditor propertyEditor) {
    if (requiredType == null && propertyPath == null) {
        throw new IllegalArgumentException("Either requiredType or propertyPath is required");
    }
    if (propertyPath != null) {
        if (this.customEditorsForPath == null) {
            this.customEditorsForPath = new LinkedHashMap<String, CustomEditorHolder>(16);
        }
        this.customEditorsForPath.put(propertyPath, new CustomEditorHolder(propertyEditor, requiredType));
    }
    else {
        if (this.customEditors == null) {
            this.customEditors = new LinkedHashMap<Class<?>, PropertyEditor&gt;(16);<br>        }<br>        this.customEditors.put(requiredType, propertyEditor);<br>        this.customEditorCache = null;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后将&#96;PropertyEditor&#96;放入&#96;customEditors&#96;，此时，&#96;@InitBinder&#96;注解的方法执行完毕</span><br></pre></td></tr></table></figure>
<p>@Override<br>public void initBinder(WebDataBinder binder, NativeWebRequest request) throws Exception {<br>    for (InvocableHandlerMethod binderMethod : this.binderMethods) {<br>        if (isBinderMethodApplicable(binderMethod, binder)) {<br>            Object returnValue = binderMethod.invokeForRequest(request, null, binder);<br>            if (returnValue != null) {<br>                throw new IllegalStateException(“@InitBinder methods should return void: “ + binderMethod);<br>            }<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里可以看到&#96;@InitBinder&#96;注解的方法不能有返回值</span><br></pre></td></tr></table></figure>
<p>@Override<br>public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)<br>        throws Exception {<br>    WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);<br>    if (this.initializer != null) {<br>        this.initializer.initBinder(dataBinder, webRequest);<br>    }<br>    initBinder(dataBinder, webRequest);<br>    return dataBinder;<br>}</p>
<p>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>String name = ModelFactory.getNameForParameter(parameter);
Object attribute = (mavContainer.containsAttribute(name) ?
        mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
if (binder.getTarget() != null) {
    bindRequestParameters(binder, webRequest);
    validateIfApplicable(binder, parameter);
    if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
        throw new BindException(binder.getBindingResult());
    }
}</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">初始化完&#96;dataBinder&#96;之后，开始绑定请求数据&#96;bindRequestParameters(binder, webRequest)&#96;</span><br></pre></td></tr></table></figure>
<pre><code>protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
    ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
    ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
    servletBinder.bind(servletRequest);
}</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;RequestFacade&#96;在前面被封装成&#96;ServletWebRequest&#96;，这里又解包装</span><br><span class="line">然后将&#96;binder&#96;从&#96;ExtendedServletRequestDataBinder&#96;向上转型为&#96;ServletRequestDataBinder&#96;</span><br></pre></td></tr></table></figure>
<p>public void bind(ServletRequest request) {<br>    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);<br>    MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);<br>    if (multipartRequest != null) {<br>        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);<br>    }<br>    addBindValues(mpvs, request);<br>    doBind(mpvs);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">看mpvs是什么</span><br></pre></td></tr></table></figure>
<p>public ServletRequestParameterPropertyValues(ServletRequest request) {<br>    this(request, null, null);<br>}</p>
<p>public ServletRequestParameterPropertyValues(ServletRequest request, String prefix, String prefixSeparator) {<br>    super(WebUtils.getParametersStartingWith(<br>            request, (prefix != null ? prefix + prefixSeparator : null)));<br>}</p>
<p>public static Map&lt;String, Object&gt; getParametersStartingWith(ServletRequest request, String prefix) {<br>    Assert.notNull(request, “Request must not be null”);<br>    Enumeration<String> paramNames = request.getParameterNames();<br>    Map&lt;String, Object&gt; params = new TreeMap&lt;String, Object&gt;();<br>    if (prefix == null) {<br>        prefix = “”;<br>    }<br>    while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {<br>        String paramName = paramNames.nextElement();<br>        if (“”.equals(prefix) || paramName.startsWith(prefix)) {<br>            String unprefixed = paramName.substring(prefix.length());<br>            String[] values = request.getParameterValues(paramName);<br>            if (values == null || values.length == 0) {<br>                // Do nothing, no values found at all.<br>            }<br>            else if (values.length &gt; 1) {<br>                params.put(unprefixed, values);<br>            }<br>            else {<br>                params.put(unprefixed, values[0]);<br>            }<br>        }<br>    }<br>    return params;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里&#96;request.getParameterNames()&#96;获取请求中传来的参数的名字的枚举集合，然后&#96;request.getParameterValues(paramName)&#96;获取请求中参数的值</span><br><span class="line"></span><br><span class="line">继续构造方法</span><br></pre></td></tr></table></figure>
<p>public MutablePropertyValues(Map<?, ?> original) {<br>    // We can optimize this because it’s all new:<br>    // There is no replacement of existing property values.<br>    if (original != null) {<br>        this.propertyValueList = new ArrayList<PropertyValue>(original.size());<br>        for (Map.Entry<?, ?> entry : original.entrySet()) {<br>            this.propertyValueList.add(new PropertyValue(entry.getKey().toString(), entry.getValue()));<br>        }<br>    }<br>    else {<br>        this.propertyValueList = new ArrayList<PropertyValue>(0);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;original&#96;存放了请求中参数的名和值，将其从&#96;Map&#96;类型转换到&#96;PropertyValue&#96;的数组队列</span><br></pre></td></tr></table></figure>
<p>public void bind(ServletRequest request) {<br>    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);<br>    MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);<br>    if (multipartRequest != null) {<br>        bindMultipart(multipartRequest.getMultiFileMap(), mpvs);<br>    }<br>    addBindValues(mpvs, request);<br>    doBind(mpvs);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;addBindValues(mpvc,request)&#96;将&#96;pathVariable&#96;变量添加入&#96;mpvs&#96;中，&#96;key&#96;重复时跳过</span><br><span class="line"></span><br><span class="line">然后&#96;doBind(mpvs)&#96;把&#96;mvps&#96;中的参数绑定到&#96;dataBinder&#96;的&#96;target&#96;中，也就是目标&#96;handlerMethod&#96;方法得参数中，中间利用到的转换器有默认的&#96;ConversionService&#96;中注入的转换器，例如&#96;java.lang.String&#96;转换到&#96;java.lang.Integer&#96;的转换器&#96;StringToNumber&#96;</span><br></pre></td></tr></table></figure>
<p>final class StringToNumberConverterFactory implements ConverterFactory&lt;String, Number&gt; {</p>
<pre><code>@Override
public &lt;T extends Number&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
    return new StringToNumber&lt;T&gt;(targetType);
}

private static final class StringToNumber&lt;T extends Number&gt; implements Converter&lt;String, T&gt; {

    private final Class&lt;T&gt; targetType;

    public StringToNumber(Class&lt;T&gt; targetType) {
        this.targetType = targetType;
    }

    @Override
    public T convert(String source) {
        if (source.length() == 0) {
            return null;
        }
        return NumberUtils.parseNumber(source, this.targetType);
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">回到&#96;ServletModelAttributeMethodProcessor&#96;的&#96;resolveArgument&#96;</span><br></pre></td></tr></table></figure>
<p>public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,<br>        NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {</p>
<pre><code>String name = ModelFactory.getNameForParameter(parameter);
Object attribute = (mavContainer.containsAttribute(name) ?
        mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));

WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
if (binder.getTarget() != null) {
    bindRequestParameters(binder, webRequest);
    validateIfApplicable(binder, parameter);
    if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
        throw new BindException(binder.getBindingResult());
    }
}

// Add resolved attribute and BindingResult at the end of the model
Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
mavContainer.removeAttributes(bindingResultModel);
mavContainer.addAllAttributes(bindingResultModel);

return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;validateIfApplicable(binder,webRequest)&#96;这句的作用在&#96;@validated&#96;注解的使用，对&#96;POJO&#96;类的属性进行jrs303验证</span><br><span class="line"></span><br><span class="line">最后将&#96;dataBinder&#96;中的&#96;BeanPropertyBindingResult&#96;的已经和请求中的参数做了数据绑定之后的&#96;target&#96;和处理&#96;@validated&#96;注解之后的&#96;BeanPropertyBindingResult&#96;也就是它自身绑定到&#96;mavContainer&#96;的&#96;Model&#96;中</span><br><span class="line"></span><br><span class="line">回到最初执行控制器&#96;Controller&#96;的&#96;ServletInvocableHandlerMethod&#96;</span><br></pre></td></tr></table></figure>
<p>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,<br>        Object… providedArgs) throws Exception {</p>
<pre><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
if (logger.isTraceEnabled()) {
    StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);
    sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);
    sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);
    sb.append(Arrays.asList(args));
    logger.trace(sb.toString());
}
Object returnValue = doInvoke(args);
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);
}
return returnValue;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;getMethodArgumentValues&#96;方法中，&#96;argumentResolver&#96;对形参&#96;methodParameter&#96;解析之后，获取到要执行的方法的参数的具体的值</span><br><span class="line"></span><br><span class="line">然后利用反射执行方法，然后返回返回值</span><br></pre></td></tr></table></figure>
<p>public void invokeAndHandle(ServletWebRequest webRequest,<br>        ModelAndViewContainer mavContainer, Object… providedArgs) throws Exception {</p>
<pre><code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
setResponseStatus(webRequest);

if (returnValue == null) {
    if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
        mavContainer.setRequestHandled(true);
        return;
    }
}
else if (StringUtils.hasText(this.responseReason)) {
    mavContainer.setRequestHandled(true);
    return;
}

mavContainer.setRequestHandled(false);
try {
    this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
}
catch (Exception ex) {
    if (logger.isTraceEnabled()) {
        logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
    }
    throw ex;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;Controller&#96;中方法返回值一般就是&#96;view&#96;了</span><br><span class="line"></span><br><span class="line">&#96;RequestMappingHandlerAdapter&#96;在将&#96;Controller&#96;中目标方法包装成&#96;ServletInvocableHandlerMethod&#96;时注入了&#96;HandlerMethodReturnValueHandlerComposite&#96;的实例，其中包含了许多处理返回值的&#96;HandlerMethodReturnValueHandler&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中这里处理&#96;view&#96;视图的是&#96;ViewNameMethodReturnValueHandler&#96;</span><br></pre></td></tr></table></figure>
<p>@Override<br>public void handleReturnValue(Object returnValue, MethodParameter returnType,<br>        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {</p>
<pre><code>if (returnValue == null) {
    return;
}
else if (returnValue instanceof String) {
    String viewName = (String) returnValue;
    mavContainer.setViewName(viewName);
    if (isRedirectViewName(viewName)) {
        mavContainer.setRedirectModelScenario(true);
    }
}
else {
    // should not happen
    throw new UnsupportedOperationException(&quot;Unexpected return type: &quot; +
            returnType.getParameterType().getName() + &quot; in method: &quot; + returnType.getMethod());
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回值为&#96;String&#96;类型的时候，将它作为&#96;viewName&#96;放入&#96;mavContainer&#96;，然后判断&#96;viewName&#96;中是否以&#96;redirect:&#96;开头的设置&#96;redirectModelScenario&#96;属性</span><br><span class="line"></span><br><span class="line">此时，&#96;RequestMappingHandlerAdapter&#96;的&#96;InvokeHandleMethod&#96;，也就是&#96;handler&#96;方法执行的入口就只剩下最后一步</span><br></pre></td></tr></table></figure>
<p>return getModelAndView(mavContainer, modelFactory, webRequest);</p>
<p>private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,<br>        ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {</p>
<pre><code>modelFactory.updateModel(webRequest, mavContainer);
if (mavContainer.isRequestHandled()) {
    return null;
}
ModelMap model = mavContainer.getModel();
ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model);
if (!mavContainer.isViewReference()) {
    mav.setView((View) mavContainer.getView());
}
if (model instanceof RedirectAttributes) {
    Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
    HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
    RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
}
return mav;</code></pre><p>}</p>
<p>```</p>
<p>前面看到返回值为空时，设置<code>requestHandled</code>为<code>true</code>，使用<code>mavContainer</code>中的<code>Model</code>和<code>viewName</code>创建一个<code>ModelAndView</code>返回，接下来就是对视图进行处理</p>
<h3 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h3><ol>
<li><p>创建<code>WebDataBinderFactory</code>，用来处理请求中属性绑定到形参</p>
</li>
<li><p>创建<code>ModelFactory</code>，处理<code>@ModelAttribute</code>方法</p>
</li>
<li><p>创建<code>ModelAndViewContainer</code>，用来作为<code>Model</code>和<code>View</code>的容器</p>
</li>
<li><p>执行<code>@ModelAttribute</code>方法，在这之前先将<code>@SessionAttributes</code>注解的属性从<code>Session</code>中取出放入<code>mavContainer</code>的<code>Model</code>中</p>
</li>
<li><p>执行<code>Controller</code>目标方法，主要通过获取方法的形参，然后根据形参选择适用的<code>HandlerMethodArgumentResolver</code>对形参进行解析处理，并且在其中使用<code>WebDataBinderFactory</code>创建<code>DataBinder</code>将请求中附带的属性绑定到形参中，然后利用反射的方式来执行方法</p>
</li>
<li><p>获取到方法的返回值过后，利用合适的<code>HandlerMethodReturnValueHandler</code>对返回值也就是<code>view</code>进行处理，然后放入<code>mavContainer</code></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/SpringMVC%E4%B8%ADdataBinder%E5%85%A5%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/SpringMVC%E4%B8%ADdataBinder%E5%85%A5%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" itemprop="url">SpringMVC中DataBinder对入参类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="DataBinder"><a href="#DataBinder" class="headerlink" title="DataBinder"></a>DataBinder</h3><p><code>DataBinder</code>在<code>SpringMVC</code>中起的作用主要是为<code>Request</code>中参数转化为对应的入参类型</p>
<h3 id="注册自己的PropertyEditor"><a href="#注册自己的PropertyEditor" class="headerlink" title="注册自己的PropertyEditor"></a>注册自己的PropertyEditor</h3><p>由于<code>DataBinder</code>实现了<code>PropertyEditorRegistry</code>接口，所以有了注册属性编辑器的方法，我们可以手动添加我们需要的<code>PropertyEditor</code>，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@InitBinder</span><br><span class="line">public void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">	SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">	sdf.setLenient(false);</span><br><span class="line">	binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会被收录在<code>WebDataBinderFactory</code>中，然后在创建和初始化<code>DataBinder</code>对象时，将<code>DataBinder</code>作为入参调用这个方法来注入<code>PropertyEditor</code></p>
<h3 id="conversionservice"><a href="#conversionservice" class="headerlink" title="conversionservice"></a>conversionservice</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这个配置默认注册了<code>FormattingConversionServiceFactoryBean</code>来创将一个<code>DefaultFormattingConversionService</code>，其中注册了许多<code>converter</code>用来进行类型转换</p>
<h3 id="转化过程"><a href="#转化过程" class="headerlink" title="转化过程"></a>转化过程</h3><p>既然是将参数转化为入参需要的类型，那应该发生在参数解析的时候，先看简单的例如<code>int</code>类型的转化</p>
<p>解析它的参数解析器为<code>RequestParamMethodArgumentResolver</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,</span><br><span class="line">		NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">	&#x2F;&#x2F;获取这个入参的参数类型</span><br><span class="line">	Class&lt;?&gt; paramType &#x3D; parameter.getParameterType();</span><br><span class="line">	&#x2F;&#x2F;获取@RequestParam的值</span><br><span class="line">	NamedValueInfo namedValueInfo &#x3D; getNamedValueInfo(parameter);</span><br><span class="line">	&#x2F;&#x2F;根据@RequestParam从request获取该参数的值</span><br><span class="line">	Object arg &#x3D; resolveName(namedValueInfo.name, parameter, webRequest);</span><br><span class="line">	if (arg &#x3D;&#x3D; null) &#123;</span><br><span class="line">		if (namedValueInfo.defaultValue !&#x3D; null) &#123;</span><br><span class="line">			arg &#x3D; resolveDefaultValue(namedValueInfo.defaultValue);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (namedValueInfo.required &amp;&amp; !parameter.getParameterType().getName().equals(&quot;java.util.Optional&quot;)) &#123;</span><br><span class="line">			handleMissingValue(namedValueInfo.name, parameter);</span><br><span class="line">		&#125;</span><br><span class="line">		arg &#x3D; handleNullValue(namedValueInfo.name, arg, paramType);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (&quot;&quot;.equals(arg) &amp;&amp; namedValueInfo.defaultValue !&#x3D; null) &#123;</span><br><span class="line">		arg &#x3D; resolveDefaultValue(namedValueInfo.defaultValue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (binderFactory !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建DataBinder</span><br><span class="line">		WebDataBinder binder &#x3D; binderFactory.createBinder(webRequest, null, namedValueInfo.name);</span><br><span class="line">		&#x2F;&#x2F;将从Request中获取的参数值转化为入参需要的类型paramType</span><br><span class="line">		arg &#x3D; binder.convertIfNecessary(arg, paramType, parameter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"></span><br><span class="line">	return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化过程发生在<code>arg = binder.convertIfNecessary(arg, paramType, parameter);</code></p>
<p>先看<code>DataBinder</code>初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line">	WebDataBinder dataBinder &#x3D; createBinderInstance(target, objectName, webRequest);</span><br><span class="line">	if (this.initializer !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;target为null的话，只将conversionservice注入到DataBinder</span><br><span class="line">		&#x2F;&#x2F;否则也一并注入到DataBinder内部变量BindingResult和它的</span><br><span class="line">		&#x2F;&#x2F;内部变量BeanWrapperImpl中</span><br><span class="line">		this.initializer.initBinder(dataBinder, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;调用@InitBinder方法</span><br><span class="line">	initBinder(dataBinder, webRequest);</span><br><span class="line">	return dataBinder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用的构造函数</span><br><span class="line">public DataBinder(Object target, String objectName) &#123;</span><br><span class="line">	if (target !&#x3D; null &amp;&amp; target.getClass().equals(javaUtilOptionalClass)) &#123;</span><br><span class="line">		this.target &#x3D; OptionalUnwrapper.unwrap(target);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		this.target &#x3D; target;</span><br><span class="line">	&#125;</span><br><span class="line">	this.objectName &#x3D; objectName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里<code>target</code>为<code>null</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T convertIfNecessary(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)</span><br><span class="line">		throws TypeMismatchException &#123;</span><br><span class="line"></span><br><span class="line">	return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getTypeConverter()</code>获取转换器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected TypeConverter getTypeConverter() &#123;</span><br><span class="line">	if (getTarget() !&#x3D; null) &#123;</span><br><span class="line">		return getInternalBindingResult().getPropertyAccessor();</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return getSimpleTypeConverter();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>target</code>为<code>null</code>，使用简单转换器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected SimpleTypeConverter getSimpleTypeConverter() &#123;</span><br><span class="line">	if (this.typeConverter &#x3D;&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建typeConverter</span><br><span class="line">		this.typeConverter &#x3D; new SimpleTypeConverter();</span><br><span class="line">		if (this.conversionService !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;注入conversionservice</span><br><span class="line">			this.typeConverter.setConversionService(this.conversionService);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return this.typeConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">public SimpleTypeConverter() &#123;</span><br><span class="line">	this.typeConverterDelegate &#x3D; new TypeConverterDelegate(this);</span><br><span class="line">	&#x2F;&#x2F;注册默认PropertyEditor</span><br><span class="line">	registerDefaultEditors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用简单转换器进行类型转化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T convertIfNecessary(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam)</span><br><span class="line">		throws TypeMismatchException &#123;</span><br><span class="line"></span><br><span class="line">	return doConvert(value, requiredType, methodParam, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private &lt;T&gt; T doConvert(Object value, Class&lt;T&gt; requiredType, MethodParameter methodParam, Field field)</span><br><span class="line">		throws TypeMismatchException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		if (field !&#x3D; null) &#123;</span><br><span class="line">			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, field);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, methodParam);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ConverterNotFoundException ex) &#123;</span><br><span class="line">		throw new ConversionNotSupportedException(value, requiredType, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ConversionException ex) &#123;</span><br><span class="line">		throw new TypeMismatchException(value, requiredType, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IllegalStateException ex) &#123;</span><br><span class="line">		throw new ConversionNotSupportedException(value, requiredType, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IllegalArgumentException ex) &#123;</span><br><span class="line">		throw new TypeMismatchException(value, requiredType, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>simpleTypeConverter</code>的成员变量<code>typeConverterDelegate</code>转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T convertIfNecessary(Object newValue, Class&lt;T&gt; requiredType, MethodParameter methodParam)</span><br><span class="line">		throws IllegalArgumentException &#123;</span><br><span class="line"></span><br><span class="line">	return convertIfNecessary(null, null, newValue, requiredType,</span><br><span class="line">			(methodParam !&#x3D; null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后到关键代码，这里的<code>propertyEditorRegistry</code>指向的就是之前的<code>simpleTypeConverter</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T convertIfNecessary(String propertyName, Object oldValue, Object newValue,</span><br><span class="line">		Class&lt;T&gt; requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException &#123;</span><br><span class="line"></span><br><span class="line">	Object convertedValue &#x3D; newValue;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Custom editor for this type?</span><br><span class="line">	&#x2F;&#x2F;查找我们通过@InitBinder注入的PropertyEditor适用吗</span><br><span class="line">	PropertyEditor editor &#x3D; this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);</span><br><span class="line"></span><br><span class="line">	ConversionFailedException firstAttemptEx &#x3D; null;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; No custom editor but custom ConversionService specified?</span><br><span class="line">	&#x2F;&#x2F;找不到则从conversionService中查找适用的&#96;Converter&#96;</span><br><span class="line">	ConversionService conversionService &#x3D; this.propertyEditorRegistry.getConversionService();</span><br><span class="line">	&#x2F;&#x2F;没有找到自定义的PropertyEditor时且conversionservice中有适用的converter</span><br><span class="line">	&#x2F;&#x2F;使用它来进行类型转换</span><br><span class="line">	if (editor &#x3D;&#x3D; null &amp;&amp; conversionService !&#x3D; null &amp;&amp; convertedValue !&#x3D; null &amp;&amp; typeDescriptor !&#x3D; null) &#123;</span><br><span class="line">		TypeDescriptor sourceTypeDesc &#x3D; TypeDescriptor.forObject(newValue);</span><br><span class="line">		TypeDescriptor targetTypeDesc &#x3D; typeDescriptor;</span><br><span class="line">		if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (ConversionFailedException ex) &#123;</span><br><span class="line">				&#x2F;&#x2F; fallback to default conversion logic below</span><br><span class="line">				firstAttemptEx &#x3D; ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Value not of required type?</span><br><span class="line">	&#x2F;&#x2F;自定义的PropertyEditor适用时或者值的类型不属于要转换的那个类型</span><br><span class="line">	if (editor !&#x3D; null || (requiredType !&#x3D; null &amp;&amp; !ClassUtils.isAssignableValue(requiredType, convertedValue))) &#123;</span><br><span class="line">		&#x2F;&#x2F;String转集合</span><br><span class="line">		if (requiredType !&#x3D; null &amp;&amp; Collection.class.isAssignableFrom(requiredType) &amp;&amp; convertedValue instanceof String) &#123;</span><br><span class="line">			TypeDescriptor elementType &#x3D; typeDescriptor.getElementTypeDescriptor();</span><br><span class="line">			if (elementType !&#x3D; null &amp;&amp; Enum.class.isAssignableFrom(elementType.getType())) &#123;</span><br><span class="line">				convertedValue &#x3D; StringUtils.commaDelimitedListToStringArray((String) convertedValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;自定义PropertyEditor和conversionservice中都没有适用的</span><br><span class="line">		&#x2F;&#x2F;从默认注册的PropertyEditor中查找</span><br><span class="line">		if (editor &#x3D;&#x3D; null) &#123;</span><br><span class="line">			editor &#x3D; findDefaultEditor(requiredType);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;进行转换，如果要转换的值convertedValue不属于String，转换用的是setValue方法</span><br><span class="line">		convertedValue &#x3D; doConvertValue(oldValue, convertedValue, requiredType, editor);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;以上对值的转换完成，由Object类型的convertedValue接收转换好的值</span><br><span class="line">	boolean standardConversion &#x3D; false;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;以下应该是根据requiredType对转换好的值convertedValue进行再处理</span><br><span class="line">	if (requiredType !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Try to apply some standard type conversion rules if appropriate.</span><br><span class="line"></span><br><span class="line">		if (convertedValue !&#x3D; null) &#123;</span><br><span class="line">			if (Object.class.equals(requiredType)) &#123;</span><br><span class="line">				return (T) convertedValue;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (requiredType.isArray()) &#123;</span><br><span class="line">				&#x2F;&#x2F; Array required -&gt; apply appropriate conversion of elements.</span><br><span class="line">				if (convertedValue instanceof String &amp;&amp; Enum.class.isAssignableFrom(requiredType.getComponentType())) &#123;</span><br><span class="line">					convertedValue &#x3D; StringUtils.commaDelimitedListToStringArray((String) convertedValue);</span><br><span class="line">				&#125;</span><br><span class="line">				return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());</span><br><span class="line">			&#125;</span><br><span class="line">			else if (convertedValue instanceof Collection) &#123;</span><br><span class="line">				&#x2F;&#x2F; Convert elements to target type, if determined.</span><br><span class="line">				convertedValue &#x3D; convertToTypedCollection(</span><br><span class="line">						(Collection&lt;?&gt;) convertedValue, propertyName, requiredType, typeDescriptor);</span><br><span class="line">				standardConversion &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (convertedValue instanceof Map) &#123;</span><br><span class="line">				&#x2F;&#x2F; Convert keys and values to respective target type, if determined.</span><br><span class="line">				convertedValue &#x3D; convertToTypedMap(</span><br><span class="line">						(Map&lt;?, ?&gt;) convertedValue, propertyName, requiredType, typeDescriptor);</span><br><span class="line">				standardConversion &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">			if (convertedValue.getClass().isArray() &amp;&amp; Array.getLength(convertedValue) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">				convertedValue &#x3D; Array.get(convertedValue, 0);</span><br><span class="line">				standardConversion &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">			if (String.class.equals(requiredType) &amp;&amp; ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) &#123;</span><br><span class="line">				&#x2F;&#x2F; We can stringify any primitive value...</span><br><span class="line">				return (T) convertedValue.toString();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (convertedValue instanceof String &amp;&amp; !requiredType.isInstance(convertedValue)) &#123;</span><br><span class="line">				if (firstAttemptEx &#x3D;&#x3D; null &amp;&amp; !requiredType.isInterface() &amp;&amp; !requiredType.isEnum()) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						Constructor&lt;T&gt; strCtor &#x3D; requiredType.getConstructor(String.class);</span><br><span class="line">						return BeanUtils.instantiateClass(strCtor, convertedValue);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (NoSuchMethodException ex) &#123;</span><br><span class="line">						&#x2F;&#x2F; proceed with field lookup</span><br><span class="line">						if (logger.isTraceEnabled()) &#123;</span><br><span class="line">							logger.trace(&quot;No String constructor found on type [&quot; + requiredType.getName() + &quot;]&quot;, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Exception ex) &#123;</span><br><span class="line">						if (logger.isDebugEnabled()) &#123;</span><br><span class="line">							logger.debug(&quot;Construction via String failed for type [&quot; + requiredType.getName() + &quot;]&quot;, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				String trimmedValue &#x3D; ((String) convertedValue).trim();</span><br><span class="line">				if (requiredType.isEnum() &amp;&amp; &quot;&quot;.equals(trimmedValue)) &#123;</span><br><span class="line">					&#x2F;&#x2F; It&#39;s an empty enum identifier: reset the enum value to null.</span><br><span class="line">					return null;</span><br><span class="line">				&#125;</span><br><span class="line">				convertedValue &#x3D; attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);</span><br><span class="line">				standardConversion &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; convertedValue &#x3D;&#x3D; null</span><br><span class="line">			if (javaUtilOptionalEmpty !&#x3D; null &amp;&amp; requiredType.equals(javaUtilOptionalEmpty.getClass())) &#123;</span><br><span class="line">				convertedValue &#x3D; javaUtilOptionalEmpty;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) &#123;</span><br><span class="line">			if (firstAttemptEx !&#x3D; null) &#123;</span><br><span class="line">				throw firstAttemptEx;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; Definitely doesn&#39;t match: throw IllegalArgumentException&#x2F;IllegalStateException</span><br><span class="line">			StringBuilder msg &#x3D; new StringBuilder();</span><br><span class="line">			msg.append(&quot;Cannot convert value of type [&quot;).append(ClassUtils.getDescriptiveType(newValue));</span><br><span class="line">			msg.append(&quot;] to required type [&quot;).append(ClassUtils.getQualifiedName(requiredType)).append(&quot;]&quot;);</span><br><span class="line">			if (propertyName !&#x3D; null) &#123;</span><br><span class="line">				msg.append(&quot; for property &#39;&quot;).append(propertyName).append(&quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (editor !&#x3D; null) &#123;</span><br><span class="line">				msg.append(&quot;: PropertyEditor [&quot;).append(editor.getClass().getName()).append(</span><br><span class="line">						&quot;] returned inappropriate value of type [&quot;).append(</span><br><span class="line">						ClassUtils.getDescriptiveType(convertedValue)).append(&quot;]&quot;);</span><br><span class="line">				throw new IllegalArgumentException(msg.toString());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				msg.append(&quot;: no matching editors or conversion strategy found&quot;);</span><br><span class="line">				throw new IllegalStateException(msg.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (firstAttemptEx !&#x3D; null) &#123;</span><br><span class="line">		if (editor &#x3D;&#x3D; null &amp;&amp; !standardConversion &amp;&amp; requiredType !&#x3D; null &amp;&amp; !Object.class.equals(requiredType)) &#123;</span><br><span class="line">			throw firstAttemptEx;</span><br><span class="line">		&#125;</span><br><span class="line">		logger.debug(&quot;Original ConversionService attempt failed - ignored since &quot; +</span><br><span class="line">				&quot;PropertyEditor based conversion eventually succeeded&quot;, firstAttemptEx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return (T) convertedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，参数解析器中对参数进行类型转化完成，接着后面会用反射调用方法，将这个作为转化后的值作为入参</p>
<p>当然这个属于单个属性的转换，我们经常会用到使用一个类来接收我们需要的多个属性参数，这种情况就使用到了<code>BeanWrapperImpl</code>这个类了，它继承了<code>AbstractPropertyAccessor</code>，可以对类中属性进行操作，同时它也有个形参<code>conversionservice</code>，和实现了接口<code>PropertyEditorRegistry</code>接口，有了给我们注入自定义<code>PropertyEditor</code>的功能</p>
<p>转换过程差不多，解析到参数为复杂类时，在创建<code>DataBinder</code>时，创建了内部变量<code>BindingResult</code>和它的内部变量<code>BeanWrapperImpl</code>，然后初始化注入自定义<code>PropertyEditor</code>和<code>conversionservice</code>，哦还有将这个参数类反射实例化通过构造方法传入<code>BeanWrapperImpl</code>，然后调用<code>BeanWrapperImpl</code>的<code>setProperty</code>将请求中参数名字和参数值设置到类中对应的属性，所以请求中参数名一定要和属性名相等</p>
<p>在这个过程中，通过<code>BeanWrapperImpl</code>中的<code>cachedIntrospectionResults</code>获取所有属性的<code>PropertyDescriptor</code>对象，通过这个对象中的属性的<code>get</code>,<code>set</code>方法确认属性的具体类型，然后开始和我们上面一样的转换过程</p>
<p>转换完之后调用<code>PropertyDescriptor</code>中属性的<code>set</code>方法将值注入类中</p>
<p>循环完成之后就完成了对将请求中属性绑定到入参的类中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/ReentrantReadWriteLock%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E4%BA%AB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/ReentrantReadWriteLock%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E4%BA%AB%E9%94%81/" itemprop="url">ReentrantReadWriteLock的共享锁和独享锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="共享锁和独享锁操作state"><a href="#共享锁和独享锁操作state" class="headerlink" title="共享锁和独享锁操作state"></a>共享锁和独享锁操作state</h3><p>ReentrantReadWriteLock中共享锁和独享锁对锁的操作还是共同操作一个变量<code>state</code>，那怎么区分这个<code>state</code>是共享锁取得锁还是独享锁取得锁呢</p>
<p>从ReentrantReadWriteLock的源码我们来看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final int SHARED_SHIFT   &#x3D; 16</span><br><span class="line"></span><br><span class="line">static final int EXCLUSIVE_MASK &#x3D; (1 &lt;&lt; SHARED_SHIFT) - 1</span><br><span class="line"></span><br><span class="line">&#x2F;** Returns the number of shared holds represented in count  *&#x2F;</span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">&#x2F;** Returns the number of exclusive holds represented in count  *&#x2F;</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>下面两个方法传入<code>state</code>，返回共享锁取得锁次数和独享锁取得锁次数</p>
<p>其中获取共享锁次数的方式为将<code>state</code>无符号右移16位</p>
<p>获取独享锁次数的方式为将<code>state</code>与<code>EXCLUSIVE_MASK</code>进行并运算，<code>EXCLUSIVE_MASK</code>为32位int型，前16位为0，后16位为1</p>
<p>所以<code>state</code>区分独享锁和共享锁次数的方法为，将<code>state</code>32位一分为二，前16位用来表示共享锁获取次数，后16位用来表示独享锁获取次数</p>
<h3 id="共享锁和独享锁在获取锁时的区别"><a href="#共享锁和独享锁在获取锁时的区别" class="headerlink" title="共享锁和独享锁在获取锁时的区别"></a>共享锁和独享锁在获取锁时的区别</h3><p>读锁用的就是共享锁，我们知道多个线程是可以同时获取读锁的</p>
<p>读锁获取锁的源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而写锁获取锁的源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是一样的先尝试获取锁，失败之后放入<code>waitingqueue</code>等待唤醒</p>
<p>我们看获取锁有什么区别，下面是获取独享锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Walkthrough:</span><br><span class="line">     * 1. If read count nonzero or write count nonzero</span><br><span class="line">     *    and owner is a different thread, fail.</span><br><span class="line">     * 2. If count would saturate, fail. (This can only</span><br><span class="line">     *    happen if count is already nonzero.)</span><br><span class="line">     * 3. Otherwise, this thread is eligible for lock if</span><br><span class="line">     *    it is either a reentrant acquire or</span><br><span class="line">     *    queue policy allows it. If so, update state</span><br><span class="line">     *    and set owner.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    int w &#x3D; exclusiveCount(c);</span><br><span class="line">    if (c !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; (Note: if c !&#x3D; 0 and w &#x3D;&#x3D; 0 then shared count !&#x3D; 0)</span><br><span class="line">        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        &#x2F;&#x2F; Reentrant acquire</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        return false;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当c!=0且w==0时，说明存在线程获取了读锁，没有线程获取了写锁，此时想要获取写锁，则需要进入waitingqueue排队</p>
<p>当c==0时，即没有线程获取写锁和读锁，线程直接获取写锁</p>
<p>读锁想重入写锁需要进入waitingqueue</p>
<p>下面是获取共享锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Walkthrough:</span><br><span class="line">     * 1. If write lock held by another thread, fail.</span><br><span class="line">     * 2. Otherwise, this thread is eligible for</span><br><span class="line">     *    lock wrt state, so ask if it should block</span><br><span class="line">     *    because of queue policy. If not, try</span><br><span class="line">     *    to grant by CASing state and updating count.</span><br><span class="line">     *    Note that step does not check for reentrant</span><br><span class="line">     *    acquires, which is postponed to full version</span><br><span class="line">     *    to avoid having to check hold count in</span><br><span class="line">     *    the more typical non-reentrant case.</span><br><span class="line">     * 3. If step 2 fails either because thread</span><br><span class="line">     *    apparently not eligible or CAS fails or count</span><br><span class="line">     *    saturated, chain to version with full retry loop.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (exclusiveCount(c) !&#x3D; 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() !&#x3D; current)</span><br><span class="line">        return -1;</span><br><span class="line">    int r &#x3D; sharedCount(c);</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        if (r &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            firstReader &#x3D; current;</span><br><span class="line">            firstReaderHoldCount &#x3D; 1;</span><br><span class="line">        &#125; else if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">            if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">                cachedHoldCounter &#x3D; rh &#x3D; readHolds.get();</span><br><span class="line">            else if (rh.count &#x3D;&#x3D; 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享锁对应的也先获取独享锁获取次数，如果已经有获取独享锁的线程了，那就进waitingqueue</p>
<p>如果此时没有线程获取独享锁，且waitingqueue中也没有exclusive模式的Node在排队，直接获取读锁，并且因为不像独享锁，它的特性exclusive使得它可以用<code>state</code>来记录重入的次数，而共享锁可以多个线程同时获取锁，所以这里用了<code>ThreadLocal</code>在线程中存放每个读锁重入的次数</p>
<p>如果是写锁要重入读锁，可以直接获取读锁</p>
<p><strong>根据以上特性我们可以初步总结到，当没有线程获取到写锁时，多个线程都可以获取到读锁，并且不需要进入waitingqueue，但是当有线程尝试获取写锁时，由于已经有线程获取了读锁，所以它要进入waitingqueue，此时后续想要获取读锁的线程也只能进入waitingqueue</strong></p>
<h3 id="共享锁和独享锁唤醒successor的区别"><a href="#共享锁和独享锁唤醒successor的区别" class="headerlink" title="共享锁和独享锁唤醒successor的区别"></a>共享锁和独享锁唤醒successor的区别</h3><h4 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h4><p>我们知道，独享锁只有在<code>unlock()</code>的时候才会唤醒下个被挂起的线程，而waitingqueue中共享锁模式的Node总共有两次换新下个被挂起的线程，一次在被唤醒获取到锁之后，一次是在<code>unlock()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Try to signal next queued node if:</span><br><span class="line">     *   Propagation was indicated by caller,</span><br><span class="line">     *     or was recorded (as h.waitStatus either before</span><br><span class="line">     *     or after setHead) by a previous operation</span><br><span class="line">     *     (note: this uses sign-check of waitStatus because</span><br><span class="line">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">     * and</span><br><span class="line">     *   The next node is waiting in shared mode,</span><br><span class="line">     *     or we don&#39;t know, because it appears null</span><br><span class="line">     *</span><br><span class="line">     * The conservatism in both of these checks may cause</span><br><span class="line">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">     * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">     * anyway.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Node中线程获取到锁之后，会将自己设置为头节点Head，但是共享锁比起独享锁在这一步多了操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line">    setHead(node);</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Try to signal next queued node if:</span><br><span class="line">     *   Propagation was indicated by caller,</span><br><span class="line">     *     or was recorded (as h.waitStatus either before</span><br><span class="line">     *     or after setHead) by a previous operation</span><br><span class="line">     *     (note: this uses sign-check of waitStatus because</span><br><span class="line">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">     * and</span><br><span class="line">     *   The next node is waiting in shared mode,</span><br><span class="line">     *     or we don&#39;t know, because it appears null</span><br><span class="line">     *</span><br><span class="line">     * The conservatism in both of these checks may cause</span><br><span class="line">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">     * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">     * anyway.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后调用了<code>doReleaseShared()</code>方法，唤醒下一个节点如果这个节点模式也为<code>Shared</code></p>
<p>而在<code>unlock()</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也调用了<code>doReleaseShared()</code>方法唤醒下一个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Ensure that a release propagates, even if there are other</span><br><span class="line">     * in-progress acquires&#x2F;releases.  This proceeds in the usual</span><br><span class="line">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">     * ensure that upon release, propagation continues.</span><br><span class="line">     * Additionally, we must loop in case a new node is added</span><br><span class="line">     * while we are doing this. Also, unlike other uses of</span><br><span class="line">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">     * fails, if so rechecking.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是唤醒下一个节点的源码，是一个for循环，只有<code>h==head</code>才能跳出循环</p>
<p>共享锁多出的这一步获取锁之后唤醒下一个模式为<code>shared</code>的节点的线程，目的应该是将多个连续的<code>shared</code>节点的线程都唤醒</p>
<p>但是在这一步可能会出现的问题是，如果唤醒下一个<code>shared</code>，在它获取锁将自己设置为Head之前，此时来到<code>h==head</code>，则循环结束，正好是一个链式唤醒<br>如果在下一个<code>shared</code>获取锁将自己设置为Head之后，此时h!=head，这样会造成什么后果，多个线程在执行自己代码之前，循环唤醒下个节点，这叫”调用风暴”，这极大地加速了唤醒后继节点的速度，提升了效率，同时该方法内部的CAS操作又保证了多个线程同时唤醒一个节点时，只有一个线程能操作成功。<br>直到下一个<code>exclusive</code>，因为有线程持有读锁，所以唤醒的线程获取不了写锁，唤醒终止，此时<code>head</code>不变，<code>h==head</code>恒成立，所有<code>doReleaseShared</code>循环结束，获取读锁的线程执行自己代码</p>
<h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><p>两种锁在这一步相似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    if (firstReader &#x3D;&#x3D; current) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert firstReaderHoldCount &gt; 0;</span><br><span class="line">        if (firstReaderHoldCount &#x3D;&#x3D; 1)</span><br><span class="line">            firstReader &#x3D; null;</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        HoldCounter rh &#x3D; cachedHoldCounter;</span><br><span class="line">        if (rh &#x3D;&#x3D; null || rh.tid !&#x3D; getThreadId(current))</span><br><span class="line">            rh &#x3D; readHolds.get();</span><br><span class="line">        int count &#x3D; rh.count;</span><br><span class="line">        if (count &lt;&#x3D; 1) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;&#x3D; 0)</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; getState();</span><br><span class="line">        int nextc &#x3D; c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            &#x2F;&#x2F; Releasing the read lock has no effect on readers,</span><br><span class="line">            &#x2F;&#x2F; but it may allow waiting writers to proceed if</span><br><span class="line">            &#x2F;&#x2F; both read and write locks are now free.</span><br><span class="line">            return nextc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后这个for循环作用，只用当读锁全部释放完，且没有线程占有写锁的情况下，共享锁会唤醒下一个节点</p>
<p>为什么要强调没有线程占有写锁，我想可能是写锁重入读锁的问题，当写锁重入读锁，读锁<code>unlock()</code>的时候，也就是这一步，加这个条件，此时会尝试唤醒下一个线程，并且会改变<code>waitStatus</code>的状态为0(每次要唤醒下一个节点，都会把头节点<code>waitStatus</code>从<code>signal</code>变为0)，会导致什么后果呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>waitStatus</code>变为0，这里无法唤醒下一个waitingqueue节点的线程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/Mysql%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/Mysql%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" itemprop="url">Mysql语法练习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="表名和字段"><a href="#表名和字段" class="headerlink" title="表名和字段"></a>表名和字段</h3><p>学生表<br>Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别<br>课程表<br>Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号<br>教师表<br>Teacher(t_id,t_name) –教师编号,教师姓名<br>成绩表<br>Score(s_id,c_id,s_score) –学生编号,课程编号,分数</p>
<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--建表</span><br><span class="line">--学生表</span><br><span class="line">CREATE TABLE &#96;Student&#96;(</span><br><span class="line">    &#96;s_id&#96; VARCHAR(20),</span><br><span class="line">    &#96;s_name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">    &#96;s_birth&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">    &#96;s_sex&#96; VARCHAR(10) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">    PRIMARY KEY(&#96;s_id&#96;)</span><br><span class="line">);</span><br><span class="line">--课程表</span><br><span class="line">CREATE TABLE &#96;Course&#96;(</span><br><span class="line">    &#96;c_id&#96;  VARCHAR(20),</span><br><span class="line">    &#96;c_name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">    &#96;t_id&#96; VARCHAR(20) NOT NULL,</span><br><span class="line">    PRIMARY KEY(&#96;c_id&#96;)</span><br><span class="line">);</span><br><span class="line">--教师表</span><br><span class="line">CREATE TABLE &#96;Teacher&#96;(</span><br><span class="line">    &#96;t_id&#96; VARCHAR(20),</span><br><span class="line">    &#96;t_name&#96; VARCHAR(20) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">    PRIMARY KEY(&#96;t_id&#96;)</span><br><span class="line">);</span><br><span class="line">--成绩表</span><br><span class="line">CREATE TABLE &#96;Score&#96;(</span><br><span class="line">    &#96;s_id&#96; VARCHAR(20),</span><br><span class="line">    &#96;c_id&#96;  VARCHAR(20),</span><br><span class="line">    &#96;s_score&#96; INT(3),</span><br><span class="line">    PRIMARY KEY(&#96;s_id&#96;,&#96;c_id&#96;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">--插入学生表测试数据</span><br><span class="line">insert into Student values(&#39;01&#39; , &#39;赵雷&#39; , &#39;1990-01-01&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;02&#39; , &#39;钱电&#39; , &#39;1990-12-21&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;03&#39; , &#39;孙风&#39; , &#39;1990-05-20&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;04&#39; , &#39;李云&#39; , &#39;1990-08-06&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;05&#39; , &#39;周梅&#39; , &#39;1991-12-01&#39; , &#39;女&#39;);</span><br><span class="line">insert into Student values(&#39;06&#39; , &#39;吴兰&#39; , &#39;1992-03-01&#39; , &#39;女&#39;);</span><br><span class="line">insert into Student values(&#39;07&#39; , &#39;郑竹&#39; , &#39;1989-07-01&#39; , &#39;女&#39;);</span><br><span class="line">insert into Student values(&#39;08&#39; , &#39;王菊&#39; , &#39;1990-01-20&#39; , &#39;女&#39;);</span><br><span class="line">--课程表测试数据</span><br><span class="line">insert into Course values(&#39;01&#39; , &#39;语文&#39; , &#39;02&#39;);</span><br><span class="line">insert into Course values(&#39;02&#39; , &#39;数学&#39; , &#39;01&#39;);</span><br><span class="line">insert into Course values(&#39;03&#39; , &#39;英语&#39; , &#39;03&#39;);</span><br><span class="line"> </span><br><span class="line">--教师表测试数据</span><br><span class="line">insert into Teacher values(&#39;01&#39; , &#39;张三&#39;);</span><br><span class="line">insert into Teacher values(&#39;02&#39; , &#39;李四&#39;);</span><br><span class="line">insert into Teacher values(&#39;03&#39; , &#39;王五&#39;);</span><br><span class="line"> </span><br><span class="line">--成绩表测试数据</span><br><span class="line">insert into Score values(&#39;01&#39; , &#39;01&#39; , 80);</span><br><span class="line">insert into Score values(&#39;01&#39; , &#39;02&#39; , 90);</span><br><span class="line">insert into Score values(&#39;01&#39; , &#39;03&#39; , 99);</span><br><span class="line">insert into Score values(&#39;02&#39; , &#39;01&#39; , 70);</span><br><span class="line">insert into Score values(&#39;02&#39; , &#39;02&#39; , 60);</span><br><span class="line">insert into Score values(&#39;02&#39; , &#39;03&#39; , 80);</span><br><span class="line">insert into Score values(&#39;03&#39; , &#39;01&#39; , 80);</span><br><span class="line">insert into Score values(&#39;03&#39; , &#39;02&#39; , 80);</span><br><span class="line">insert into Score values(&#39;03&#39; , &#39;03&#39; , 80);</span><br><span class="line">insert into Score values(&#39;04&#39; , &#39;01&#39; , 50);</span><br><span class="line">insert into Score values(&#39;04&#39; , &#39;02&#39; , 30);</span><br><span class="line">insert into Score values(&#39;04&#39; , &#39;03&#39; , 20);</span><br><span class="line">insert into Score values(&#39;05&#39; , &#39;01&#39; , 76);</span><br><span class="line">insert into Score values(&#39;05&#39; , &#39;02&#39; , 87);</span><br><span class="line">insert into Score values(&#39;06&#39; , &#39;01&#39; , 31);</span><br><span class="line">insert into Score values(&#39;06&#39; , &#39;03&#39; , 34);</span><br><span class="line">insert into Score values(&#39;07&#39; , &#39;02&#39; , 89);</span><br><span class="line">insert into Score values(&#39;07&#39; , &#39;03&#39; , 98);</span><br></pre></td></tr></table></figure>

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>查询”01”课程比”02”课程成绩高的学生的信息及课程分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.c_id,b.s_score,c.c_id <span class="keyword">AS</span> c_id2,c.s_score <span class="keyword">AS</span> s_score2 <span class="keyword">FROM</span> student a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score c <span class="keyword">on</span> a.s_id=c.s_id </span><br><span class="line"><span class="keyword">AND</span> c.c_id=<span class="string">'02'</span> <span class="keyword">where</span> b.s_score&gt;c.s_score <span class="keyword">and</span> b.c_id=<span class="string">'01'</span></span><br></pre></td></tr></table></figure>

<p><strong>同表内比较使用同表内联</strong></p>
<p>查询”01”课程比”02”课程成绩低的学生的信息及课程分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.c_id,b.s_score,c.c_id <span class="keyword">AS</span> c_id2,c.s_score <span class="keyword">AS</span> s_score2 <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score c <span class="keyword">on</span> a.s_id=c.s_id <span class="keyword">AND</span> c.c_id=<span class="string">'02'</span> <span class="keyword">where</span> b.s_score&lt;c.s_score <span class="keyword">and</span> b.c_id=<span class="string">'01'</span></span><br></pre></td></tr></table></figure>

<p>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score),<span class="number">2</span>) <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> avg_score&gt;=<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩(包括有成绩的和无成绩的)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score),<span class="number">2</span>) <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student a <span class="keyword">left</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> avg_score&lt;<span class="number">60</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> c.s_id,c.s_name,<span class="number">0</span> <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student c <span class="keyword">WHERE</span> c.s_id <span class="keyword">not</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s_id <span class="keyword">FROM</span> score)</span><br></pre></td></tr></table></figure>

<p><strong>UNION 用于合并两个或多个 SELECT 语句的结果集，并消去表中任何重复行</strong></p>
<p>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">COUNT</span>(b.c_id),<span class="keyword">SUM</span>(b.s_score) <span class="keyword">as</span> score <span class="keyword">FROM</span> student a <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id</span><br></pre></td></tr></table></figure>

<p>查询”李”姓老师的数量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(a.t_id) <span class="keyword">FROM</span> teacher a <span class="keyword">WHERE</span> a.t_name REGEXP <span class="string">'^李'</span>(<span class="keyword">like</span> <span class="string">'李%'</span>)</span><br></pre></td></tr></table></figure>

<p>查询学过”张三”老师授课的同学的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id <span class="keyword">in</span>(<span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> t_id =(<span class="keyword">select</span> t_id <span class="keyword">from</span> teacher <span class="keyword">where</span> t_name = <span class="string">'张三'</span>);</span><br></pre></td></tr></table></figure>

<p>查询没学过”张三”老师授课的同学的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> a.s_id <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> t_id <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> t_name=<span class="string">'张三'</span>)))	</span><br><span class="line"><span class="string">``</span><span class="string">`sql</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a,score b,score c <span class="keyword">where</span> a.s_id = b.s_id <span class="keyword">and</span> a.s_id = c.s_id <span class="keyword">and</span> b.c_id=<span class="string">'01'</span> <span class="keyword">and</span> c.c_id=<span class="string">'02'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>交叉连接：因为没有连接条件，所进行的表与表间的所有行的连接</strong></p>
<p>查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">where</span> a.s_id <span class="keyword">in</span> (<span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'01'</span> ) <span class="keyword">and</span> a.s_id <span class="keyword">NOT</span> <span class="keyword">in</span>(<span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'02'</span>)</span><br></pre></td></tr></table></figure>

<p>查询没有学全所有课程的同学的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">select</span> a.s_id <span class="keyword">from</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.s_id)&gt;<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>查询至少有一门课与学号为”01”的同学所学相同的同学的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> a.s_id <span class="keyword">from</span> score a <span class="keyword">where</span> a.c_id <span class="keyword">in</span>(<span class="keyword">select</span> a.c_id <span class="keyword">from</span> score a <span class="keyword">where</span> a.s_id=<span class="string">'01'</span>));</span><br></pre></td></tr></table></figure>

<p>查询和”01”号的同学学习的课程完全相同的其他同学的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">where</span> a.s_id <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id!=’<span class="number">01</span>’ <span class="keyword">and</span> c_id <span class="keyword">in</span>(<span class="keyword">select</span> c_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id=’<span class="number">01</span>’)<span class="keyword">group</span> <span class="keyword">by</span> s_id <span class="keyword">having</span> <span class="keyword">count</span>(<span class="number">1</span>)=(<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> score <span class="keyword">where</span> s_id=<span class="string">'01'</span>));</span><br></pre></td></tr></table></figure>

<p>查询没学过”张三”老师讲授的任一门课程的学生姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> a.s_id <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">WHERE</span> b.c_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t_id <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> t_name=<span class="string">'张三'</span>)))</span><br></pre></td></tr></table></figure>

<p>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score),<span class="number">2</span>) <span class="keyword">AS</span> avg_score <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">AND</span> b.s_score&lt;<span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> a.s_id <span class="keyword">having</span> <span class="keyword">count</span>(a.s_id)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>检索”01”课程分数小于60，按分数降序排列的学生信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">AND</span> b.c_id=’<span class="number">01</span>’ <span class="keyword">WHERE</span> b.s_score&lt;<span class="number">60</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b.s_score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,(<span class="keyword">SELECT</span> s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id = a.s_id <span class="keyword">AND</span> c_id=<span class="string">'01'</span>) <span class="keyword">AS</span> 语文,(<span class="keyword">SELECT</span> s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id = a.s_id <span class="keyword">AND</span> c_id=<span class="string">'02'</span>) <span class="keyword">AS</span> 数学,(<span class="keyword">SELECT</span> s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id = a.s_id <span class="keyword">AND</span> c_id = <span class="string">'03'</span>) <span class="keyword">AS</span> 英语,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(a.s_score),<span class="number">2</span>) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> score a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均分 <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率，及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.c_id,b.c_name,<span class="keyword">MAX</span>(s_score) <span class="keyword">AS</span> 最高分,<span class="keyword">MIN</span>(s_score) <span class="keyword">AS</span> 最低分,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">AS</span> 平均分,<span class="keyword">ROUND</span>(<span class="number">100</span><span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> a.s_score&gt;=<span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">WHEN</span> a.s_score <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>),<span class="number">2</span>) <span class="keyword">AS</span> 及格率,<span class="keyword">ROUND</span>(<span class="number">100</span>(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">70</span> <span class="keyword">and</span> a.s_score&lt;=<span class="number">80</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 中等率, <span class="keyword">ROUND</span>(<span class="number">100</span>(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">80</span> <span class="keyword">and</span> a.s_score&lt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 优良率,<span class="keyword">ROUND</span>(<span class="number">100</span>(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 优秀率 <span class="keyword">FROM</span> score a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course b <span class="keyword">ON</span> a.c_id = b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>按各科成绩进行排序，并显示排名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ,(@i:=@i+<span class="number">1</span>) 排名 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = ‘<span class="number">01</span>’ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">LIMIT</span> <span class="number">10000</span>) a,(<span class="keyword">SELECT</span> @i:=<span class="number">0</span>) <span class="keyword">AS</span> 排名 <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> ,(@j:=@j+<span class="number">1</span>) 排名 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = ‘<span class="number">02</span>’ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">LIMIT</span> <span class="number">10000</span>) a,(<span class="keyword">SELECT</span> @j:=<span class="number">0</span>) <span class="keyword">AS</span> 排名 <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> ,(@k:=@k+<span class="number">1</span>) 排名 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = ‘<span class="number">03</span>’ <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">LIMIT</span> <span class="number">10000</span>) a,(<span class="keyword">SELECT</span> @k:=<span class="number">0</span>) <span class="keyword">AS</span> 排名</span><br></pre></td></tr></table></figure>

<p>查询学生的总成绩并进行排名</p>
<p>查询学生平均成绩及其名次</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.s_id,@i:=@i+<span class="number">1</span> <span class="keyword">as</span> ‘不保留空缺排名’,@k:=(<span class="keyword">case</span> <span class="keyword">when</span> @avg_score=a.avg_s <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> ‘保留空缺排名’,@avg_score:=avg_s <span class="keyword">as</span> ‘平均分’<span class="keyword">from</span> (<span class="keyword">select</span> s_id,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_s <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id)a,(<span class="keyword">select</span> @avg_score:=<span class="number">0</span>,@i:=<span class="number">0</span>,@k:=<span class="number">0</span>)b;</span><br></pre></td></tr></table></figure>

<p>查询各科成绩前三名的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.s_id,a.c_id,a.s_score,b.* <span class="keyword">from</span> score a <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.c_id = b.c_id <span class="keyword">and</span> a.s_score&lt;b.s_score <span class="keyword">group</span> <span class="keyword">by</span> a.s_id,a.c_id,a.s_score <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(b.s_id)&lt;<span class="number">3</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.c_id,a.s_score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>查询每门课程被选修的学生数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.c_id,a.c_name,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">as</span> 数量 <span class="keyword">FROM</span> course a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.c_id = b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.c_id,a.c_name</span><br></pre></td></tr></table></figure>

<p>查询出只有两门课程的全部学生的学号和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>查询男生、女生人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_sex,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_sex</span><br></pre></td></tr></table></figure>

<p>查询名字中含有”风”字的学生信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_name <span class="keyword">RLIKE</span> “风”</span><br></pre></td></tr></table></figure>

<p>查询同名同性学生名单，并统计同名人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name,s_sex <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name,s_sex <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查询1990年出生的学生名单</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id,s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(s_birth)=’<span class="number">1990</span>’</span><br></pre></td></tr></table></figure>

<p>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.c_id,b.c_name,<span class="keyword">AVG</span>(a.s_score) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> score a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course b <span class="keyword">ON</span> a.c_id=b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均分 <span class="keyword">DESC</span>,b.c_id</span><br></pre></td></tr></table></figure>

<p>查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name,<span class="keyword">AVG</span>(b.s_score) <span class="keyword">AS</span> 平均分 <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name <span class="keyword">HAVING</span> 平均分&gt;=<span class="number">85</span></span><br></pre></td></tr></table></figure>

<p>查询课程名称为”数学”，且分数低于60的学生姓名和分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.s_name,b.s_score <span class="keyword">from</span> score b <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student a <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id=(<span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> c_name =’数学’) <span class="keyword">and</span> b.s_score&lt;<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>查询所有学生的课程及分数情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.s_id,a.s_name,<span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> ‘语文’ <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> ‘语文’,<span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> ‘数学’ <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> ‘数学’,<span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> ‘英语’ <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> ‘英语’,<span class="keyword">SUM</span>(b.s_score) <span class="keyword">as</span> ‘总分’ <span class="keyword">from</span> student a <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> b.c_id = c.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name</span><br></pre></td></tr></table></figure>

<p>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_name,b.s_score,c.c_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id <span class="keyword">WHERE</span> b.s_score&gt;<span class="number">70</span></span><br></pre></td></tr></table></figure>

<p>查询不及格的课程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name,b.s_score,c.c_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id <span class="keyword">WHERE</span> b.s_score&lt;<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>查询课程编号为01且课程成绩在80分以上的学生的学号和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id,a.s_name <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">WHERE</span> b.s_score&gt;<span class="number">80</span> <span class="keyword">AND</span> b.c_id=’<span class="number">01</span>’</span><br></pre></td></tr></table></figure>

<p>求每门课程的学生人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br></pre></td></tr></table></figure>

<p>查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*,b.s_score,b.c_id,c.c_name <span class="keyword">from</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id <span class="keyword">where</span> b.c_id =(<span class="keyword">select</span> c_id <span class="keyword">from</span> course c,teacher d <span class="keyword">where</span> c.t_id=d.t_id <span class="keyword">and</span> d.t_name=’张三’) <span class="keyword">and</span> b.s_score <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">MAX</span>(s_score) <span class="keyword">from</span> score <span class="keyword">where</span> c_id=’<span class="number">02</span>’)</span><br></pre></td></tr></table></figure>

<p>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> b.s_id,b.c_id,b.s_score <span class="keyword">from</span> score a,score b <span class="keyword">where</span> a.c_id != b.c_id <span class="keyword">and</span> a.s_score = b.s_score</span><br></pre></td></tr></table></figure>

<p>查询每门功成绩最好的前两名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.s_id,a.c_id,a.s_score <span class="keyword">from</span> score a <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> score b <span class="keyword">where</span> b.c_id=a.c_id <span class="keyword">and</span> b.s_score&gt;=a.s_score)&lt;=<span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.c_id</span><br></pre></td></tr></table></figure>

<p>统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排 列，若人数相同，按课程号升序排列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.c_id,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">as</span> n <span class="keyword">FROM</span> score a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.c_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.c_id)&gt;<span class="number">5</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> n <span class="keyword">DESC</span>,c_id</span><br></pre></td></tr></table></figure>

<p>检索至少选修两门课程的学生学号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.s_id)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查询选修了全部课程的学生信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(a.s_id)&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>查询各学生的年龄(当前月日 &lt; 出生年月的月日则，年龄减一)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,<span class="keyword">YEAR</span>(<span class="keyword">NOW</span>())-<span class="keyword">YEAR</span>(s_birth)-(<span class="keyword">case</span> <span class="keyword">WHEN</span> <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>())-<span class="keyword">MONTH</span>(s_birth)&gt;<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">AS</span> 年龄 <span class="keyword">FROM</span> student</span><br></pre></td></tr></table></figure>

<p>查询本周过生日的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">WEEK</span>(<span class="keyword">NOW</span>())=<span class="keyword">WEEK</span>(s_birth)</span><br></pre></td></tr></table></figure>

<p>查询下周过生日的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> (<span class="keyword">WEEK</span>(<span class="keyword">NOW</span>())+<span class="number">1</span>)=<span class="keyword">WEEK</span>(s_birth)</span><br></pre></td></tr></table></figure>

<p>查询本月过生日的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(s_birth) = <span class="keyword">MONTH</span>(<span class="keyword">NOW</span>())</span><br></pre></td></tr></table></figure>

<p>查询下月过生日的学生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student WHERE MONTH(s_birth) &#x3D; (MONTH(NOW())+1)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/ReentrantLock%E8%8E%B7%E5%8F%96%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/ReentrantLock%E8%8E%B7%E5%8F%96%E9%94%81%E9%87%8A%E6%94%BE%E9%94%81%E6%BA%90%E7%A0%81/" itemprop="url">ReentrantLock获取锁释放锁源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p><code>ReentrantLock</code>中主要用到的核心类就是<code>AbstractQueuedSynchronizer</code>，例如最基本的获取锁和释放锁</p>
<p><code>private volatile int state</code>: The synchronization state，标记当前加锁状态的变量，初始为0，当有线程调用<code>lock</code>方法获取到锁时，它会变为1(重入时继续增1)</p>
<p><code>private transient volatile Node head</code>: 线程队列头</p>
<p><code>private transient volatile Node tail</code>: 线程队列尾</p>
<p>它有个内部类<code>Node</code>，每个线程为一个节点，以链表的结构实现多个线程排队</p>
<p><code>volatile Node prev;</code>: 上一个节点</p>
<p><code>volatile Node next</code>: 下一个节点</p>
<p><code>volatile int waitStatus</code>: 线程等待状态</p>
<p><code>volatile Thread thread</code>： 节点中的线程</p>
<p><code>volatile Node nextWaiter</code>: 节点锁的属性(shared和exclusive)</p>
<p>等待线程队列wait queue结构如下</p>
<p><img src="https://img-blog.csdnimg.cn/20190829203640524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1ODM1NjI0,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p><img src="https://raw.githubusercontent.com/sinaill/pic/master/Sync.png" alt=""> </p>
<p>ReentrantLock中有两种锁，公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>，公平锁遵循FIFO原则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建方法如上，默认创建非公平锁，如果想要创建公平锁，则需要构造函数传入<code>True</code></p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看两种锁的实现方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 非公平锁</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 公平锁</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到非公平锁在线程获取锁时，是采用<code>compareAndSetState(0, 1)</code>马上尝试获取锁</p>
<p>接着来到<code>acquire(1)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcquire</code>方法两种锁还是分别有自己的实现逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 公平锁的tryAcquire方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		&#x2F;&#x2F;当前锁空闲时，查看是否有线程队列排队中</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;锁被占用时，如果是用一个线程重入，state继续加1</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁即使在锁空闲时，仍会<code>hasQueuedPredecessors()</code>查看时候后面还有线程在队列派对中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    &#x2F;&#x2F; The correctness of this depends on head being initialized</span><br><span class="line">    &#x2F;&#x2F; before tail and on head.next being accurate if the current</span><br><span class="line">    &#x2F;&#x2F; thread is first in queue.</span><br><span class="line">    Node t &#x3D; tail; &#x2F;&#x2F; Read fields in reverse initialization order</span><br><span class="line">    Node h &#x3D; head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h !&#x3D; t &amp;&amp;</span><br><span class="line">        ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的<code>tryAcquire</code>继续调用<code>nonfairTryAcquire(int acquires)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		&#x2F;&#x2F;锁空闲时，继续抢锁</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是一样，<code>state==0</code>时继续抢锁</p>
<p>以上就是两种锁在抢锁时不同的地方，非公平锁相当于抢两次锁，没抢到就去排队，而公平锁会先看有没有线程在排队，没有时才抢锁</p>
<p>然后我们回到<code>acquire(int arg)</code>方法，这里可以看到线程是怎么排队的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addWaiter(Node.EXCLUSIVE)</code>方法创建新节点存放排队的线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);&#x2F;&#x2F;将创建的节点入队</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程创建一个节点，此时节点中<code>waitStatus</code>为0，然后将这个节点设置为<code>tail</code>，并且和上一个<code>tail</code>串联起来(将节点中<code>prev</code>指向上一个<code>tail</code>)，就这样，线程呈链表的形式排成队，接着进入<code>acquireQueued</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">			&#x2F;&#x2F;查看上一个节点是不是头节点，是的话抢锁</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);&#x2F;&#x2F;抢到锁将自己变为头节点</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接受的<code>node</code>是线程创建好的节点，然后线程开始以这样的形式，Head-&gt;线程节点1-&gt;线程节点2···，在for无条件循环中，每一个节点的线程检测上一个节点是否为头节点，是的话，尝试抢锁，成功之后把自己节点设置为头节点，Head-&gt;线程节点2···</p>
<p>非头节点时，进入<code>shouldParkAfterFailedAcquire(p, node)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>初始<code>waitStatus</code>为0，所以这里把前节点的<code>waitStatus</code>都设置为<code>Node.SIGNAL(-1)</code>，返回<code>false</code>，然后短路，第二次循环这里返回<code>true</code>，然后进入<code>parkAndCheckInterrupt()</code>，挂起线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把两次循环都没抢到锁的线程挂起</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryRelease(arg)</code>开始释放锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">	&#x2F;&#x2F;被锁的线程才能释放锁，否则抛出异常</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将<code>state</code>减1，等于0的时候释放锁，将<code>state</code>置0，返回<code>true</code>，此时如果有线程在排队(挂起状态)，<code>unparkSuccessor(h)</code>将线程回到运行状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">		&#x2F;&#x2F;唤醒Head后一个节点中的线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入<code>Head</code>节点，从前面可以知道，<code>Head</code>节点后面有线程节点排队时，<code>head</code>节点的<code>waitStatus</code>被置为<code>Node.SIGNAL</code>，即-1，这里重新置0，然后获取<code>Head</code>节点的下一个节点，如果不为空，则将节点中存放的创建该节点的线程唤醒</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/MyBatis%E5%A4%A7%E8%87%B4%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/MyBatis%E5%A4%A7%E8%87%B4%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/" itemprop="url">MyBatis大致运行流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原生调用方式"><a href="#原生调用方式" class="headerlink" title="原生调用方式"></a>原生调用方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种</span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  Blog blog &#x3D; (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种，使用到了代理(getMapper方法)</span><br><span class="line"></span><br><span class="line">SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog &#x3D; mapper.selectBlog(101);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集成框架后使用代理"><a href="#集成框架后使用代理" class="headerlink" title="集成框架后使用代理"></a>集成框架后使用代理</h3><ol>
<li>启动服务器后，自动创建数据库服务接口的代理类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MapperRegistry类的addMapper方法</span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">if (type.isInterface()) &#123;</span><br><span class="line">  if (hasMapper(type)) &#123;</span><br><span class="line">    throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  boolean loadCompleted &#x3D; false;</span><br><span class="line">  try &#123;</span><br><span class="line">	&#x2F;&#x2F;每个接口对应一个代理工厂实例</span><br><span class="line">    knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">    &#x2F;&#x2F; It&#39;s important that the type is added before the parser is run</span><br><span class="line">    &#x2F;&#x2F; otherwise the binding may automatically be attempted by the</span><br><span class="line">    &#x2F;&#x2F; mapper parser. If the type is already known, it won&#39;t try.</span><br><span class="line">    MapperAnnotationBuilder parser &#x3D; new MapperAnnotationBuilder(config, type);</span><br><span class="line">    parser.parse();</span><br><span class="line">    loadCompleted &#x3D; true;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (!loadCompleted) &#123;</span><br><span class="line">      knownMappers.remove(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>触发Spring的autowire自动向service注入接口的代理类，通过sqlsession的getMappder的方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">return getConfiguration().getMapper(type, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跟踪源码</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">	return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mapperRegistry就是初始化容器时，通过addMapper方法，给每个接口确定了对应的代理工厂实例</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">	return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;mapperRegistry类</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">&#x2F;&#x2F;取出之前添加的代理工厂类</span><br><span class="line">	final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">	if (mapperProxyFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">	  throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">	  &#x2F;&#x2F;使用代理工厂类创建代理类实例</span><br><span class="line">	  return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">	  throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;转进mapperProxyFactory类</span><br><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">	&#x2F;&#x2F;这行代码生成代理</span><br><span class="line">	return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">	final MapperProxy&lt;T&gt; mapperProxy &#x3D; new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">	return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>代理类的生成</li>
</ol>
<p>我们知道代理类的生成需要一个实现invocationHandler接口的类，在MyBatis中这个类为MapperProxy，查看invoke方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">   if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       return method.invoke(this, args);</span><br><span class="line">     &#125; catch (Throwable t) &#123;</span><br><span class="line">       throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">查看method方法对用的MapperMehtod是否存在，不存在则创建</span><br><span class="line">   final MapperMethod mapperMethod &#x3D; cachedMapperMethod(method);</span><br><span class="line">   return mapperMethod.execute(sqlSession, args);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private MapperMethod cachedMapperMethod(Method method) &#123;</span><br><span class="line">   MapperMethod mapperMethod &#x3D; methodCache.get(method);</span><br><span class="line">   if (mapperMethod &#x3D;&#x3D; null) &#123;</span><br><span class="line">     mapperMethod &#x3D; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">     methodCache.put(method, mapperMethod);</span><br><span class="line">   &#125;</span><br><span class="line">   return mapperMethod;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过代理调用原生调用方式</li>
</ol>
<p>通过MapperMehtod这个类来实现，先看下它的成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final SqlCommand command;</span><br><span class="line">private final MethodSignature method;</span><br><span class="line"></span><br><span class="line">public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123;</span><br><span class="line">  this.command &#x3D; new SqlCommand(config, mapperInterface, method);</span><br><span class="line">  this.method &#x3D; new MethodSignature(config, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看sqlcommand是什么，大概就是关于sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">  &#x2F;&#x2F;接口名加方法名，正好等于我们配置文件的命名空间namespace加上语句的id</span><br><span class="line">  String statementName &#x3D; mapperInterface.getName() + &quot;.&quot; + method.getName();</span><br><span class="line">  MappedStatement ms &#x3D; null;</span><br><span class="line">  if (configuration.hasStatement(statementName)) &#123;</span><br><span class="line">	&#x2F;&#x2F;大概是通过命名空间和id从配置文件查找具体配置对象</span><br><span class="line">    ms &#x3D; configuration.getMappedStatement(statementName);</span><br><span class="line">  &#125; else if (!mapperInterface.equals(method.getDeclaringClass())) &#123; &#x2F;&#x2F; issue #35</span><br><span class="line">    String parentStatementName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">    if (configuration.hasStatement(parentStatementName)) &#123;</span><br><span class="line">      ms &#x3D; configuration.getMappedStatement(parentStatementName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (ms &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if(method.getAnnotation(Flush.class) !&#x3D; null)&#123;</span><br><span class="line">      name &#x3D; null;</span><br><span class="line">      type &#x3D; SqlCommandType.FLUSH;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new BindingException(&quot;Invalid bound statement (not found): &quot; + statementName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    name &#x3D; ms.getId();</span><br><span class="line">    type &#x3D; ms.getSqlCommandType();</span><br><span class="line">    if (type &#x3D;&#x3D; SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">      throw new BindingException(&quot;Unknown execution method for: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看<code>MethodSignature</code>的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MethodSignature(Configuration configuration, Method method) &#123;</span><br><span class="line">  this.returnType &#x3D; method.getReturnType();</span><br><span class="line">  this.returnsVoid &#x3D; void.class.equals(this.returnType);</span><br><span class="line">  this.returnsMany &#x3D; (configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray());</span><br><span class="line">  this.mapKey &#x3D; getMapKey(method);</span><br><span class="line">  this.returnsMap &#x3D; (this.mapKey !&#x3D; null);</span><br><span class="line">  &#x2F;&#x2F;处理@Param</span><br><span class="line">  this.hasNamedParameters &#x3D; hasNamedParams(method);</span><br><span class="line">  this.rowBoundsIndex &#x3D; getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">  this.resultHandlerIndex &#x3D; getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">  this.params &#x3D; Collections.unmodifiableSortedMap(getParams(method, this.hasNamedParameters));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代理类中生成MethodMapper类后，调用execute方法来指定sqlcommand中的sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;args是由代理类invoke方法传来的方法参数</span><br><span class="line">   Object result;</span><br><span class="line">   if (SqlCommandType.INSERT &#x3D;&#x3D; command.getType()) &#123;</span><br><span class="line">     Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  &#x2F;&#x2F;getName返回具体配置语句对象的id</span><br><span class="line">     result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.UPDATE &#x3D;&#x3D; command.getType()) &#123;</span><br><span class="line">     Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.DELETE &#x3D;&#x3D; command.getType()) &#123;</span><br><span class="line">     Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">     result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">   &#125; else if (SqlCommandType.SELECT &#x3D;&#x3D; command.getType()) &#123;</span><br><span class="line">     if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">       executeWithResultHandler(sqlSession, args);</span><br><span class="line">       result &#x3D; null;</span><br><span class="line">     &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">       result &#x3D; executeForMany(sqlSession, args);</span><br><span class="line">     &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">       result &#x3D; executeForMap(sqlSession, args);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result &#x3D; sqlSession.selectOne(command.getName(), param);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else if (SqlCommandType.FLUSH &#x3D;&#x3D; command.getType()) &#123;</span><br><span class="line">       result &#x3D; sqlSession.flushStatements();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   if (result &#x3D;&#x3D; null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName() </span><br><span class="line">         + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;返回结果</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;对返回结果result进行类型转换</span><br><span class="line"> private Object rowCountResult(int rowCount) &#123;</span><br><span class="line">   final Object result;</span><br><span class="line">   if (method.returnsVoid()) &#123;</span><br><span class="line">     result &#x3D; null;</span><br><span class="line">   &#125; else if (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">     result &#x3D; Integer.valueOf(rowCount);</span><br><span class="line">   &#125; else if (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">     result &#x3D; Long.valueOf(rowCount);</span><br><span class="line">   &#125; else if (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">     result &#x3D; Boolean.valueOf(rowCount &gt; 0);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName() + &quot;&#39; has an unsupported return type: &quot; + method.getReturnType());</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinaill</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinaill</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <link rel="stylesheet" href="/lib/prettify/skins/desert.css" type="text/css">
<script src="/lib/prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
      prettyPrint();
  });
</script>
</body>
</html>
