<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="article:author" content="sinaill">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" itemprop="url">生产者消费者模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="synchornized"><a href="#synchornized" class="headerlink" title="synchornized"></a>synchornized</h3><pre><code>public class Threadpc {
    public static void main(String[] args) {
        storage storage = new storage();
        new producer(&quot;生产者1&quot;,storage,50).start();
        new producer(&quot;生产者2&quot;,storage,100).start();
        new producer(&quot;生产者3&quot;,storage,60).start();
        new consumer(&quot;消费者1&quot;, storage,20).start();
        new consumer(&quot;消费者2&quot;, storage,40).start();
        new consumer(&quot;消费者3&quot;, storage,60).start();
        new consumer(&quot;消费者4&quot;, storage,30).start();
        new consumer(&quot;消费者5&quot;, storage,50).start();
        new consumer(&quot;消费者6&quot;, storage,10).start();
    }
}

class storage{
    private final int MAX_SIZE = 100;
    private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;();
    public void consume(int num,String threadName){
        synchronized (list) {
            while(list.size()&lt;num){//库存小于要消费的数量
                try {
                    System.out.println(threadName+&quot;暂时无法进行消费,库存不足&quot;);
                    list.wait();
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            for (int i = 0; i &lt; num; i++) {
                list.remove();
            }
            System.out.println(threadName+&quot;消费产品&quot;+num+&quot;,剩余库存:&quot;+list.size());
            list.notifyAll();
        }

    }


    public void produce(int num,String threadName){
        synchronized (list) {
            while(num &gt; MAX_SIZE-list.size()){//生产数量超过库存限制
                try {
                    System.out.println(threadName+&quot;暂时无法进行生产,库存过多&quot;);
                    list.wait();
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            for (int i = 0; i &lt; num; i++) {
                list.add(new Object());
            }
            System.out.println(threadName+&quot;生产产品&quot;+num+&quot;,剩余库存:&quot;+list.size());
            list.notifyAll();
        }
    }
}

class consumer extends Thread{
    private int num;
    private storage storage;
    public consumer(String name,storage storage,int num) {
        super(name);
        // TODO Auto-generated constructor stub
        this.storage = storage;
        this.num = num;
    }
    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        storage.consume(num, Thread.currentThread().getName());
    }

}

class producer extends Thread{
    private int num;
    private storage storage;
    public producer(String name,storage storage,int num) {
        super(name);
        // TODO Auto-generated constructor stub
        this.storage = storage;
        this.num = num;
    }
    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        storage.produce(num, Thread.currentThread().getName());
    }

}</code></pre><p>创建多个线程，<code>run</code>方法中调用共有的<code>storage</code>实例的<code>produce</code>和<code>consume</code>方法，在两个方法中使用<code>synchronized</code>代码块进行同步，使用<code>storage</code>中的共有的<code>list</code>的对象锁和<code>wait</code>和<code>notifyall</code>方法来调度生产者和消费者进程交替。输出如下：</p>
<pre><code>生产者2生产产品100,剩余库存:100
生产者1暂时无法进行生产,库存过多
生产者3暂时无法进行生产,库存过多
消费者1消费产品20,剩余库存:80
生产者3暂时无法进行生产,库存过多
消费者4消费产品30,剩余库存:50
消费者6消费产品10,剩余库存:40
生产者1生产产品50,剩余库存:90
消费者3消费产品60,剩余库存:30
消费者2暂时无法进行消费,库存不足
生产者3生产产品60,剩余库存:90
消费者5消费产品50,剩余库存:40
消费者2消费产品40,剩余库存:0</code></pre><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code>锁的粒度比<code>synchronized</code>小，在尝试使用<code>synchronized</code>进行同样的分组唤醒，即生产者唤醒消费者和消费者唤醒生产者，忽略了一个要点，无论是执行对象的<code>wait</code>、<code>notify</code>还是<code>notifyAll</code>方法，必须保证当前运行的线程取得了该对象的锁，否则会报<code>java.lang.IllegalMonitorStateException</code>异常，发生异常代码如下</p>
<pre><code>public void consume(int num,String threadName){
    synchronized (o1) {
        System.out.println(threadName+&quot;获得锁&quot;);
        while(list.size()&lt;num){//库存小于要消费的数量
            try {
                System.out.println(threadName+&quot;暂时无法进行消费,库存不足&quot;);
                o1.wait();
                //list.wait();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (int i = 0; i &lt; num; i++) {
            list.remove();
        }
        System.out.println(threadName+&quot;消费产品&quot;+num+&quot;,剩余库存:&quot;+list.size());
        o2.notifyAll();//未取得o2对象锁，不能运行这个方法
    }</code></pre><p>下面用<code>ReentrantLock</code>来进行分组唤醒</p>
<pre><code>public class Threadpc {
    public static void main(String[] args) {
        storage storage = new storage2();
        new producer(&quot;生产者1&quot;,storage,50).start();
        new producer(&quot;生产者2&quot;,storage,100).start();
        new producer(&quot;生产者3&quot;,storage,60).start();
        new consumer(&quot;消费者1&quot;, storage,20).start();
        new consumer(&quot;消费者2&quot;, storage,40).start();
        new consumer(&quot;消费者3&quot;, storage,60).start();
        new consumer(&quot;消费者4&quot;, storage,30).start();
        new consumer(&quot;消费者5&quot;, storage,50).start();
        new consumer(&quot;消费者6&quot;, storage,10).start();
    }

}

class storage2{
    private int MAX_SIZE = 100;
    private ReentrantLock lock = new ReentrantLock();
    private Condition produce = lock.newCondition();
    private Condition consumer = lock.newCondition();
    private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;();

    public void consume(int num,String threadName){
        lock.lock();
        while(num &gt; list.size()){
            try {
                System.out.println(threadName+&quot;暂时无法消费,库存余量为:&quot;+list.size());
                consumer.await();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (int i = 0; i &lt; num; i++) {
            list.remove();
        }
        System.out.println(threadName+&quot;消费库存&quot;+num+&quot;,库存余量为&quot;+list.size());
        produce.signalAll();
        lock.unlock();
    }

    public void produce(int num,String threadName){
        lock.lock();
        while(num+list.size()&gt;MAX_SIZE){
            try {
                System.out.println(threadName+&quot;暂时无法生产,库存余量为:&quot;+list.size());
                produce.await();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for (int i = 0; i &lt; num; i++) {
            list.add(new Object());
        }
        System.out.println(threadName+&quot;生产库存&quot;+num+&quot;,库存余量为&quot;+list.size());
        consumer.signalAll();
        lock.unlock();
    }

}

class producer2 extends Thread{

    private storage storage;
    private int num;
    public producer(String name,storage storage,int num) {
        super(name);
        // TODO Auto-generated constructor stub
        this.storage = storage;
        this.num = num;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        storage.produce(num, Thread.currentThread().getName());
    }
}

class consumer2 extends Thread{
    private storage storage;
    private int num;
    public consumer2(String name,storage storage,int num) {
        super(name);
        // TODO Auto-generated constructor stub
        this.num = num;
        this.storage = storage;
    }
    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        storage.consume(num, Thread.currentThread().getName());
    }

}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84default%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84default%E6%96%B9%E6%B3%95/" itemprop="url">接口中的default方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>java接口中的default方法是在java 8之后引入的，即在不破坏java现有实现架构的情况下能往接口里增加新方法，这个特征又叫做虚拟扩展方法（Virtual extension methods），通常也称之为 defender 方法，它目前可以添加到接口中，为声明的方法提供默认的实现，子类可以直接调用或者复写该方法。作用为优化接口的同时，避免跟现有实现架构的兼容问题。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list.add(1);
list.add(2);
list.forEach(System.out::println);</code></pre><p>java8之后list多了一个forEach方法来方便我们遍历集合，向上查找父类和实现的接口发现Iterable接口中多了一个default方法</p>
<pre><code>/**
 * Performs the given action for each element of the {@code Iterable}
 * until all elements have been processed or the action throws an
 * exception.  Unless otherwise specified by the implementing class,
 * actions are performed in the order of iteration (if an iteration order
 * is specified).  Exceptions thrown by the action are relayed to the
 * caller.
 *
 * @implSpec
 * &lt;p&gt;The default implementation behaves as if:
 * &lt;pre&gt;{@code
 *     for (T t : this)
 *         action.accept(t);
 * }&lt;/pre&gt;
 *
 * @param action The action to be performed for each element
 * @throws NullPointerException if the specified action is null
 * @since 1.8
 */
default void forEach(Consumer&lt;? super T&gt; action) {
    Objects.requireNonNull(action);
    for (T t : this) {
        action.accept(t);
    }
}</code></pre><p>与此相同的还有Collection接口新增的stream方法，用来帮助我们更方便地处理集合元素</p>
<pre><code>/**
 * Returns a sequential {@code Stream} with this collection as its source.
 *
 * &lt;p&gt;This method should be overridden when the {@link #spliterator()}
 * method cannot return a spliterator that is {@code IMMUTABLE},
 * {@code CONCURRENT}, or &lt;em&gt;late-binding&lt;/em&gt;. (See {@link #spliterator()}
 * for details.)
 *
 * @implSpec
 * The default implementation creates a sequential {@code Stream} from the
 * collection&#39;s {@code Spliterator}.
 *
 * @return a sequential {@code Stream} over the elements in this collection
 * @since 1.8
 */
default Stream&lt;E&gt; stream() {
    return StreamSupport.stream(spliterator(), false);
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E6%9E%9A%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E6%9E%9A%E4%B8%BE/" itemprop="url">枚举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="理解枚举类型"><a href="#理解枚举类型" class="headerlink" title="理解枚举类型"></a>理解枚举类型</h3><p>枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性</p>
<h3 id="枚举用来定义常量"><a href="#枚举用来定义常量" class="headerlink" title="枚举用来定义常量"></a>枚举用来定义常量</h3><p><strong>枚举常量、类常量与静态常量</strong></p>
<p>平常我们定义普通常量的时候</p>
<pre><code>    public class Demo{
        public static final int OPEN =1;
        public static final int CLOSE=2;
    }</code></pre><p>上述的常量定义常量的方式称为int枚举模式，这样的定义方式并没有什么错，但它存在许多不足，如在类型安全和使用方便性上并没有多少好处，如果存在定义int值相同的变量，混淆的几率还是很大的，编译器也不会提出任何警告，因此这种方式在枚举出现后并不提倡，现在我们利用枚举类型来重新定义上述的常量，同时也感受一把枚举定义的方式</p>
<pre><code>    enum Demo{
        OPEN,CLOSE
    }
</code></pre><p>用普通常量的方式定义的话，值为<code>int</code>类型，用枚举来定义的话，取值<code>Demo.OPEN</code>输出为我们定义的枚举类型</p>
<h3 id="枚举的构造函数"><a href="#枚举的构造函数" class="headerlink" title="枚举的构造函数"></a>枚举的构造函数</h3><p>测试Demo</p>
<pre><code>enum fruit{
    apple(&quot;苹果&quot;),melon(&quot;西瓜&quot;);
    private String chinese;
    private fruit(String chinese) {
        this.chinese = chinese;
    }
    public String getChinese() {
        return chinese;
    }
    public void setChinese(String chinese) {
        this.chinese = chinese;
    }


}


    @Test
    void test3() {
        System.out.println(fruit.apple);
        //输出为apple
    }

    @Test
    void test3() {
        System.out.println(fruit.apple.getClass());
        //输出为class 本包.fruit，为自定义的枚举类型
    }

    //调用函数
    @Test
    void test3() {
        System.out.println(fruit.apple.getChinese);
        //输出苹果
    }

    //遍历枚举
    @Test
    void test3() {
        for(fruit f:fruit.values()) {
            System.out.println(f.getChinese());
        }
    }
</code></pre><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>枚举可以定义静态方法和非静态方法</p>
<p>枚举不能有继承</p>
<p>可以用在switch中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h3><p>关键排序代码如下</p>
<pre><code>public void bubble(int[] i){
    int temp;
    for(int j = 0;j &lt; i.length-1; j++){
        for(int k = 0; k &lt; i.length - j -1; k++){
            if(i[k] &gt; i[k+1]){
                temp = i[k];
                i[k] = i[k+1];
                i[k+1] = temp;
            }
        }
    }
}</code></pre><p>用来对一万个10000内随机数进行排序，所消耗时间为 <strong>耗时：14329ms</strong></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>关键代码如下</p>
<pre><code>public void selectionSort(int n[]) {
    for (int i = 0; i &lt; n.length - 1; i++) {
        int max = 0;
        for (int j = 0; j &lt; n.length - i - 1; j++) {
            if(n[max] &lt; n[j+1]){
                max = j+1;
            }
        }
        if (max != n.length-1-i) {
            int temp;
            temp = n[max];
            n[max] = n[n.length-1-i];
            n[n.length-1-i] = temp;
        }
    }
}</code></pre><p>用来对一万个10000内随机数进行排序，所消耗时间为 <strong>耗时：2657ms</strong></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>关键代码如下</p>
<pre><code>public void Insert(int n[]) {
    for (int i = 1; i &lt; n.length; i++) {
        int temp = i;
        for (int j = i -1; j &gt;= 0 &amp;&amp; n[j] &gt; n[temp]; j--) {
            exch(n, j, temp);
            temp = j;
        }
    }
}
public void exch(int n[],int a,int b) {
    int temp = n[a];
    n[a] = n[b];
    n[b] = temp;
}</code></pre><p>用来对一万个10000内随机数进行排序，所消耗时间为 <strong>耗时：3107ms</strong></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>关键代码如下</p>
<pre><code>    public void Quick(int n[],int left,int right) {
        if(left &gt;= right){
            return;
        }
        int key = PartSort(n, left, right);
        Quick(n, left, key);
        Quick(n, key+1, right);
    }
    public int PartSort(int n[],int left,int right) {
        int key = n[left];
        while(left &lt; right){
            while (left &lt; right &amp;&amp; n[right] &gt;= key) {
                right--;
            }
            n[left] = n[right];
            while (left &lt; right &amp;&amp; n[left] &lt;= key) {
                left++;
            }
            n[right] = n[left];
        }
        n[left] = key;
        return left;
    }
}</code></pre><p>用来对一万个10000内随机数进行排序，所消耗时间为 <strong>耗时：16ms</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E6%8E%88%E6%9D%83%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E6%8E%88%E6%9D%83%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="url">shiro授权三种用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shiro/" itemprop="url" rel="index">
                    <span itemprop="name">shiro</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>RequiresAuthentication:</p>
<ul>
<li>使用该注解标注的类，实例，方法在访问或调用时，当前Subject必须在当前session中已经过认证。<br>RequiresGuest:</li>
<li>使用该注解标注的类，实例，方法在访问或调用时，当前Subject可以是“gust”身份，不需要经过认证或者在原先的session中存在记录。<br>RequiresPermissions:</li>
<li>当前Subject需要拥有某些特定的权限时，才能执行被该注解标注的方法。如果当前Subject不具有这样的权限，则方法不会被执行。<br>RequiresRoles:</li>
<li>当前Subject必须拥有所有指定的角色时，才能访问被该注解标注的方法。如果当天Subject不同时拥有所有指定角色，则方法不会执行还会抛出AuthorizationException异常。<br>RequiresUser</li>
<li>表示当前Subject已经进行身份验证或者通过“记住我”登录。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>//属于user角色
@RequiresRoles(&quot;user&quot;)

//必须同时属于user和admin角色
@RequiresRoles({&quot;user&quot;,&quot;admin&quot;})

//属于user或者admin之一;修改logical为OR 即可
@RequiresRoles(value={&quot;user&quot;,&quot;admin&quot;},logical=Logical.OR)


//符合index:hello权限要求
@RequiresPermissions(&quot;index:hello&quot;)

//必须同时复核index:hello和index:world权限要求
@RequiresPermissions({&quot;index:hello&quot;,&quot;index:world&quot;})

//符合index:hello或index:world权限要求即可
@RequiresPermissions(value={&quot;index:hello&quot;,&quot;index:world&quot;},logical=Logical.OR)


@RequiresAuthentication
@RequiresUser
@RequiresGusst</code></pre><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="Role-Based-Authorization-角色验证"><a href="#Role-Based-Authorization-角色验证" class="headerlink" title="Role-Based Authorization(角色验证)"></a>Role-Based Authorization(角色验证)</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hasRole(String roleName)</td>
<td align="right">返回true，当前Subject（登陆工号）有该角色权限，false，没有</td>
</tr>
<tr>
<td align="left">hasRoles(List<String> roleNames)</td>
<td align="right">返回true，至少在集合中存在一个角色权限，false一个都没有</td>
</tr>
<tr>
<td align="left">hasAllRoles(Collection<String> roleNames)</td>
<td align="right">返回true，当前工号拥有列表所有角色，否则返回false</td>
</tr>
</tbody></table>
<p>例子</p>
<pre><code>Subject currentUser = SecurityUtils.getSubject();

if (currentUser.hasRole(&quot;administrator&quot;)) {
    //有权限处理业务逻辑
} else {
    //没权限处理业务逻辑
}</code></pre><h4 id="Role-Assertions-角色检查"><a href="#Role-Assertions-角色检查" class="headerlink" title="Role Assertions(角色检查)"></a>Role Assertions(角色检查)</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">checkRole(String roleName)</td>
<td align="right">若当前Subject（工号）有该角色不抛出异常，若没有抛出AuthorizationException</td>
</tr>
<tr>
<td align="left">checkRoles(Collection<String> roleNames)</td>
<td align="right">若当前Subject（工号）拥有所有该集合角色不抛出异常，若没有抛出AuthorizationException</td>
</tr>
<tr>
<td align="left">checkRoles(String… roleNames)</td>
<td align="right">同上</td>
</tr>
</tbody></table>
<p>例子</p>
<pre><code>Subject currentUser = SecurityUtils.getSubject();

//检查是否有该bankTeller权限，若没有抛出异常，继续往下执行
currentUser.checkRole(&quot;bankTeller&quot;);</code></pre><h4 id="Permission-Based-Authorization-权限校验"><a href="#Permission-Based-Authorization-权限校验" class="headerlink" title="Permission-Based Authorization(权限校验)"></a>Permission-Based Authorization(权限校验)</h4><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="right">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="left">isPermitted(Permission p)/isPermitted(String perm)</td>
<td align="right">返回true，当前Subject（工号）拥有该权限，否则false</td>
</tr>
<tr>
<td align="left">isPermitted(List<Permission> perms)/isPermitted(String… perms)</td>
<td align="right">有集合中的一个以上，即返回true，否则false</td>
</tr>
<tr>
<td align="left">isPermittedAll(Collection<Permission> perms)/isPermittedAll(String… perms)</td>
<td align="right">有集合中的所有权限，才返回true，否则false</td>
</tr>
</tbody></table>
<p>例子</p>
<pre><code>Subject currentUser = SecurityUtils.getSubject();

if (currentUser.isPermitted(&quot;printer:print:laserjet4400n&quot;)) {
    //做有权限操作
} else {
    //做无权限操作
}
</code></pre><h4 id="Permission-Assertions-权限检查"><a href="#Permission-Assertions-权限检查" class="headerlink" title="Permission Assertions(权限检查)"></a>Permission Assertions(权限检查)</h4><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="right">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="left">checkPermission(Permission p)</td>
<td align="right">subject有该权限返回true，否则false</td>
</tr>
<tr>
<td align="left">checkPermission(String perm)</td>
<td align="right">同上</td>
</tr>
<tr>
<td align="left">checkPermissions(Collection<Permission> perms)</td>
<td align="right">拥有所有权限返回true，否则false</td>
</tr>
<tr>
<td align="left">checkPermissions(String… perms)</td>
<td align="right">同上</td>
</tr>
</tbody></table>
<h3 id="jstl标签"><a href="#jstl标签" class="headerlink" title="jstl标签"></a>jstl标签</h3><p>导入标签库</p>
<pre><code>&lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;

&lt;shiro:guest&gt;&lt;/shiro:guest&gt;   `

&lt;shiro:user&gt;&lt;/shiro:user&gt;

&lt;shiro:authenticated&gt;&lt;/shiro:authenticated&gt;

&lt;shiro:notAuthenticated&gt;未身份验证（包括记住我）&lt;/shiro:notAuthenticated&gt;

&lt;shiro: principal/&gt;

显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal，获取的值为对象时，可以使用property属性指定

&lt;shiro:hasRole name=&quot;role&quot;&gt;&lt;/shiro:hasRole&gt;

&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;&lt;/shiro:hasAnyRoles&gt;

&lt;shiro:lacksRole name=&quot;abc&quot;&gt;&lt;/shiro:lacksRole&gt;

&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;&lt;/shiro:hasPermission&gt;

&lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;&lt;/shiro:lacksPermission&gt;      </code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" itemprop="url">工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="工厂模式介绍"><a href="#工厂模式介绍" class="headerlink" title="工厂模式介绍"></a>工厂模式介绍</h3><p>工厂模式专门负责将大量有共同接口的类实例化。工厂模式可以动态决定将哪一个类实例化，不必事先知道每次要实例化哪一个类。</p>
<p>###为什么要使用工厂模式</p>
<ol>
<li>解耦 ：把对象的创建和使用的过程分开</li>
<li>降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。</li>
<li>降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。</li>
</ol>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="简单工厂模式介绍"><a href="#简单工厂模式介绍" class="headerlink" title="简单工厂模式介绍"></a>简单工厂模式介绍</h4><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据自变量的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<h4 id="角色分配"><a href="#角色分配" class="headerlink" title="角色分配"></a>角色分配</h4><ul>
<li>工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li>
<li>具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>//抽象产品
public interface Product {
}

//具体产品
public class Tv implements Product {
    public Tv(){
        System.out.println(&quot;电视被制造了&quot;);
    }
}

public class Car implements Product {
    public Car(){
        System.out.println(&quot;汽车被制造了&quot;);
    }
}

//工厂
public class ProductFactory {

    public static Shape getProduct(String productType) {
        if (productType == null) {
            return null;
        }
        if (productType.equalsIgnoreCase(&quot;Tv&quot;)) {
            return new Tv();
        } else if (productType.equalsIgnoreCase(&quot;Car&quot;)) {
            return new Rectangle();
        } 
        return null;
    }
}

//使用反射来为工厂创建类更好
public class ProductFactory {
    public static Product produce(String className) throws Exception {
        try {
            Product product = (Product) Class.forName(className).newInstance();
            return product;
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        throw new Exception(&quot;没有该产品&quot;);
    }
}</code></pre><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="工厂方法模式介绍"><a href="#工厂方法模式介绍" class="headerlink" title="工厂方法模式介绍"></a>工厂方法模式介绍</h4><p>工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method是一个类的实例化延迟到其子类。<br>在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<h4 id="角色分配-1"><a href="#角色分配-1" class="headerlink" title="角色分配"></a>角色分配</h4><ul>
<li>抽象工厂（Creator）角色：担任这个角色的是工厂方法模式的核心，它是与应用程序无关的。任何在模式中创建对象的工厂类必须实现这个接口。在上面的系统中这个角色由Java 接口Creator 扮演；在实际的系统中，这个角色也常常使用抽象Java 类实现。</li>
<li>具体工厂（Concrete Creator）角色：担任这个角色的是实现了抽象工厂接口的具体Java 类。具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。在本系统中给出了两个这样的角色，也就是具体Java 类ConcreteCreator1 和ConcreteCreator2。</li>
<li>抽象产品（Product）角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在本系统中，这个角色由Java 接口Product 扮演；在实际的系统中，这个角色也常常使用抽象Java 类实现。</li>
<li>具体产品（Concrete Product）角色：这个角色实现了抽象产品角色所声明的接口。工厂方法模式所创建的每一个对象都是某个具体产品角色的实例。</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><pre><code>//抽象工厂
public interface Factory {
    public Product produce();
}

//抽象产品
public interface Product{} 

//具体产品
public class Tv implements Product {
    public Tv() {
        System.out.println(&quot;电视被制造了&quot;);
    }
}


public class Car implements Product {
    public Car(){
        System.out.println(&quot;汽车被制造了&quot;);
    }
}

//具体工厂
public class TvFactory implements Factory {
    @Override
    public Product produce() {
        return new Tv();
    }
}

public class CarFactory implements Factory {
    @Override
    public Product produce() {
        return new Car();
    }
}</code></pre><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h4 id="抽象工厂模式介绍"><a href="#抽象工厂模式介绍" class="headerlink" title="抽象工厂模式介绍"></a>抽象工厂模式介绍</h4><p>抽象工厂模式提供一个创建一系列或相互依赖的对象的接口，而无需指定它们具体的类。</p>
<h4 id="角色分配-2"><a href="#角色分配-2" class="headerlink" title="角色分配"></a>角色分配</h4><p>-抽象工厂（AbstractFactory）角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。</p>
<ul>
<li>具体工厂类（Conrete Factory）角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。</li>
<li>抽象产品（Abstract Product）角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li>
<li>具体产品（Concrete Product）角色：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品。</li>
</ul>
<h4 id="和工厂方法的区别"><a href="#和工厂方法的区别" class="headerlink" title="和工厂方法的区别"></a>和工厂方法的区别</h4><p>抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>以枪和子弹为例子</p>
<pre><code>//抽象产品
public interface Gun {
    public void shooting();
}

public interface Bullet {
    public void load();
}

//具体产品
public class AK implements Gun{

    @Override
    public void shooting() {
        System.out.println(&quot;shooting with AK&quot;);

    }

}

public class M4A1 implements Gun {

    @Override
    public void shooting() {
        System.out.println(&quot;shooting with M4A1&quot;);

    }

}

public class AK_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println(&quot;Load bullets with AK&quot;);
    }

}

public class M4A1
_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println(&quot;Load bullets with M4A1&quot;);
    }

}

//抽象工厂
public interface Factory {
    public Gun produceGun();
    public Bullet produceBullet();
}

//具体工厂
public class M4A1_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new M4A1();
    }

    @Override
    public Bullet produceBullet() {
        return new M4A1_Bullet();
    }

}

public class AK_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new AK();
    }

    @Override
    public Bullet produceBullet() {
        return new AK_Bullet();
    }

}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" itemprop="url">手动实现线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><pre><code>import java.util.concurrent.atomic.AtomicReference;
public class SpinLock {
   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();
   public void lock() {
       Thread currentThread = Thread.currentThread();
        // 如果锁未被占用，则设置当前线程为锁的拥有者
       while (!owner.compareAndSet(null, currentThread)) {}
   }

   public void unlock() {
       Thread currentThread = Thread.currentThread();
        // 只有锁的拥有者才能释放锁
       owner.compareAndSet(currentThread, null);
   }
}</code></pre><p>利用CAS第一个线程<code>owner.compareAndSet(null, currentThread)</code>抢到执行权，后面的线程则进入循环，直到第一个线程释放锁<code>owner.compareAndSet(currentThread, null)</code>，接着下一个线程抢到执行权，依次运行下去</p>
<h3 id="公平自旋锁"><a href="#公平自旋锁" class="headerlink" title="公平自旋锁"></a>公平自旋锁</h3><p>我们第一个自旋锁所有线程一起抢执行权，如果要执行FIFO原则，如以下</p>
<pre><code>import java.util.concurrent.atomic.AtomicInteger;

public class FairSpinLock {
   private AtomicInteger serviceNum = new AtomicInteger(); // 服务号
   private AtomicInteger ticketNum = new AtomicInteger(); // 排队号

   public int lock() {
       // 首先原子性地获得一个排队号
       int myTicketNum = ticketNum.getAndIncrement();
       // 只要当前服务号不是自己的就不断轮询
       while (serviceNum.get() != myTicketNum) {
       }
       return myTicketNum;
    }

    public void unlock(int myTicket) {
        // 只有当前线程拥有者才能释放锁
        int next = myTicket + 1;
        serviceNum.compareAndSet(myTicket, next);
    }
}</code></pre><p>每个线程分配一个<code>myTicketNum</code>，每一次<code>unlock</code>将<code>serviceNum</code>自增，让下一个持<code>myTicketNum</code>与<code>serviceNum</code>相等的线程跳出循环，开始业务</p>
<h3 id="MCS自旋锁"><a href="#MCS自旋锁" class="headerlink" title="MCS自旋锁"></a>MCS自旋锁</h3><pre><code>import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
public class MCSLock {
    public static class MCSNode {
        volatile MCSNode next;
        volatile boolean isWaiting = true; // 默认是在等待锁
    }
    volatile MCSNode queue;// 指向最后一个申请锁的MCSNode
    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater
            .newUpdater(MCSLock.class, MCSNode.class, &quot;queue&quot;);

    public void lock(MCSNode currentThread) {
        MCSNode predecessor = UPDATER.getAndSet(this, currentThread);// step 1
        if (predecessor != null) {
            predecessor.next = currentThread;// step 2
            while (currentThread.isWaiting) {// step 3
            }
        } else { // 只有一个线程在使用锁，没有前驱来通知它，所以得自己标记自己已获得锁
            currentThread.isWaiting = false;
        }
    }

    public void unlock(MCSNode currentThread) {
        if (currentThread.isWaiting) {// 锁拥有者进行释放锁才有意义
            return;
        }

        if (currentThread.next == null) {// 检查是否有人排在自己后面
            if (UPDATER.compareAndSet(this, currentThread, null)) {// step 4
                // compareAndSet返回true表示确实没有人排在自己后面
                return;
            } else {
                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者
                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完
                while (currentThread.next == null) { // step 5
                }
            }
        }
        currentThread.next.isWaiting = false;
        currentThread.next = null;// for GC
    }
}</code></pre><p>利用CAS特性，<code>UPDATER.getAndSet(this, currentThread)</code>在多线程访问情况下将所有节点连成一个虚拟队列，然后将前后节点链成链表结构，每个申请锁的线程都是链表上的一个节点，这些线程会一直轮询自己的本地变量，来知道它自己是否获得了锁。已经获得了锁的线程在释放锁的时候，负责通知其它线程，这样 CPU 之间缓存的同步操作就减少了很多，仅在线程通知另外一个线程的时候发生，降低了系统总线和内存的开销。</p>
<h3 id="CLH-自旋锁"><a href="#CLH-自旋锁" class="headerlink" title="CLH 自旋锁"></a>CLH 自旋锁</h3><p>CLH 锁与 MCS 锁的原理大致相同，都是各个线程轮询各自关注的变量，来避免多个线程对同一个变量的轮询，从而从 CPU 缓存一致性的角度上减少了系统的消耗。<br>CLH 锁的名字也与他们的发明人的名字相关：Craig，Landin and Hagersten。<br>CLH 锁与 MCS 锁最大的不同是，MCS 轮询的是当前队列节点的变量，而 CLH 轮询的是当前节点的前驱节点的变量，来判断前一个线程是否释放了锁。</p>
<pre><code>import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
public class CLHLock {
    public static class CLHNode {
        private volatile boolean isWaiting = true; // 默认是在等待锁
    }
    private volatile CLHNode tail ;
    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater
            . newUpdater(CLHLock.class, CLHNode .class , &quot;tail&quot; );
    public void lock(CLHNode currentThread) {
        CLHNode preNode = UPDATER.getAndSet( this, currentThread);
        if(preNode != null) {//已有线程占用了锁，进入自旋
            while(preNode.isWaiting ) {
            }
        }
    }

    public void unlock(CLHNode currentThread) {
        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。
        if (!UPDATER .compareAndSet(this, currentThread, null)) {
            // 还有后续线程
            currentThread.isWaiting = false ;// 改变状态，让后续线程结束自旋
        }
    }
}</code></pre><p>CLH 锁与 MCS 锁的原理大致相同，都是各个线程轮询各自关注的变量，来避免多个线程对同一个变量的轮询，从而从 CPU 缓存一致性的角度上减少了系统的消耗。CLH 锁与 MCS 锁最大的不同是，MCS 轮询的是当前队列节点的变量，而 CLH 轮询的是当前节点的前驱节点的变量，来判断前一个线程是否释放了锁。</p>
<h3 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h3><pre><code>class Store{
    private static int storage = 0;
    Semaphore semaphore = new Semaphore(1);
    public void add(int n) throws InterruptedException {
        semaphore.acquire();
        storage += n;
        semaphore.release();
    }

    public void out(){
        System.out.println(storage);
    }
}</code></pre><p>设置信号量为1，这样可以保证多线程并发调用<code>add</code>方法时，只能单个线程运行，起到加锁效果</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BAABC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BAABC/" itemprop="url">多线程交替输出ABC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><pre><code>public class Mythread2 {
    public static void main(String[] args) throws InterruptedException {
        Object A = new Object();
        Object B = new Object();
        Object C = new Object();
        new ThreadABC(C,A,&#39;A&#39;).start();
        Thread.sleep(100);
        new ThreadABC(A,B,&#39;B&#39;).start();
        Thread.sleep(100);
        new ThreadABC(B,C,&#39;C&#39;).start();
    }
}

class ThreadABC extends Thread{
    private Object pre;
    private Object self;
    private char c;
    public ThreadABC(Object pre, Object self, char c) {
        this.pre = pre;
        this.self = self;
        this.c = c;
    }
    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        while(true){
            synchronized (pre) {
                synchronized (self) {
                    System.out.println(c);
                    self.notifyAll();//执行完同步代码块才会释放锁
                }
                try {
                    pre.wait();
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }

}</code></pre><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><pre><code>public class Mythread3 {

    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        Condition A = lock.newCondition();
        Condition B = lock.newCondition();
        Condition C = lock.newCondition();
        new ThreadReen(C, A, &#39;A&#39;, lock).start();
        new ThreadReen(A, B, &#39;B&#39;, lock).start();
        new ThreadReen(B, C, &#39;C&#39;, lock).start();
    }

}

class ThreadReen extends Thread{
    private Condition pre;
    private Condition self;
    private char c;
    private ReentrantLock lock;

    public ThreadReen(Condition pre, Condition self, char c, ReentrantLock lock) {
        this.pre = pre;
        this.self = self;
        this.c = c;
        this.lock = lock;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        while(true){
            lock.lock();
            System.out.println(c);
            self.signalAll();//执行完同步代码块才会释放锁
            try {
                pre.await();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            lock.unlock();
        }
    }

}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" itemprop="url">双向链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="双向链表的结构"><a href="#双向链表的结构" class="headerlink" title="双向链表的结构"></a>双向链表的结构</h3><p><img src="http://wx4.sinaimg.cn/large/96b7c0f4ly1fymvpeor3pj20qq0a2js6.jpg" alt=""></p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><pre><code>class Node&lt;T&gt;{
    Node&lt;T&gt; pre;
    Node&lt;T&gt; next;
    T data;

    public Node() {
    }
    public Node(T data) {
        super();
        this.data = data;
    }
    public Node&lt;T&gt; getPre() {
        return pre;
    }
    public void setPre(Node&lt;T&gt; pre) {
        this.pre = pre;
    }
    public Node&lt;T&gt; getNext() {
        return next;
    }
    public void setNext(Node&lt;T&gt; next) {
        this.next = next;
    }
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }

}</code></pre><h3 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h3><pre><code>public class DoublyLinkedList&lt;T&gt; {

    private Node&lt;T&gt; first;//指向第一个节点
    private Node&lt;T&gt; last;//指向最后一个节点


    public Node&lt;T&gt; getFirst() {
        return first;
    }

    public void setFirst(Node&lt;T&gt; first) {
        this.first = first;
    }

    public Node&lt;T&gt; getLast() {
        return last;
    }

    public void setLast(Node&lt;T&gt; last) {
        this.last = last;
    }
    ·
    ·
    ·    
    基本操作

}</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><pre><code>public void insertNodeHead(Node&lt;T&gt; node){
    if(first == null){
        first = node;
        last = node;
        return;
    }
    first.setPre(node);//将第一个节点的pre设为新增进来的节点
    node.setNext(first);//将第一个节点设为新增节点的next
    first = node;//将第一个节点置换为新增进来的节点
}</code></pre><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><pre><code>public void insertNodeTail(Node&lt;T&gt; node){

    Node&lt;T&gt; temp = first;

    if(first ==  null){
        first = node;
        last = node;
        return;
    }

    while(temp.getNext() != null){
        temp = temp.getNext();
    }
    temp.setNext(node);    
    node.setPre(temp);
    last = node;
}</code></pre><h4 id="删除第一个节点"><a href="#删除第一个节点" class="headerlink" title="删除第一个节点"></a>删除第一个节点</h4><pre><code>public void removeFirstNode(){
    if(isEmpty()){
        return;
    }
    first.getNext().setPre(null);
    first = first.getNext();
}</code></pre><h4 id="删除最后一个节点"><a href="#删除最后一个节点" class="headerlink" title="删除最后一个节点"></a>删除最后一个节点</h4><pre><code>public void removeFirstNode(){
    if(isEmpty()){
        return;
    }
    first.getNext().setPre(null);
    first = first.getNext();
}</code></pre><h4 id="清空双链表"><a href="#清空双链表" class="headerlink" title="清空双链表"></a>清空双链表</h4><pre><code>public void clear(){
    setFirst(null);
    setLast(null);
}</code></pre><h4 id="查看指定节点数据"><a href="#查看指定节点数据" class="headerlink" title="查看指定节点数据"></a>查看指定节点数据</h4><pre><code>public T getData(int index){
    if(isEmpty()){
        return null;
    }
    Node&lt;T&gt; temp = first;
    while(temp != null &amp;&amp; --index &gt; 0){
        temp = temp.getNext();
    }
    return temp.getData();
}</code></pre><h4 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h4><pre><code>public void removeNodeByPos(int index){
    if(isEmpty()){
        return;
    }
    if(getLength()==index){
        removeLastNode();
        return;
    }
    Node&lt;T&gt; temp = first;
    while(temp != null &amp;&amp; --index &gt; 0){
        temp = temp.getNext();
    }
    temp.getNext().setPre(temp.getPre());
    temp.getPre().setNext(temp.getNext());
}</code></pre><h4 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h4><pre><code>public void insertByPos(int index,Node&lt;T&gt; node){
    Node&lt;T&gt; temp = first;
    if(isEmpty() || index == 1){//空链表或者插入第一个时用头插法
        insertNodeHead(node);
        return;
    }
    if(getLength()+1 == index){//指定最后位置时用尾插法
        insertNodeTail(node);
        return;
    }
    while(temp != null &amp;&amp; --index &gt; 0){
        temp = temp.getNext();
    }
    node.setNext(temp);//新节点的next指向当前节点
    node.setPre(temp.getPre());//新节点的pre指向上一个节点
    temp.getPre().setNext(node);//上一个节点的next指向新节点
}</code></pre><h4 id="倒置空链表"><a href="#倒置空链表" class="headerlink" title="倒置空链表"></a>倒置空链表</h4><pre><code>public void reverse(){
    if(isEmpty()){
        return;
    }
    Node&lt;T&gt; newNode = first;
    Node&lt;T&gt; temp = first;
    setFirst(null);
    setLast(null);
    while(newNode != null){//遍历双链表
        temp = newNode.getNext();
        newNode.setPre(null);
        newNode.setNext(null);//置空前后节点作为新节点
        insertNodeHead(newNode);//头插法
        newNode = temp;
    }
}</code></pre><h4 id="是否为空链表"><a href="#是否为空链表" class="headerlink" title="是否为空链表"></a>是否为空链表</h4><pre><code>public boolean isEmpty(){
    return Objects.isNull(first);
}</code></pre><h4 id="查看双链表长度"><a href="#查看双链表长度" class="headerlink" title="查看双链表长度"></a>查看双链表长度</h4><pre><code>public int getLength(){
    Node&lt;T&gt; temp = first;
    int length = 0;
    while(temp != null){
        length++;
        temp = temp.getNext();
    }
    return length;
}</code></pre><h4 id="显示所有节点"><a href="#显示所有节点" class="headerlink" title="显示所有节点"></a>显示所有节点</h4><pre><code>public void display(){
    Node&lt;T&gt; temp = first;
    while(temp != null){
        System.out.println(temp.getData());
        temp = temp.getNext();
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/" itemprop="url">反射基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。</p>
<h3 id="反射能做什么"><a href="#反射能做什么" class="headerlink" title="反射能做什么"></a>反射能做什么</h3><p>我们知道反射机制允许程序在运行时取得任何一个已知名称的<code>class</code>的内部信息，包括包括其<code>modifiers</code>(修符)<code>fields</code>(属性)，<code>methods</code>(方法)等，并可于运行时改变<code>fields</code>内容或调用<code>methods</code>。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等；但是需要注意的是反射使用不当会造成很高的资源消耗</p>
<h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><p>每个通过关键字<code>class</code>标识的类，在内存中有且只有一个与之对应的<code>Class</code>对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个<code>Class</code>对象。</p>
<p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是<code>Class</code>类。<code>Class</code>类封装一个对象和接口运行时的状态，当装载类时，<code>Class</code>类型的对象自动创建，所以可以在程序运行中获取类的内部信息。</p>
<h3 id="获取类的内部信息"><a href="#获取类的内部信息" class="headerlink" title="获取类的内部信息"></a>获取类的内部信息</h3><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><p>第一种：通过类名获得</p>
<p><code>Class&lt;?&gt; class = ClassName.class;</code></p>
<p>第二种：通过类名全路径获得：</p>
<p><code>Class&lt;?&gt; class = Class.forName(&quot;类名全路径&quot;);</code></p>
<p>第三种：通过实例对象获得：</p>
<p><code>Class&lt;?&gt; class = object.getClass();</code></p>
<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p><code>Field</code>提供有关类或接口的单个字段的信息和动态访问。 反射的字段可以是类（静态）字段或普通字段</p>
<p><code>Class</code>对象提供了四个方法来获取<code>Field</code>对象</p>
<ol>
<li><code>getDeclaredField(String name)</code></li>
</ol>
<p>根据传入的方法名返回一个指定字段的<code>Field</code>对象</p>
<ol start="2">
<li><code>getDeclaredFields()</code></li>
</ol>
<p>返回的<code>Field</code>对象数组包含类或接口声明的所有字段</p>
<ol start="3">
<li><code>getField(String name)</code></li>
</ol>
<p>根据传入的方法名返回一个指定的公共成员字段的<code>Field</code>对象</p>
<ol start="4">
<li><code>getFields()</code></li>
</ol>
<p>返回一个<code>Field</code>对象数组，包含类或接口的所有可访问的公共字段</p>
<p>区别：</p>
<ul>
<li><p>其中<code>getFields</code>方法返回一个<code>Field</code>类型数组，其中包含当前类的<code>public</code>字段，如果此类继承于某个父类，同时包括父类的public字段。其它的proteced和private字段，无论是属于当前类还是父类都不被此方法获取。</p>
</li>
<li><p><code>getDeclaredFields</code>方法返回一个<code>Field</code>类型数组，结果包含当前类的所有字段，<code>private、protected、public</code>或者无修饰符都在内。另外，此方法返回的结果不包括父类的任何字段。 此方法只是针对当前类的。</p>
</li>
</ul>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>方法提供有关类和接口上单一方法的信息和访问权限。可以是类方法或实例方法（包括抽象方法）</p>
<p>Class对象提供了四个方法来获取Method对象，parameterTypes参数是形参的Class对象数组(new Class[]{})</p>
<ol>
<li><code>getDeclaredMethod(String name，Class&lt;?&gt;... parameterTypes)</code></li>
</ol>
<p>根据传入的方法名和一个Class对象数组(按顺序包含了方法的形参)返回一个指定的Method对象</p>
<ol start="2">
<li><code>getDeclaredMethods()</code></li>
</ol>
<p>返回的数组Method对象包含类或接口声明的所有字段</p>
<ol start="3">
<li><code>getMethod(String name， Class&lt;?&gt;... parameterTypes)</code></li>
</ol>
<p>根据传入的方法名和一个Class对象数组(按顺序包含了方法的形参)返回一个Method对象</p>
<ol start="4">
<li>getMethods()</li>
</ol>
<p>返回包含一个数组Method对象，包含类或接口的所有可访问的公共字段</p>
<p>区别：</p>
<ul>
<li><p>其中<code>getMethods</code>方法返回一个<code>Method</code>类型数组，其中包含当前类的<code>public</code>字段，如果此类继承于某个父类，同时包括父类的<code>public</code>字段。其它的<code>proteced</code>和<code>private</code>字段，无论是属于当前类还是父类都不被此方法获取。</p>
</li>
<li><p><code>getDeclaremethods</code>方法返回一个<code>Method</code>类型数组，结果包含当前类的所有字段，<code>private、protected、public</code>或者无修饰符都在内。另外，此方法返回的结果不包括父类的任何字段。 此方法只是针对当前类的。</p>
</li>
</ul>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p><code>Constructor</code>提供了一个类的单个构造函数的信息和访问</p>
<p>1 <code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></p>
<p>根据传入的形参和一个Class对象数组(按顺序包含了方法的形参)返回指定构造函数</p>
<ol start="2">
<li><code>getConstructors()</code></li>
</ol>
<p>返回一个包含类中公共构造函数的Constructor数组</p>
<ol start="3">
<li><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></li>
</ol>
<p>根据传入的形参和一个Class对象数组(按顺序包含了方法的形参)返回指定构造函数</p>
<ol start="4">
<li><code>getDeclaredConstructors()</code></li>
</ol>
<p>获取包含了所有声明的构造函数的<code>Constructor</code>数组</p>
<p>区别：<code>getConstructors</code>获取的是类中修饰符为public的构造函数，<code>getDeclaredConstructors</code>获取的是类中所有声明的构造函数</p>
<h3 id="具体运用"><a href="#具体运用" class="headerlink" title="具体运用"></a>具体运用</h3><pre><code>class reflect{
    public char asc = &#39;a&#39;;
    private int num;
    private String string;
    private int privateNum = 1;
    public reflect(){

    }

    public reflect(int num,String string){
        this.num = num;
        this.string = string;
    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getString() {
        return string;
    }

    public void setString(String string) {
        this.string = string;
    }

    public int getNum(int i){
        return num+i;
    }

    public void out(){
        System.out.println(num+string);
    }
}

class sonReflect extends reflect{

    public boolean bool = true;
    private float fnum;

    public sonReflect() {

    }

    public sonReflect(float fnum) {
        this.fnum = fnum;
    }

    public float getFnum() {
        return fnum;
    }

    public void setFnum(float fnum) {
        this.fnum = fnum;
    }

    public void out(){

    }

    private void privateOut(){

    }
}



        reflect r = new reflect(1,&quot;1&quot;);
        sonReflect sr = new sonReflect(1.1f);
        Class&lt;?&gt; rc = r.getClass();
        Class&lt;?&gt; src = sr.getClass();
        //获取子类的Method
        Method srcdeclaredMethod[] = src.getDeclaredMethods();
        Method srcMethod[] = src.getMethods();
        Arrays.asList(srcdeclaredMethod).forEach(m-&gt;System.out.print(m.getName()+&quot; &quot;));
        System.out.println();
        Arrays.asList(srcMethod).forEach(m-&gt;System.out.print(m.getName()+&quot; &quot;));
        /* 输出为:
         * out getFnum setFnum  和
         * out getFnum setFnum getString getNum getNum setNum setString
         * wait wait wait equals toString hashCode getClass notify notifyAll
         * getDeclaredMethods只能获取到当前类声明的所有类型方法，而getMethods能
         * 获取当前和从父类继承的public方法，例如privateOut方法它就无法获得
         * */
        System.out.println();
        Field srcdeclaredField[] = src.getDeclaredFields();
        Field srcField[] = src.getFields();
        Arrays.asList(srcdeclaredField).forEach(m-&gt;System.out.print(m.getName()+&quot; &quot;));
        System.out.println();
        Arrays.asList(srcField).forEach(m-&gt;System.out.print(m.getName()+&quot; &quot;));
        /* 输出为:
         * bool fnum 和 bool asc,从结果看出getDeclaredFields方法获取到了自身公有和私有
         * 属性,而getFields方法获取到了父类和子类的所有共有属性
         * 
         * */

        Method m = rc.getMethod(&quot;getNum&quot;, new Class[]{int.class});
        Method m1 = rc.getMethod(&quot;getNum&quot;);
        System.out.println(m.invoke(r, 1));
        System.out.println(m1.invoke(r));
      //System.out.println(m1.invoke(r, 1));//抛出异常
        /*输出为:2 1 和一个异常,通过形参数组确定具体
         * 方法,再用invoke函数调用对象方法
         */

        Field f = rc.getDeclaredField(&quot;privateNum&quot;);
//        Field f1 = rc.getField(&quot;privateNum&quot;); 
//        System.out.println(f.get(r)+&quot; &quot;+f1.get(r));
        f.setAccessible(true);
        System.out.println(f.get(r));
        /* 抛出两个异常,getField只能获取子类和父类的公有属性
         * f为私有属性且没有get方法,需要setAccessible设为true
         * 才能调用Field的get方法获取
         */

        try {
            Class constructor = Class.forName(&quot;reflect.reflect&quot;);
            Constructor con = constructor.getConstructor(new Class[]{int.class,String.class});
            reflect nr = (reflect) con.newInstance(3,&quot;333&quot;);
            nr.out();
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        //除了class.newInstance，构造器也能用来创建实例</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinaill</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinaill</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <link rel="stylesheet" href="/lib/prettify/skins/sunburst.css" type="text/css">
<script src="/lib/prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
      prettyPrint();
  });
</script>
</body>
</html>
