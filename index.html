<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="article:author" content="sinaill">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" itemprop="url">锁的基本使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="多线程同步作用"><a href="#多线程同步作用" class="headerlink" title="多线程同步作用"></a>多线程同步作用</h3><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时(如数据的增删改查),将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<h3 id="Sychronized"><a href="#Sychronized" class="headerlink" title="Sychronized"></a>Sychronized</h3><p><code>Synchronized</code>使用方式：</p>
<p><img src="http://wx1.sinaimg.cn/large/96b7c0f4gy1fzfjb5cgrmj20rl0gajrn.jpg" alt=""></p>
<h4 id="方法锁"><a href="#方法锁" class="headerlink" title="方法锁"></a>方法锁</h4><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在进入该方法前，需要获得当前对象的内置锁，否则就处于阻塞状态。<code>synchronized</code>关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p>
<pre><code>public class Mythread {
    public static void main(String[] args) {
        testThread MyThread = new testThread();
        new Thread(MyThread,&quot;线程1&quot;).start();
        new Thread(MyThread,&quot;线程2&quot;).start();
        new Thread(MyThread,&quot;线程3&quot;).start();
        new Thread(MyThread,&quot;线程4&quot;).start();
        new Thread(MyThread,&quot;线程5&quot;).start();
        new Thread(MyThread,&quot;线程6&quot;).start();
        new Thread(MyThread,&quot;线程7&quot;).start();
        new Thread(MyThread,&quot;线程8&quot;).start();
        new Thread(MyThread,&quot;线程9&quot;).start();
        new Thread(MyThread,&quot;线程10&quot;).start();
    }
}


class testThread implements Runnable{
    public int i = 10;
    @Override
    public void run() {
        // TODO Auto-generated method stub
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i--);
        }
    }</code></pre><p>输出结果为</p>
<pre><code>线程8:8
线程2:3
线程9:4
线程1:2
线程5:10
线程6:10
线程10:6
线程7:5
线程3:7
线程4:9</code></pre><p>由于多个线程同时进入<code>run</code>方法，导致输出的结果出现异常，接下来在<code>run</code>方法加入关键字<code>synchronized</code>，<code>public synchronized void run()</code>，输出结果如下</p>
<pre><code>线程2:10
线程10:9
线程8:8
线程9:7
线程7:6
线程6:5
线程5:4
线程4:3
线程3:2
线程1:1</code></pre><p>可以看到变量i按顺序依次减1输出，run方法被加锁后每次只有一个获取了锁的线程能运行，其它线程则处于阻塞状态。</p>
<h4 id="对象锁-synchronized代码块"><a href="#对象锁-synchronized代码块" class="headerlink" title="对象锁(synchronized代码块)"></a>对象锁(synchronized代码块)</h4><p>上面代码除了将<code>run</code>方法加入关键字<code>Synchronized</code>，还可以使用对象锁，方法锁实际也是对象锁，锁的是调用同步方法的实例，代码如下</p>
<pre><code>class testThread implements Runnable{
    public int i = 10;
    @Override
    public void run() {
        // TODO Auto-generated method stub
            synchronized(this) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i--);
            }

        }
    }</code></pre><h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><p>对象锁是用来控制实例方法之间的同步，而类锁是用来控制静态方法（或者静态变量互斥体）之间的同步的。</p>
<p>类锁只是一个概念上的东西，并不是真实存在的，他只是用来帮助我们理解锁定实例方法和静态方法的区别的。<br>java类可能会有很多对象，但是只有一个Class(字节码)对象，也就是说类的不同实例之间共享该类的<code>Class</code>对象。<code>Class</code>对象其实也仅仅是1个java对象，只不过有点特殊而已。<br>由于每个java对象都有1个互斥锁，而类的静态方法是需要<code>Class</code>对象。所以所谓的类锁，只不过是<code>Class</code>对象的锁而已。<br>获取类的<code>Class</code>对象的方法有好几种，最简单的是[类名.class]的方式</p>
<pre><code>public class Mythread {
    public static void main(String[] args) {

        new testThread(&quot;线程1&quot;).start();
        new testThread(&quot;线程2&quot;).start();
        new testThread(&quot;线程3&quot;).start();

    }
}


class testThread extends Thread{

    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        testThread.out();
    }

    public testThread(String name) {
        super(name);
        // TODO Auto-generated constructor stub
    }

    public static void out(){
        int i = 5;
        while(i&gt;0){
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+--i);
        }
    }


}</code></pre><p>创建多个线程<code>testThread</code>，<code>run</code>方法中调用静态方法<code>out()</code>，结果为</p>
<pre><code>线程3:1
线程2:2
线程3:0
线程1:2
线程2:1
线程1:1
线程2:0
线程1:0</code></pre><p>给静态方法加上锁<code>public synchronized static void out()</code></p>
<pre><code>线程1:4
线程1:3
线程1:2
线程1:1
线程1:0
线程3:4
线程3:3
线程3:2
线程3:1
线程3:0
线程2:4
线程2:3
线程2:2
线程2:1
线程2:0</code></pre><p>另一种使用代码块实现类锁的方法为</p>
<pre><code>public static void out(){
    synchronized(testThread.class){
        int i = 5;
        while(i&gt;0){
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+--i);
        }
    }
}</code></pre><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>必须在同步代码块中,且获得对应的锁才能使用</p>
<p><code>wait()</code>:使一个线程处于等待状态，并且释放所持有的对象的lock。<br><code>notify()</code>:唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br><code>notifyAll()</code>:唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。<br>线程间通信使用例子 生产者消费者模型。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code>public class Rlock {
    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        new Thread(new Mythread5(lock)).start();
        new Thread(new Mythread5(lock)).start();
        new Thread(new Mythread5(lock)).start();
    }
}

class Mythread5 implements Runnable{
    private ReentrantLock lock;
    int num = 10;
    public Mythread5(ReentrantLock lock) {
        this.lock = lock;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        lock.lock();
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(--num);
        }
        lock.unlock();
    }

}</code></pre><p>同样使用加锁和解锁的操作实现多线程排队执行目标代码</p>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><pre><code>/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}</code></pre><p>创建锁时可以指定锁为公平锁还是非公平锁，当设为<code>true</code>时，锁倾向于等待时间最长的线程。否则锁不保证特定的访问顺序。</p>
<h4 id="trylock"><a href="#trylock" class="headerlink" title="trylock"></a>trylock</h4><p><code>tryLock()</code>方法只有在成功获取了锁的情况下才会返回<code>true</code>，如果别的线程当前正持有锁，则会立即返回<code>false</code>。如果为这个方法加上<code>timeout</code>参数，则会在等待<code>timeout</code>的时间才会返回<code>false</code>或者在获取到锁的时候返回<code>true</code>。</p>
<h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h4><p><code>ReentrantLock.lockInterruptibly</code>允许在等待时由其它线程调用等待线程的<code>Thread.interrupt</code>方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个<code>InterruptedException</code>。 <code>ReentrantLock.lock</code>方法不允许<code>Thread.interrupt</code>中断,即使检测到<code>Thread.isInterrupted</code>,一样会继续尝试获取锁，失败则继续休眠。只是在最后获取锁成功后再把当前线程置为<code>interrupted</code>状态,然后再中断线程。</p>
<h4 id="线程间通信Condition"><a href="#线程间通信Condition" class="headerlink" title="线程间通信Condition"></a>线程间通信Condition</h4><p>没有获得锁也可以使用以下方法</p>
<p><code>await()</code>:使一个线程处于等待状态，并且释放所持有的对象的lock。<br><code>signal()</code>:唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br><code>signalAll()</code>:唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。<br>线程间通信使用例子 生产者消费者模型</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>Synchronized</code>是依赖于JVM实现的，而<code>ReenTrantLock</code>是JDK实现的<br><code>Synchronized</code>的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而<code>ReenTrantLock</code>需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在<code>finally</code>中声明释放锁<br><code>ReenTrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。<br><code>ReenTrantLock</code>提供了一个<code>Condition</code>（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像<code>synchronized</code>要么随机唤醒一个线程要么唤醒全部线程。参照生产者消费者模型。<br><code>ReenTrantLock</code>提供了一种能够中断等待锁的线程的机制，通过<code>lock.lockInterruptibly()</code>来实现这个机制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" itemprop="url">适配器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h3><p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
<h3 id="类适配器模式（采用继承实现）"><a href="#类适配器模式（采用继承实现）" class="headerlink" title="类适配器模式（采用继承实现）"></a>类适配器模式（采用继承实现）</h3><p><img src="http://wx1.sinaimg.cn/large/96b7c0f4gy1g0l72acl2gj20h8081dfu.jpg" alt=""></p>
<pre><code>//目标接口，或称为标准接口 
public interface Target {
    //普通功能
    public void request();
}

//已存在的、具有特殊功能、但不符合我们既有的标准接口的类  
public class Adaptee {
    public void specificRequest() {
        System.out.println(&quot;被适配类...我是两孔插座  具有特殊功能&quot;);
    }
}

//适配器类，继承了被适配类，同时实现标准接口
public class Adapter extends Adaptee implements Target  {
    @Override
    public void request() {
        System.out.println(&quot;我是适配器类 我能适配任何两孔插座 让它正常工作&quot;);
        this.specificRequest();
    }
 }


public class Client {
    public static void main(String[] args) {
         Target adapter = new Adapter(); 
         //通过适配器调用特殊功能
         adapter.request();  
    }
}
对象适配器（采用对象组合方式实现）
对象适配器

源代码：
//目标接口，或称为标准接口 
public interface Target {
    //普通功能
    public void request();
}

//已存在的、具有特殊功能、但不符合我们既有的标准接口的类  
public class Adaptee {
    public void specificRequest() {
        System.out.println(&quot;被适配类...我是两孔插座  具有特殊功能&quot;);
    }
} 

//适配器类，直接关联被适配类，同时实现标准接口  
class Adapter implements Target {
    // 直接关联被适配类
    private Adaptee adaptee;

    // 可以通过构造函数传入具体需要适配的被适配类对象
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        // 这里是使用委托的方式完成特殊功能
        System.out.println(&quot;我是适配器类 我能适配任何两孔插座 让它正常工作&quot;);
        this.adaptee.specificRequest();
    }
}

public class Client {
    public static void main(String[] args) {
        //使用特殊功能类，即适配类，  
        // 需要先创建一个被适配类的对象作为参数  
        Target adapter = new Adapter(new Adaptee());  
        adapter.request();  
    }
}</code></pre><h3 id="两种方式使用权衡"><a href="#两种方式使用权衡" class="headerlink" title="两种方式使用权衡"></a>两种方式使用权衡</h3><ul>
<li>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</li>
<li>对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。</li>
<li>对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义 Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</li>
<li>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。</li>
<li>对于对象适配器，需要额外的引用来间接得到Adaptee。<br>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" itemprop="url">装饰者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是装饰者模式"><a href="#什么是装饰者模式" class="headerlink" title="什么是装饰者模式"></a>什么是装饰者模式</h3><p>在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<h3 id="装饰者模式结构"><a href="#装饰者模式结构" class="headerlink" title="装饰者模式结构"></a>装饰者模式结构</h3><p>结构图：</p>
<p><img src="http://wx3.sinaimg.cn/large/96b7c0f4gy1g0aprtaiiwj20hg0abjre.jpg" alt=""></p>
<p>例子代码如下：</p>
<pre><code>//抽象构件（Component）角色

public interface Component{
    void sampleOperation();    
}

//具体构件（ConcreteComponent）角色

public class ConcreteComponent{
    public void sampleOperation(){

    }
}

//抽象装饰（Decorator）角色

public class Decorator implements Component{
    Component component;
    public Decorator(Component component){
        this.component = component;
    }
    public void sampleOperation(){
        component.sampleOperation();
    }
}

具体装饰（ConcreteDecorator）角色

public void ConcreteDecorator extends Decorator{
    public ConcreteDecorator(Component component){
        super(Component component);
    }

    public void sampleOperation(){
        //动态扩展功能代码
        component.sampleOperation();
        //动态扩展功能代码
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" itemprop="url">自定义注解的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>JDK 1.5开始jdk就定义了元注解，用来定义其他的自定义注解，目前提供的元注解主要有4个：</p>
<ul>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ul>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target说明了<code>Annotation</code>所修饰的对象范围：<code>Annotation</code>可被用于<code>packages</code>、<code>types</code>（类、接口、枚举、<code>Annotation</code>类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。</p>
<p>参数只有一个<code>value</code>，决定注解的作用域，从<code>enum</code>类型的<code>ElementType</code>中取值</p>
<ul>
<li>CONSTRUCTOR:用于描述构造器</li>
<li>FIELD:用于描述域</li>
<li>LOCAL_VARIABLE:用于描述局部变量</li>
<li>METHOD:用于描述方法</li>
<li>PACKAGE:用于描述包</li>
<li>PARAMETER:用于描述参数</li>
<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
<p>例子</p>
<pre><code>@Target(ElementType.ANNOTATION_TYPE)</code></pre><p>表示注解作用范围为注解类型</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p><code>@Retention</code>定义了该Annotation被保留的时间长短</p>
<p>从<code>enum</code>类型的<code>RentetionPolicy</code>取值</p>
<ul>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在class文件中有效（即class保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ul>
<p>我们在自定义注解用用的比较多的自然是RUNTIME了，这样保证注解在运行时是有效的，我们在其他框架中遇到的也大部分都是RUNTIME的。</p>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p><code>@Documented</code>用于描述其它类型的<code>annotation</code>应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。<code>Documented</code>是一个标记注解，没有成员。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p><code>@Inherited</code>元注解是一个标记注解，<code>@Inherited</code>阐述了某个被标注的类型是被继承的。如果一个使用了<code>@Inherited</code>修饰的annotation类型被用于一个<code>class</code>，则这个<code>annotation</code>将被用于该<code>class</code>的子类。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    /**
     * Returns an array of the kinds of elements an annotation type
     * can be applied to.
     * @return an array of the kinds of elements an annotation type
     * can be applied to
     */
    ElementType[] value();
}</code></pre><p>以<code>@Target</code>注解为例，<code>@interface</code>用来声明一个注解，注解类的方法返回值就是该注解的配置参数</p>
<p>使用<code>@interface</code>自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。</p>
<p>注解支持的参数类型有</p>
<ul>
<li>所有基本数据类型（int,float,boolean,byte,double,char,long,short)</li>
<li>String类型</li>
<li>Class类型</li>
<li>enum类型</li>
<li>Annotation类型</li>
<li>以上所有类型的数组</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>定义一个注解</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@interface classInfo{
    String name() default &quot;&quot;;
    boolean isPublic() default true;
}</code></pre><p>作用于类上面</p>
<pre><code>@classInfo(name = &quot;Annotation&quot;,isPublic = false)
class testAnnotation{

}</code></pre><p>获取注解配置</p>
<pre><code>@Test
public void test(){
    classInfo annotation = AnnotationUtils.findAnnotation(testAnnotation.class,classInfo.class);
    System.out.println(annotation.name()+&quot; &quot;+annotation.isPublic());
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA/" itemprop="url">线程的创建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程，有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>直接继承<code>Thread</code>，覆写<code>run</code>方法</p>
<pre><code>public class Mythread {
    public static void main(String[] args) {
        Thread t = new testThread();
        t.start();
    }
}


class testThread extends Thread{

    @Override
    public void run() {
        // TODO Auto-generated method stub
        super.run();
        System.out.println(1);
    }

}</code></pre><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>实现<code>Runnable</code>接口，覆写<code>run</code>方法</p>
<pre><code>public class Mythread {
    public static void main(String[] args) {
        testThread MyThread = new testThread();
        new Thread(MyThread).start();
    }
}


class testThread implements Runnable{

    @Override
    public void run() {
        // TODO Auto-generated method stub
        System.out.println(1);
    }

}</code></pre><h3 id="两种创建方法的区别"><a href="#两种创建方法的区别" class="headerlink" title="两种创建方法的区别"></a>两种创建方法的区别</h3><p>使用实现<code>Runnable</code>接口的方法可以很容易实现线程之间共享资源</p>
<p>采用实现接口的方法可以避免java中的单继承限制</p>
<pre><code>public class Mythread {
    public static void main(String[] args) {
        testThread MyThread = new testThread();
        new Thread(MyThread,&quot;线程1&quot;).start();
        new Thread(MyThread,&quot;线程2&quot;).start();
    }
}


class testThread implements Runnable{
    public int i = 10;
    @Override
    public void run() {
        // TODO Auto-generated method stub
        for(int a = 0;a &lt; 10;a++){
            if(a&gt;0){
                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i--);
            }
        }
    }

}</code></pre><p>输出为：</p>
<pre><code>线程2:10
线程1:9
线程1:7
线程1:6
线程1:5
线程2:8
线程1:4
线程1:2
线程1:1
线程1:0
线程1:-1
线程2:3
线程2:-2
线程2:-3
线程2:-4
线程2:-5
线程2:-6
线程2:-7</code></pre><p>从以上结果可以看出，实现<code>runnable</code>的类中定义的变量是所有用它来创建的线程共享的，并且两个线程进入同一个<code>run</code>方法。</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java线程有优先级，优先级高的线程会获得较多的运行机会(调用start方法只是使线程处于就绪状态，需要等cpu调度)</p>
<p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：<br><code>static int MAX_PRIORITY</code>：线程可以具有的最高优先级，取值为10。<br><code>static int MIN_PRIORITY</code>：线程可以具有的最低优先级，取值为1。<br><code>static int NORM_PRIORITY</code>：分配给线程的默认优先级，取值为5。</p>
<p><code>Thread</code>类的<code>setPriority()</code>和<code>getPriority()</code>方法分别用来设置和获取线程的优先级。</p>
<p>每个线程都有默认的优先级。主线程的默认优先级为<code>Thread.NORM_PRIORITY</code>。<br>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。<br>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h3><p>帮我们重复管理线程，避免线程的创建和销毁带来的性能开销</p>
<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p><img src="http://wx2.sinaimg.cn/large/96b7c0f4gy1g0zzdg7e7nj20lv0dv3z3.jpg" alt=""></p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>创建线程池我们需要用到ThreadPoolExecutor。</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)</code></pre><p>构造函数中这些参数的意义：</p>
<p><code>corePoolSize</code>: 核心线程池数量</p>
<ul>
<li>在线程数少于核心数量时，有新任务进来就新建一个线程</li>
<li>等超出核心数量后，就不会新建线程了，而是放到队列中等待</li>
</ul>
<p><code>maximumPoolSize</code>: </p>
<ul>
<li>包括核心线程池数量 + 核心以外的数量</li>
<li>如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务</li>
</ul>
<p><code>keepAliveTime</code>：核心池以外的线程存活时间，即最大线程数多出核心线程数的那部分线程</p>
<ul>
<li>如果给线程池设置 <code>allowCoreThreadTimeOut(true)</code>，则核心线程在空闲时头上也会响起死亡的倒计时</li>
<li>如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务</li>
</ul>
<p><code>workQueue</code>：保存待执行任务的阻塞队列</p>
<p><code>threadFactory</code>：每个线程创建的地方</p>
<ul>
<li>手动实现后可以对线程属性进行设置</li>
</ul>
<p><code>handler</code>：饱和策略，线程池和队列都满了的时候进行的操作</p>
<ul>
<li><code>CallerRunsPolicy</code>：只要线程池没关闭，就直接用调用者所在线程来运行任务</li>
<li><code>AbortPolicy</code>：直接抛出<code>RejectedExecutionException</code>异常</li>
<li><code>DiscardPolicy</code>：忽略任务，不做了</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中时间最久的任务</li>
<li>我们也可以实现自己的<code>RejectedExecutionHandler</code>接口自定义策略</li>
</ul>
<p>常用的用来作保存待执行任务的阻塞队列</p>
<p><code>ArrayBlockingQueue</code>：基于数组、有界，按<code>FIFO</code>（先进先出）原则对元素进行排序<br><code>LinkedBlockingQueue</code>：基于链表，按FIFO （先进先出） 排序元素<br><code>SynchronousQueue</code>：<code>SynchronousQueue</code> 也是一个队列来的，但它的特别之处在于它内部没有容器，一个生产线程，当它生产产品（即<code>put</code>的时候），如果当前没有人想要消费产品(即当前没有线程执行<code>take</code>)，此生产线程必须阻塞，等待一个消费线程调用take操作，<code>take</code>操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先<code>take</code>后<code>put</code>,原理是一样的)。<br><code>PriorityBlockingQueue</code>：具有优先级的、无限阻塞队列</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>线程池运行流程</p>
<p><img src="http://wx1.sinaimg.cn/large/96b7c0f4gy1g0ywrk1dyoj20n50leq3g.jpg" alt=""></p>
<ol>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>,且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>JDK为我们内置了常见线程池的实现，均可以使用Executors工厂类创建。</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}</code></pre><p>可以看出<code>nThreads</code>为核心线程数和最大线程数，由于传入的阻塞队列是无界的，队列可以一直添加至<code>LinkedBlockingQueue</code>的最大值<code>Integer.MAX_VALUE</code>,可能导致OOM。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}</code></pre><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序，按照任务的提交顺序执行</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}</code></pre><p>没有核心线程数，没有核心线程，直接向<code>SynchronousQueue</code>中提交任务，空闲线程存活时间60s，可以看到存储队列用的是<code>SynchronousQueue</code>，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>用来处理延时任务或定时任务</p>
<h3 id="Callable和FutureTask"><a href="#Callable和FutureTask" class="headerlink" title="Callable和FutureTask"></a>Callable和FutureTask</h3><h4 id="callable"><a href="#callable" class="headerlink" title="callable"></a>callable</h4><p>和Runnable类似，但是Callable有返回结果或抛出异常</p>
<pre><code>@FunctionalInterface
public interface Callable&lt;V&gt; {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}</code></pre><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>在线程池中，<code>executorService</code>的<code>submit</code>方法可以返回线程执行结果</p>
<p><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></p>
<p><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</code></p>
<p><code>Future&lt;?&gt; submit(Runnable task);</code></p>
<p><code>FutureTask</code>实现了<code>RunnableFuture</code>接口，而<code>RunnableFuture</code>继承了<code>Runnable</code>和<code>Future</code>接口，所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值</p>
<pre><code>V get() throws InterruptedException, ExecutionException;</code></pre><p>通过<code>future</code>的<code>get</code>方法获取线程运行返回值(阻塞)</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future&lt;Integer&gt; result = executor.submit(task);
        executor.shutdown();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }

        System.out.println(&quot;主线程在执行任务&quot;);

        try {
            System.out.println(&quot;task运行结果&quot;+result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;所有任务执行完毕&quot;);
    }
}
class Task implements Callable&lt;Integer&gt;{
    @Override
    public Integer call() throws Exception {
        System.out.println(&quot;子线程在进行计算&quot;);
        Thread.sleep(3000);
        int sum = 0;
        for(int i=0;i&lt;100;i++)
            sum += i;
        return sum;
    }
}</code></pre><p>大致看一下代码，写下流程</p>
<pre><code>   public Future&lt;?&gt; submit(Runnable task) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);
       execute(ftask);
       return ftask;
   }

   public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
       execute(ftask);
       return ftask;
   }

   public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
       if (task == null) throw new NullPointerException();
       RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
       execute(ftask);
       return ftask;
   }
//以上为AbstractExecutorService实现的三种submit方法

protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
       return new FutureTask&lt;T&gt;(runnable, value);
   }

   protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
       return new FutureTask&lt;T&gt;(callable);
   }
//接着查看newTaskFor方法，创建了FutureTask实例并返回
    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }

//直接成员变量callable接收传入的callable
   public FutureTask(Callable&lt;V&gt; callable) {
       if (callable == null)
           throw new NullPointerException();
       this.callable = callable;
       this.state = NEW;       // ensure visibility of callable
   }


//将Runnable通过适配器模式转接callable接收，查看callable方法
   public FutureTask(Runnable runnable, V result) {
       this.callable = Executors.callable(runnable, result);
       this.state = NEW;       // ensure visibility of callable
   }


   public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {
       if (task == null)
           throw new NullPointerException();
       return new RunnableAdapter&lt;T&gt;(task, result);
   }

   static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {
       final Runnable task;
       final T result;
       RunnableAdapter(Runnable task, T result) {
           this.task = task;
           this.result = result;
       }
       public T call() {
           task.run();
           return result;
       }
   }

//再往回追溯result，submit方法中只有一个参数runnable时，result为null


//此时，创建futuretask完成了(最终的runnable)
//下一步submit方法中执行了excute方法，传入初始化好的futuretask
//查看FutureTask的run方法
   public void run() {
       if (state != NEW ||
           !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                        null, Thread.currentThread()))
           return;
       try {
           Callable&lt;V&gt; c = callable;
           if (c != null &amp;&amp; state == NEW) {
               V result;
               boolean ran;
               try {
                   result = c.call();
                   ran = true;
               } catch (Throwable ex) {
                   result = null;
                   ran = false;
                   setException(ex);
               }
               if (ran)
                   set(result);
           }
       } finally {
           // runner must be non-null until state is settled to
           // prevent concurrent calls to run()
           runner = null;
           // state must be re-read after nulling runner to prevent
           // leaked interrupts
           int s = state;
           if (s &gt;= INTERRUPTING)
               handlePossibleCancellationInterrupt(s);
       }
   }

//大致流程为将我们传入的runnable或callable包装为FutureTask，然后执行FutureTask
//run方法中调用callable的call方法，从上面代码看到，创建FutureTask实例时
//传入一个runnable时，result为null，传入一个runnable和value时，result为
//value，传入的是callable时，result为call方法返回值，然后通过set方法，将
//result传给成员变量outcome,最后return

   protected void set(V v) {
       if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
           outcome = v;
           UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
           finishCompletion();
       }
   }</code></pre><p><code>Future</code>接口还有一个<code>boolean cancel(boolean mayInterruptIfRunning)</code>方法来取消线程运行，参数决定当线程在运行时是否执行中断操作</p>
<p>the mayInterruptIfRunning parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>线程池即使不执行任务也会占用一些资源，所以在我们要退出任务时最好关闭线程池。</p>
<p><code>shutdown()</code>：将线程池的状态设置为<code>SHUTDOWN</code>，然后中断所有没有执行的线程，无法再添加线程。<br><code>shutdownNow()</code>：将线程池设置为 <code>STOP</code>，然后尝试停止所有线程，并返回等待执行任务的列表。</p>
<p><code>isTerminated</code>: 当调用<code>shutdown()</code>方法后，并且所有提交的任务完成后返回为<code>true</code><br><code>isShutDown</code>: 当调用<code>shutdown()</code>方法后返回为<code>true</code>。</p>
<p>创建一个线程池</p>
<pre><code>public class ThreadPoolManager {
    private final String TAG = this.getClass().getSimpleName();
    private static final int CORE_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2; // 核心线程数为 CPU数＊2
    private static final int MAXIMUM_POOL_SIZE = 64;    // 线程队列最大线程数
    private static final int KEEP_ALIVE_TIME = 1;    // 保持存活时间 1秒

    private final BlockingQueue&lt;Runnable&gt; mWorkQueue = new LinkedBlockingQueue&lt;&gt;(128);

    private final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
        private final AtomicInteger mCount = new AtomicInteger(1);

        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r, TAG + &quot; #&quot; + mCount.getAndIncrement());
            thread.setPriority(Thread.NORM_PRIORITY);
            return thread;
        }
    };

    private ThreadPoolExecutor mExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME,
            TimeUnit.SECONDS, mWorkQueue, DEFAULT_THREAD_FACTORY,
            new ThreadPoolExecutor.DiscardOldestPolicy());

    private static volatile ThreadPoolManager mInstance = new ThreadPoolManager();

    public static ThreadPoolManager getInstance() {
        return mInstance;
    }

    public void addTask(Runnable runnable) {
        mExecutor.execute(runnable);
    }


    public void shutdownNow() {
        mExecutor.shutdownNow();
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E7%B4%A2%E5%BC%95/" itemprop="url">索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是索引和索引的作用"><a href="#什么是索引和索引的作用" class="headerlink" title="什么是索引和索引的作用"></a>什么是索引和索引的作用</h3><p><strong>索引是一个单独的、物理的数据库结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单</strong></p>
<p>索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相 关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间</p>
<h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致</strong>，其实理解起来非常简单，还是举字典的例子：如果按照拼音查询，那么都是从a-z的，是具有连续性的，a后面就是b，b后面就是c， 聚集索引就是这样的，他是和表的物理排列顺序是一样的，例如有id为聚集索引，那么1后面肯定是2,2后面肯定是3，所以说这样的搜索顺序的就是聚集索引。非聚集索引就和按照部首查询是一样是，可能按照偏房查询的时候，根据偏旁‘弓’字旁，索引出两个汉字，张和弘，但是这两个其实一个在100页，一个在1000页，（这里只是举个例子），他们的索引顺序和数据库表的排列顺序是不一样的，这个样的就是非聚集索引</p>
<h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><h4 id="InnoDB页结构示意图"><a href="#InnoDB页结构示意图" class="headerlink" title="InnoDB页结构示意图"></a>InnoDB页结构示意图</h4><p><img src="https://www.itcodemonkey.com/data/upload/portal/20190228/1551343343178878.jpg" alt=""></p>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p><img src="https://www.itcodemonkey.com/data/upload/portal/20190228/1551343343125435.jpg" alt=""></p>
<p><strong>每个数据页用双向链表连接，页中的数据使用单向链表存储，数据页的大小为16KB</strong>，每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录，如果以非主键列作为搜索条件，只能从最小记录开始依次遍历单链表中的每条记录。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="http://img.mp.sohu.com/upload/20170713/358025867be14bb99bf8806b98e774d9_th.png" alt=""></p>
<p>以主键索引为例，使用记录主键值的大小进行记录和页的排序，中间节点记录了下层节点主键最大值，如此往上迭代，组成一个B+树，其中只有叶子节点存有数据，其余中间节点仅仅只是索引，不带有数据，在查询的时候，B+树会自顶向下逐层查找节点，直到找到匹配的叶子节点。(相当于根据指定字段，为所有数据页生成一个目录，就可以根据某个字段快速定位数据所在的数据页)</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483701&amp;idx=1&amp;sn=bd229dd584f51ef4fe545d44ad8cdbf9&amp;chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483701&amp;idx=1&amp;sn=bd229dd584f51ef4fe545d44ad8cdbf9&amp;chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4#rd</a></p>
<p><a href="https://www.sohu.com/a/156886901_479559" target="_blank" rel="noopener">https://www.sohu.com/a/156886901_479559</a></p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ol>
<li><p>普通索引index :加速查找</p>
</li>
<li><p>唯一索引</p>
</li>
</ol>
<ul>
<li>主键索引：primary key ：加速查找+约束（不为空且唯一）</li>
<li>唯一索引：unique：加速查找+约束 （唯一）</li>
</ul>
<ol start="3">
<li>联合索引</li>
</ol>
<ul>
<li>primary key(id,name):联合主键索引</li>
<li>unique(id,name):联合唯一索引</li>
<li>index(id,name):联合普通索引</li>
</ul>
<ol start="4">
<li>全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。</li>
<li>空间索引spatial :了解就好，几乎不用</li>
</ol>
<h3 id="索引的运用"><a href="#索引的运用" class="headerlink" title="索引的运用"></a>索引的运用</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<p><code>CREATE INDEX 索引名 ON 表(字段(长度))</code></p>
<p><code>ALTER TABLE 表 ADD INDEX 索引名(字段(长度))</code></p>
<p>在建表时<code>INDEX 表 (字段(长度))</code></p>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>主键就是唯一索引的一种，主键要求建表时指定，一般用auto_increment列，关键字是primary key。它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<p><code>CREATE UNIQUE INDEX 索引名 ON 表(字段(长度))</code></p>
<p>`ALTER TABLE 表 ADD UNIQUE <a href="字段(长度)">索引名</a></p>
<p>在建表时<code>UNIQUE [索引名] (字段(长度))</code></p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p><code>CREATE INDEX 索引名 ON 表(字段(长度),字段(长度))</code></p>
<p><code>ALTER TABLE 表 ADD INDEX [索引名](字段(长度),字段(长度))</code></p>
<p>在建表时<code>INDEX [索引名] (字段(长度),字段(长度))</code></p>
<h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><ol>
<li>经常需要搜索的列上，可以加快搜索的速度</li>
<li>作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
<li>经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</li>
<li>经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
<li>经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li>
<li>经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引， 那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>索引的最左匹配特性（即从左往右匹配）：如果以a,b,c三个字段建立多列索引，则在使用a,ab,abc作为检索条件时都能使用这个多列索引</li>
<li>索引字段要尽量的小：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表</li>
<li>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器<br>会帮你优化成索引可以识别的形式</li>
<li>MySQL只对一下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形)</li>
<li>select from users where YEAR(adddate)&lt;2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select from users where adddate&lt;’2007-01-01′</li>
<li>要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E7%B1%BB%E4%B8%AD%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E7%B1%BB%E4%B8%AD%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA/" itemprop="url">类中静态变量初始化时机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性为类属性，所有由它来实例化的对象共享该属性，所以静态属性在类的生命周期中，只在类被初始化时被初始化一次(final类型的静态变量在编译时初始化)</p>
<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>什么时候会触发类的初始化呢</p>
<ol>
<li><code>new</code>关键字</li>
<li>访问类的静态变量时</li>
<li>调用类的静态方法时</li>
<li>反射，例如<code>Class.forName()</code></li>
<li>子类被初始化时</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
</ol>
<h3 id="final类型的静态属性"><a href="#final类型的静态属性" class="headerlink" title="final类型的静态属性"></a>final类型的静态属性</h3><ol>
<li>当<code>final</code>属性编译时就确定时，访问该属性不会触发类的初始化，例如</li>
</ol>
<pre><code>public static final int a =1</code></pre><p>在以下情况访问类变量<code>a</code>时，会触发初始化</p>
<pre><code>public static final int a;
static{
    a = 1;
    System.out.println(&quot;out&quot;);
}</code></pre><p>和</p>
<pre><code>public static int a;

public ttt() {
    a = 1;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E7%B1%BB%E4%B8%AD%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E7%B1%BB%E4%B8%AD%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/" itemprop="url">类中变量初始化顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>当第一次加载初始化一个类的时候，首先执行静态代码块和静态变量初始化(按照先后顺序）,然后执行非静态代码块和非静态变量初始化(按照先后顺序),最后执行构造函数</p>
<p>当涉及到继承关系时</p>
<pre><code>class father{
    static{
        System.out.println(&quot;父类静态代码块&quot;);
    }

    {
        System.out.println(&quot;父类非静态代码块&quot;);
    }

    public father(){
        System.out.println(&quot;父类构造函数&quot;);
    }
}

class son extends father{
    static{
        System.out.println(&quot;子类静态代码块&quot;);
    }
    {
        System.out.println(&quot;子类非静态代码块&quot;);
    }
    public son(){
        System.out.println(&quot;子类构造函数&quot;);
    }
}

执行 new son();</code></pre><p>得到结果</p>
<pre><code>父类静态代码块
子类静态代码块
父类非静态代码块
父类构造函数
子类非静态代码块
子类构造函数</code></pre><p>当子类和父类都未被加载过时，初始化一个子类，首先执行父类静态代码块和静态变量初始化(按照先后顺序)，然后执行子类静态代码块和静态变量初始化(按照先后顺序)，然后执行父类非静态代码块和非静态变量初始化(按照先后顺序)，再执行父类构造方法，然后执行子类非静态方法和非静态变量初始化(按照先后顺序)，再执行子类构造方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/17/%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinaill">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/17/%E6%B3%9B%E5%9E%8B/" itemprop="url">泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-17T01:43:37+08:00">
                2020-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是泛型，为什么要使用泛型"><a href="#什么是泛型，为什么要使用泛型" class="headerlink" title="什么是泛型，为什么要使用泛型"></a>什么是泛型，为什么要使用泛型</h3><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<p>如果你定义了一个泛型（类、接口），那么Java规定，你不能在所有的静态方法、静态初块等所有静态内容中使用泛型的类型参数</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code>class generic&lt;T&gt;{
    T element;
}</code></pre><p>创建对象时指定T的参数类型例如<code>new generic&lt;Integer&gt;</code>，将成员变量的类型参数化</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code>interface generic&lt;T&gt;{
    public T get();
}</code></pre><p>若实现类中确定了参数类型，在实现接口时可以指定，<code>class a implements generic&lt;Integer&gt;</code>，若不确定参数类型，<code>class a&lt;T&gt; implements generic&lt;T&gt;</code>，用法一样</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在非泛型类中定义泛型方法，格式为：修饰符 返回值类型 方法名(形参列表)</p>
<ul>
<li>public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法</li>
<li>只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法</li>
<li><T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T</li>
<li>与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</li>
</ul>
<pre><code>class Method{
    public &lt;T&gt; void out(T a){
        System.out.println(a.getClass().getName());
    }
}

public class Generic{
    public static void main(String[] args) {
        Method m = new Method();
        m.out(&quot;sss&quot;);//输出java.lang.String
        m.out(1);//输出java.lang.Integer
    }
}</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul>
<li>？表示类型参数赋予不确定值，任意类型</li>
<li><strong>只能用在声明类型、方法参数上，不能用在定义泛型类上</strong></li>
</ul>
<pre><code>public static void main(String[] args) {
    List&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;();
    List&lt;String&gt; l2 = new ArrayList&lt;String&gt;();
    l1.add(1);
    l1.add(2);
    l2.add(&quot;aaa&quot;);
    l2.add(&quot;bbb&quot;);
    out1(l1);
    out1(l2);
    out2(l1);
    out2(l2);//报错
}

public static void out1(List&lt;?&gt; list){

}
public static void out2(List&lt;Integer&gt; list){

}</code></pre><p>使用了通配符？定义的泛型变量和形参可以接受所有类型的同一泛型变量(不包括子类)，如下</p>
<pre><code>// 用在形参上
public static void test(List&lt;?&gt; list) {

 List&lt;?&gt; list2; // 用在声明变量上
 list2 = new ArrayList&lt;String&gt;();
 list2 = new ArrayList&lt;Integer&gt;();
 list2 = new ArrayList&lt;Object&gt;();

}

public static void main(String[] args) {
 test(new ArrayList&lt;String&gt;());
 test(new ArrayList&lt;Integer&gt;());
}</code></pre><h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类</p>
<p>&lt;? extends T&gt;和&lt;? super T&gt;是Java泛型中的”通配符(Wildcards)”和”边界(Bounds)”的概念</p>
<ul>
<li>&lt;? extends T&gt;：是指 “上界通配符(Upper Bounds Wildcards)”，&lt;=</li>
<li>&lt;? super T&gt;：是指 “下界通配符(Lower Bounds Wildcards)”，&gt;=</li>
</ul>
<ol>
<li>定义泛型类时使用，限定参数范围</li>
</ol>
<pre><code>public class Generic&lt;T extends Number&gt;{
    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}</code></pre><ol start="2">
<li>作为变量时使用</li>
</ol>
<p><code>List</code>的<code>add</code>方法不能添加任何有意义的元素，但是可以接受现有的子类型<code>List</code>赋值</p>
<pre><code>List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;();
list.add(1);//报错</code></pre><ol start="3">
<li>作为形参时使用</li>
</ol>
<pre><code>class Method{
    public void out(List&lt;? extends Number&gt; a){

    }
}</code></pre><h3 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h3><pre><code>/**
 * 泛型继承
 *
 * 保留父类泛型 ----》泛型子类 
 * 不保留父类泛型 -----》子类按需实现
 *
 * 子类重写父类的方法，泛型类型随父类而定 子类使用父类的属性，该属性类型随父类定义的泛型
 *
 * @author Administrator
 *
 * @param &lt;T1&gt;
 * @param &lt;T2&gt;
 */
public abstract class Father&lt;T1, T2&gt; {
  T1 age;

  public abstract void test(T2 name);
}

// 保留父类泛型 ----》泛型子类
// 1）全部保留
class C1&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; {

  @Override
  public void test(T2 name) {

  }
}

// 2) 部分保留
class C2&lt;T1&gt; extends Father&lt;T1, Integer&gt; {

  @Override
  public void test(Integer name) {

  }
}

// 不保留父类泛型 -----》子类按需实现
// 1)具体类型
class C3 extends Father&lt;String, Integer&gt; {

  @Override
  public void test(Integer name) {

  }
}

// 2)没有具体类型
// 泛型擦除：实现或继承父类的子类，没有指定类型，类似于Object
class C4 extends Father {

  @Override
  public void test(Object name) {

  }

}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinaill</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinaill</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <link rel="stylesheet" href="/lib/prettify/skins/sunburst.css" type="text/css">
<script src="/lib/prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
      prettyPrint();
  });
</script>
</body>
</html>
